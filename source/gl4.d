/**
 * This is a set of OpenGL bindings.
 *
 * Generated by ./ogl_gen ....
 * Do not modify. Regenerate if changes are required.
 *
 * Macros:
 *    D_CODE = <pre><code class="D">$0</code></pre>
 */
module opengl.gl4;
import std.traits : Unqual;

alias int64_t = long;
alias uint64_t = ulong;
alias int32_t = int;

///
alias GLboolean = bool;
///
alias GLbyte = byte;
///
alias GLubyte = ubyte;
///
alias GLshort = short;
///
alias GLushort = ushort;
///
alias GLhalf = ushort;
///
alias GLint = int;
///
alias GLuint = uint;
///
alias GLfixed = int;
///
alias GLint64 = long;
///
alias GLuint64 = ulong;
///
alias GLsizei = uint;
///
alias GLenum = uint;
///
alias GLintptr = ptrdiff_t;
///
alias GLsizeiptr = ptrdiff_t;
///
alias GLsync = void*;
///
alias GLbitfield = uint;
///
alias GLfloat = float;
///
alias GLclampf = float;
///
alias GLdouble = double;
///
alias GLclampd = double;
///
alias GLclampx = int;
///
alias GLchar = char;
///
alias GLuintptr = size_t;
///
alias GLvoid = void;
///
alias GLeglImageOES = void*;
///
alias GLcharARB = char;
///
alias GLhandleARB = uint;
///
alias GLhalfARB = ushort;
///
alias Glfixed = GLint;

///
struct _cl_context;
///
struct _cl_event;

///
alias GLDEBUGPROC = extern(C) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const(GLchar)* message, void* userParam);
///
alias GLDEBUGPROCARB = extern(C) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const(GLchar)* message, void* userParam);
///
alias GLDEBUGPROCKHR = extern(C) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const(GLchar)* message, void* userParam);

///
alias GLintptrARB = ptrdiff_t;
///
alias GLsizeiptrARB = ptrdiff_t;
///
alias GLint64EXT = int64_t;
///
alias GLuint64EXT = uint64_t;

///
alias GLDEBUGPROCAMD = extern(C) void function(GLuint id, GLenum category, GLenum severity, GLsizei length, const(GLchar)* message, void* userParam);
///
alias GLhalfNV = ushort;
///
alias GLvdpauSurfaceNV = GLintptr;

///
struct GLUnurbs;
///
struct GLUquadric;
///
struct GLUtesselator;
///
alias _GLUfuncptr = extern(C) void function();

struct OpenGL_Version {
	OGLIntroducedIn from;
}

struct OpenGL_Extension {
	string name;
}

enum OGLIntroducedIn : ushort {
	Unknown,
	V1P0 = 10,
	V1P1 = 11,
	V1P2 = 12,
	V1P3 = 13,
	V1P4 = 14,
	V1P5 = 15,
	V2P0 = 25,
	V2P1 = 21,
	V2P2 = 22,
	V3P0 = 30,
	V3P1 = 31,
	V3P2 = 32,
	V3P3 = 33,
	V4P0 = 40,
	V4P1 = 41,
	V4P2 = 42,
	V4P3 = 43,
	V4P4 = 44,
	V4P5 = 45,
}

struct Bitmaskable {}
enum GL_1PASS_EXT = 0x80A1; ///
enum GL_1PASS_SGIS = 0x80A1; ///
enum GL_2D = 0x0600; ///
enum GL_2PASS_0_EXT = 0x80A2; ///
enum GL_2PASS_0_SGIS = 0x80A2; ///
enum GL_2PASS_1_EXT = 0x80A3; ///
enum GL_2PASS_1_SGIS = 0x80A3; ///
enum GL_2X_BIT_ATI = 0x00000001; ///
enum GL_2_BYTES = 0x1407; ///
enum GL_2_BYTES_NV = 0x1407; ///
enum GL_3D = 0x0601; ///
enum GL_3DC_XY_AMD = 0x87FA; ///
enum GL_3DC_X_AMD = 0x87F9; ///
enum GL_3D_COLOR = 0x0602; ///
enum GL_3D_COLOR_TEXTURE = 0x0603; ///
enum GL_3_BYTES = 0x1408; ///
enum GL_3_BYTES_NV = 0x1408; ///
enum GL_422_AVERAGE_EXT = 0x80CE; ///
enum GL_422_EXT = 0x80CC; ///
enum GL_422_REV_AVERAGE_EXT = 0x80CF; ///
enum GL_422_REV_EXT = 0x80CD; ///
enum GL_4D_COLOR_TEXTURE = 0x0604; ///
enum GL_4PASS_0_EXT = 0x80A4; ///
enum GL_4PASS_0_SGIS = 0x80A4; ///
enum GL_4PASS_1_EXT = 0x80A5; ///
enum GL_4PASS_1_SGIS = 0x80A5; ///
enum GL_4PASS_2_EXT = 0x80A6; ///
enum GL_4PASS_2_SGIS = 0x80A6; ///
enum GL_4PASS_3_EXT = 0x80A7; ///
enum GL_4PASS_3_SGIS = 0x80A7; ///
enum GL_4X_BIT_ATI = 0x00000002; ///
enum GL_4_BYTES = 0x1409; ///
enum GL_4_BYTES_NV = 0x1409; ///
enum GL_8X_BIT_ATI = 0x00000004; ///
enum GL_ABGR_EXT = 0x8000; ///
enum GL_ACCUM = 0x0100; ///
enum GL_ACCUM_ADJACENT_PAIRS_NV = 0x90AD; ///
enum GL_ACCUM_ALPHA_BITS = 0x0D5B; ///
enum GL_ACCUM_BLUE_BITS = 0x0D5A; ///
enum GL_ACCUM_BUFFER_BIT = 0x00000200; ///
enum GL_ACCUM_CLEAR_VALUE = 0x0B80; ///
enum GL_ACCUM_GREEN_BITS = 0x0D59; ///
enum GL_ACCUM_RED_BITS = 0x0D58; ///
enum GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = 0x92D9; ///
enum GL_ACTIVE_ATTRIBUTES = 0x8B89; ///
enum GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A; ///
enum GL_ACTIVE_PROGRAM = 0x8259; ///
enum GL_ACTIVE_PROGRAM_EXT = 0x8B8D; ///
enum GL_ACTIVE_RESOURCES = 0x92F5; ///
enum GL_ACTIVE_STENCIL_FACE_EXT = 0x8911; ///
enum GL_ACTIVE_SUBROUTINES = 0x8DE5; ///
enum GL_ACTIVE_SUBROUTINE_MAX_LENGTH = 0x8E48; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORMS = 0x8DE6; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49; ///
enum GL_ACTIVE_TEXTURE = 0x84E0; ///
enum GL_ACTIVE_TEXTURE_ARB = 0x84E0; ///
enum GL_ACTIVE_UNIFORMS = 0x8B86; ///
enum GL_ACTIVE_UNIFORM_BLOCKS = 0x8A36; ///
enum GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35; ///
enum GL_ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87; ///
enum GL_ACTIVE_VARIABLES = 0x9305; ///
enum GL_ACTIVE_VARYINGS_NV = 0x8C81; ///
enum GL_ACTIVE_VARYING_MAX_LENGTH_NV = 0x8C82; ///
enum GL_ACTIVE_VERTEX_UNITS_ARB = 0x86A5; ///
enum GL_ADD = 0x0104; ///
enum GL_ADD_ATI = 0x8963; ///
enum GL_ADD_BLEND_IMG = 0x8C09; ///
enum GL_ADD_SIGNED = 0x8574; ///
enum GL_ADD_SIGNED_ARB = 0x8574; ///
enum GL_ADD_SIGNED_EXT = 0x8574; ///
enum GL_ADJACENT_PAIRS_NV = 0x90AE; ///
enum GL_AFFINE_2D_NV = 0x9092; ///
enum GL_AFFINE_3D_NV = 0x9094; ///
enum GL_ALIASED_LINE_WIDTH_RANGE = 0x846E; ///
enum GL_ALIASED_POINT_SIZE_RANGE = 0x846D; ///
enum GL_ALLOW_DRAW_FRG_HINT_PGI = 0x1A210; ///
enum GL_ALLOW_DRAW_MEM_HINT_PGI = 0x1A211; ///
enum GL_ALLOW_DRAW_OBJ_HINT_PGI = 0x1A20E; ///
enum GL_ALLOW_DRAW_WIN_HINT_PGI = 0x1A20F; ///
enum GL_ALL_ATTRIB_BITS = 0xFFFFFFFF; ///
enum GL_ALL_BARRIER_BITS = 0xFFFFFFFF; ///
enum GL_ALL_BARRIER_BITS_EXT = 0xFFFFFFFF; ///
enum GL_ALL_COMPLETED_NV = 0x84F2; ///
enum GL_ALL_SHADER_BITS = 0xFFFFFFFF; ///
enum GL_ALL_SHADER_BITS_EXT = 0xFFFFFFFF; ///
enum GL_ALL_STATIC_DATA_IBM = 0x103060; ///
enum GL_ALPHA = 0x1906; ///
enum GL_ALPHA12 = 0x803D; ///
enum GL_ALPHA12_EXT = 0x803D; ///
enum GL_ALPHA16 = 0x803E; ///
enum GL_ALPHA16F_ARB = 0x881C; ///
enum GL_ALPHA16F_EXT = 0x881C; ///
enum GL_ALPHA16I_EXT = 0x8D8A; ///
enum GL_ALPHA16UI_EXT = 0x8D78; ///
enum GL_ALPHA16_EXT = 0x803E; ///
enum GL_ALPHA16_SNORM = 0x9018; ///
enum GL_ALPHA32F_ARB = 0x8816; ///
enum GL_ALPHA32F_EXT = 0x8816; ///
enum GL_ALPHA32I_EXT = 0x8D84; ///
enum GL_ALPHA32UI_EXT = 0x8D72; ///
enum GL_ALPHA4 = 0x803B; ///
enum GL_ALPHA4_EXT = 0x803B; ///
enum GL_ALPHA8 = 0x803C; ///
enum GL_ALPHA8I_EXT = 0x8D90; ///
enum GL_ALPHA8UI_EXT = 0x8D7E; ///
enum GL_ALPHA8_EXT = 0x803C; ///
enum GL_ALPHA8_OES = 0x803C; ///
enum GL_ALPHA8_SNORM = 0x9014; ///
enum GL_ALPHA_BIAS = 0x0D1D; ///
enum GL_ALPHA_BITS = 0x0D55; ///
enum GL_ALPHA_FLOAT16_APPLE = 0x881C; ///
enum GL_ALPHA_FLOAT16_ATI = 0x881C; ///
enum GL_ALPHA_FLOAT32_APPLE = 0x8816; ///
enum GL_ALPHA_FLOAT32_ATI = 0x8816; ///
enum GL_ALPHA_INTEGER = 0x8D97; ///
enum GL_ALPHA_INTEGER_EXT = 0x8D97; ///
enum GL_ALPHA_MAX_CLAMP_INGR = 0x8567; ///
enum GL_ALPHA_MAX_SGIX = 0x8321; ///
enum GL_ALPHA_MIN_CLAMP_INGR = 0x8563; ///
enum GL_ALPHA_MIN_SGIX = 0x8320; ///
enum GL_ALPHA_REF_COMMAND_NV = 0x000F; ///
enum GL_ALPHA_SCALE = 0x0D1C; ///
enum GL_ALPHA_SNORM = 0x9010; ///
enum GL_ALPHA_TEST = 0x0BC0; ///
enum GL_ALPHA_TEST_FUNC = 0x0BC1; ///
enum GL_ALPHA_TEST_FUNC_QCOM = 0x0BC1; ///
enum GL_ALPHA_TEST_QCOM = 0x0BC0; ///
enum GL_ALPHA_TEST_REF = 0x0BC2; ///
enum GL_ALPHA_TEST_REF_QCOM = 0x0BC2; ///
enum GL_ALREADY_SIGNALED = 0x911A; ///
enum GL_ALREADY_SIGNALED_APPLE = 0x911A; ///
enum GL_ALWAYS = 0x0207; ///
enum GL_ALWAYS_FAST_HINT_PGI = 0x1A20C; ///
enum GL_ALWAYS_SOFT_HINT_PGI = 0x1A20D; ///
enum GL_AMBIENT = 0x1200; ///
enum GL_AMBIENT_AND_DIFFUSE = 0x1602; ///
enum GL_AND = 0x1501; ///
enum GL_AND_INVERTED = 0x1504; ///
enum GL_AND_REVERSE = 0x1502; ///
enum GL_ANY_SAMPLES_PASSED = 0x8C2F; ///
enum GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A; ///
enum GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT = 0x8D6A; ///
enum GL_ANY_SAMPLES_PASSED_EXT = 0x8C2F; ///
enum GL_ARC_TO_NV = 0xFE; ///
enum GL_ARRAY_BUFFER = 0x8892; ///
enum GL_ARRAY_BUFFER_ARB = 0x8892; ///
enum GL_ARRAY_BUFFER_BINDING = 0x8894; ///
enum GL_ARRAY_BUFFER_BINDING_ARB = 0x8894; ///
enum GL_ARRAY_ELEMENT_LOCK_COUNT_EXT = 0x81A9; ///
enum GL_ARRAY_ELEMENT_LOCK_FIRST_EXT = 0x81A8; ///
enum GL_ARRAY_OBJECT_BUFFER_ATI = 0x8766; ///
enum GL_ARRAY_OBJECT_OFFSET_ATI = 0x8767; ///
enum GL_ARRAY_SIZE = 0x92FB; ///
enum GL_ARRAY_STRIDE = 0x92FE; ///
enum GL_ASYNC_DRAW_PIXELS_SGIX = 0x835D; ///
enum GL_ASYNC_HISTOGRAM_SGIX = 0x832C; ///
enum GL_ASYNC_MARKER_SGIX = 0x8329; ///
enum GL_ASYNC_READ_PIXELS_SGIX = 0x835E; ///
enum GL_ASYNC_TEX_IMAGE_SGIX = 0x835C; ///
enum GL_ATC_RGBA_EXPLICIT_ALPHA_AMD = 0x8C93; ///
enum GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD = 0x87EE; ///
enum GL_ATC_RGB_AMD = 0x8C92; ///
enum GL_ATOMIC_COUNTER_BARRIER_BIT = 0x00001000; ///
enum GL_ATOMIC_COUNTER_BARRIER_BIT_EXT = 0x00001000; ///
enum GL_ATOMIC_COUNTER_BUFFER = 0x92C0; ///
enum GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5; ///
enum GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6; ///
enum GL_ATOMIC_COUNTER_BUFFER_BINDING = 0x92C1; ///
enum GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4; ///
enum GL_ATOMIC_COUNTER_BUFFER_INDEX = 0x9301; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = 0x90ED; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7; ///
enum GL_ATOMIC_COUNTER_BUFFER_SIZE = 0x92C3; ///
enum GL_ATOMIC_COUNTER_BUFFER_START = 0x92C2; ///
enum GL_ATTACHED_SHADERS = 0x8B85; ///
enum GL_ATTENUATION_EXT = 0x834D; ///
enum GL_ATTRIBUTE_ADDRESS_COMMAND_NV = 0x0009; ///
enum GL_ATTRIB_ARRAY_POINTER_NV = 0x8645; ///
enum GL_ATTRIB_ARRAY_SIZE_NV = 0x8623; ///
enum GL_ATTRIB_ARRAY_STRIDE_NV = 0x8624; ///
enum GL_ATTRIB_ARRAY_TYPE_NV = 0x8625; ///
enum GL_ATTRIB_STACK_DEPTH = 0x0BB0; ///
enum GL_AUTO_GENERATE_MIPMAP = 0x8295; ///
enum GL_AUTO_NORMAL = 0x0D80; ///
enum GL_AUX0 = 0x0409; ///
enum GL_AUX1 = 0x040A; ///
enum GL_AUX2 = 0x040B; ///
enum GL_AUX3 = 0x040C; ///
enum GL_AUX_BUFFERS = 0x0C00; ///
enum GL_AUX_DEPTH_STENCIL_APPLE = 0x8A14; ///
enum GL_AVERAGE_EXT = 0x8335; ///
enum GL_AVERAGE_HP = 0x8160; ///
enum GL_BACK = 0x0405; ///
enum GL_BACK_LEFT = 0x0402; ///
enum GL_BACK_NORMALS_HINT_PGI = 0x1A223; ///
enum GL_BACK_PRIMARY_COLOR_NV = 0x8C77; ///
enum GL_BACK_RIGHT = 0x0403; ///
enum GL_BACK_SECONDARY_COLOR_NV = 0x8C78; ///
enum GL_BEVEL_NV = 0x90A6; ///
enum GL_BGR = 0x80E0; ///
enum GL_BGRA = 0x80E1; ///
enum GL_BGRA8_EXT = 0x93A1; ///
enum GL_BGRA_EXT = 0x80E1; ///
enum GL_BGRA_IMG = 0x80E1; ///
enum GL_BGRA_INTEGER = 0x8D9B; ///
enum GL_BGRA_INTEGER_EXT = 0x8D9B; ///
enum GL_BGR_EXT = 0x80E0; ///
enum GL_BGR_INTEGER = 0x8D9A; ///
enum GL_BGR_INTEGER_EXT = 0x8D9A; ///
enum GL_BIAS_BIT_ATI = 0x00000008; ///
enum GL_BIAS_BY_NEGATIVE_ONE_HALF_NV = 0x8541; ///
enum GL_BINNING_CONTROL_HINT_QCOM = 0x8FB0; ///
enum GL_BINORMAL_ARRAY_EXT = 0x843A; ///
enum GL_BINORMAL_ARRAY_POINTER_EXT = 0x8443; ///
enum GL_BINORMAL_ARRAY_STRIDE_EXT = 0x8441; ///
enum GL_BINORMAL_ARRAY_TYPE_EXT = 0x8440; ///
enum GL_BITMAP = 0x1A00; ///
enum GL_BITMAP_TOKEN = 0x0704; ///
enum GL_BLEND = 0x0BE2; ///
enum GL_BLEND_ADVANCED_COHERENT_KHR = 0x9285; ///
enum GL_BLEND_ADVANCED_COHERENT_NV = 0x9285; ///
enum GL_BLEND_COLOR = 0x8005; ///
enum GL_BLEND_COLOR_COMMAND_NV = 0x000B; ///
enum GL_BLEND_COLOR_EXT = 0x8005; ///
enum GL_BLEND_DST = 0x0BE0; ///
enum GL_BLEND_DST_ALPHA = 0x80CA; ///
enum GL_BLEND_DST_ALPHA_EXT = 0x80CA; ///
enum GL_BLEND_DST_ALPHA_OES = 0x80CA; ///
enum GL_BLEND_DST_RGB = 0x80C8; ///
enum GL_BLEND_DST_RGB_EXT = 0x80C8; ///
enum GL_BLEND_DST_RGB_OES = 0x80C8; ///
enum GL_BLEND_EQUATION = 0x8009; ///
enum GL_BLEND_EQUATION_ALPHA = 0x883D; ///
enum GL_BLEND_EQUATION_ALPHA_EXT = 0x883D; ///
enum GL_BLEND_EQUATION_ALPHA_OES = 0x883D; ///
enum GL_BLEND_EQUATION_EXT = 0x8009; ///
enum GL_BLEND_EQUATION_OES = 0x8009; ///
enum GL_BLEND_EQUATION_RGB = 0x8009; ///
enum GL_BLEND_EQUATION_RGB_EXT = 0x8009; ///
enum GL_BLEND_EQUATION_RGB_OES = 0x8009; ///
enum GL_BLEND_OVERLAP_NV = 0x9281; ///
enum GL_BLEND_PREMULTIPLIED_SRC_NV = 0x9280; ///
enum GL_BLEND_SRC = 0x0BE1; ///
enum GL_BLEND_SRC_ALPHA = 0x80CB; ///
enum GL_BLEND_SRC_ALPHA_EXT = 0x80CB; ///
enum GL_BLEND_SRC_ALPHA_OES = 0x80CB; ///
enum GL_BLEND_SRC_RGB = 0x80C9; ///
enum GL_BLEND_SRC_RGB_EXT = 0x80C9; ///
enum GL_BLEND_SRC_RGB_OES = 0x80C9; ///
enum GL_BLOCK_INDEX = 0x92FD; ///
enum GL_BLUE = 0x1905; ///
enum GL_BLUE_BIAS = 0x0D1B; ///
enum GL_BLUE_BITS = 0x0D54; ///
enum GL_BLUE_BIT_ATI = 0x00000004; ///
enum GL_BLUE_INTEGER = 0x8D96; ///
enum GL_BLUE_INTEGER_EXT = 0x8D96; ///
enum GL_BLUE_MAX_CLAMP_INGR = 0x8566; ///
enum GL_BLUE_MIN_CLAMP_INGR = 0x8562; ///
enum GL_BLUE_NV = 0x1905; ///
enum GL_BLUE_SCALE = 0x0D1A; ///
enum GL_BOLD_BIT_NV = 0x01; ///
enum GL_BOOL = 0x8B56; ///
enum GL_BOOL_ARB = 0x8B56; ///
enum GL_BOOL_VEC2 = 0x8B57; ///
enum GL_BOOL_VEC2_ARB = 0x8B57; ///
enum GL_BOOL_VEC3 = 0x8B58; ///
enum GL_BOOL_VEC3_ARB = 0x8B58; ///
enum GL_BOOL_VEC4 = 0x8B59; ///
enum GL_BOOL_VEC4_ARB = 0x8B59; ///
enum GL_BOUNDING_BOX_NV = 0x908D; ///
enum GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV = 0x909C; ///
enum GL_BROWSER_DEFAULT_WEBGL = 0x9244; ///
enum GL_BUFFER = 0x82E0; ///
enum GL_BUFFER_ACCESS = 0x88BB; ///
enum GL_BUFFER_ACCESS_ARB = 0x88BB; ///
enum GL_BUFFER_ACCESS_FLAGS = 0x911F; ///
enum GL_BUFFER_ACCESS_OES = 0x88BB; ///
enum GL_BUFFER_BINDING = 0x9302; ///
enum GL_BUFFER_DATA_SIZE = 0x9303; ///
enum GL_BUFFER_FLUSHING_UNMAP_APPLE = 0x8A13; ///
enum GL_BUFFER_GPU_ADDRESS_NV = 0x8F1D; ///
enum GL_BUFFER_IMMUTABLE_STORAGE = 0x821F; ///
enum GL_BUFFER_IMMUTABLE_STORAGE_EXT = 0x821F; ///
enum GL_BUFFER_KHR = 0x82E0; ///
enum GL_BUFFER_MAPPED = 0x88BC; ///
enum GL_BUFFER_MAPPED_ARB = 0x88BC; ///
enum GL_BUFFER_MAPPED_OES = 0x88BC; ///
enum GL_BUFFER_MAP_LENGTH = 0x9120; ///
enum GL_BUFFER_MAP_OFFSET = 0x9121; ///
enum GL_BUFFER_MAP_POINTER = 0x88BD; ///
enum GL_BUFFER_MAP_POINTER_ARB = 0x88BD; ///
enum GL_BUFFER_MAP_POINTER_OES = 0x88BD; ///
enum GL_BUFFER_OBJECT_APPLE = 0x85B3; ///
enum GL_BUFFER_OBJECT_EXT = 0x9151; ///
enum GL_BUFFER_SERIALIZED_MODIFY_APPLE = 0x8A12; ///
enum GL_BUFFER_SIZE = 0x8764; ///
enum GL_BUFFER_SIZE_ARB = 0x8764; ///
enum GL_BUFFER_STORAGE_FLAGS = 0x8220; ///
enum GL_BUFFER_STORAGE_FLAGS_EXT = 0x8220; ///
enum GL_BUFFER_UPDATE_BARRIER_BIT = 0x00000200; ///
enum GL_BUFFER_UPDATE_BARRIER_BIT_EXT = 0x00000200; ///
enum GL_BUFFER_USAGE = 0x8765; ///
enum GL_BUFFER_USAGE_ARB = 0x8765; ///
enum GL_BUFFER_VARIABLE = 0x92E5; ///
enum GL_BUMP_ENVMAP_ATI = 0x877B; ///
enum GL_BUMP_NUM_TEX_UNITS_ATI = 0x8777; ///
enum GL_BUMP_ROT_MATRIX_ATI = 0x8775; ///
enum GL_BUMP_ROT_MATRIX_SIZE_ATI = 0x8776; ///
enum GL_BUMP_TARGET_ATI = 0x877C; ///
enum GL_BUMP_TEX_UNITS_ATI = 0x8778; ///
enum GL_BYTE = 0x1400; ///
enum GL_C3F_V3F = 0x2A24; ///
enum GL_C4F_N3F_V3F = 0x2A26; ///
enum GL_C4UB_V2F = 0x2A22; ///
enum GL_C4UB_V3F = 0x2A23; ///
enum GL_CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183; ///
enum GL_CAVEAT_SUPPORT = 0x82B8; ///
enum GL_CCW = 0x0901; ///
enum GL_CIRCULAR_CCW_ARC_TO_NV = 0xF8; ///
enum GL_CIRCULAR_CW_ARC_TO_NV = 0xFA; ///
enum GL_CIRCULAR_TANGENT_ARC_TO_NV = 0xFC; ///
enum GL_CLAMP = 0x2900; ///
enum GL_CLAMP_FRAGMENT_COLOR = 0x891B; ///
enum GL_CLAMP_FRAGMENT_COLOR_ARB = 0x891B; ///
enum GL_CLAMP_READ_COLOR = 0x891C; ///
enum GL_CLAMP_READ_COLOR_ARB = 0x891C; ///
enum GL_CLAMP_TO_BORDER = 0x812D; ///
enum GL_CLAMP_TO_BORDER_ARB = 0x812D; ///
enum GL_CLAMP_TO_BORDER_EXT = 0x812D; ///
enum GL_CLAMP_TO_BORDER_NV = 0x812D; ///
enum GL_CLAMP_TO_BORDER_OES = 0x812D; ///
enum GL_CLAMP_TO_BORDER_SGIS = 0x812D; ///
enum GL_CLAMP_TO_EDGE = 0x812F; ///
enum GL_CLAMP_TO_EDGE_SGIS = 0x812F; ///
enum GL_CLAMP_VERTEX_COLOR = 0x891A; ///
enum GL_CLAMP_VERTEX_COLOR_ARB = 0x891A; ///
enum GL_CLEAR = 0x1500; ///
enum GL_CLEAR_BUFFER = 0x82B4; ///
enum GL_CLEAR_TEXTURE = 0x9365; ///
enum GL_CLIENT_ACTIVE_TEXTURE = 0x84E1; ///
enum GL_CLIENT_ACTIVE_TEXTURE_ARB = 0x84E1; ///
enum GL_CLIENT_ALL_ATTRIB_BITS = 0xFFFFFFFF; ///
enum GL_CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1; ///
enum GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000; ///
enum GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT = 0x00004000; ///
enum GL_CLIENT_PIXEL_STORE_BIT = 0x00000001; ///
enum GL_CLIENT_STORAGE_BIT = 0x0200; ///
enum GL_CLIENT_STORAGE_BIT_EXT = 0x0200; ///
enum GL_CLIENT_VERTEX_ARRAY_BIT = 0x00000002; ///
enum GL_CLIPPING_INPUT_PRIMITIVES_ARB = 0x82F6; ///
enum GL_CLIPPING_OUTPUT_PRIMITIVES_ARB = 0x82F7; ///
enum GL_CLIP_DEPTH_MODE = 0x935D; ///
enum GL_CLIP_DISTANCE0 = 0x3000; ///
enum GL_CLIP_DISTANCE0_APPLE = 0x3000; ///
enum GL_CLIP_DISTANCE0_EXT = 0x3000; ///
enum GL_CLIP_DISTANCE1 = 0x3001; ///
enum GL_CLIP_DISTANCE1_APPLE = 0x3001; ///
enum GL_CLIP_DISTANCE1_EXT = 0x3001; ///
enum GL_CLIP_DISTANCE2 = 0x3002; ///
enum GL_CLIP_DISTANCE2_APPLE = 0x3002; ///
enum GL_CLIP_DISTANCE2_EXT = 0x3002; ///
enum GL_CLIP_DISTANCE3 = 0x3003; ///
enum GL_CLIP_DISTANCE3_APPLE = 0x3003; ///
enum GL_CLIP_DISTANCE3_EXT = 0x3003; ///
enum GL_CLIP_DISTANCE4 = 0x3004; ///
enum GL_CLIP_DISTANCE4_APPLE = 0x3004; ///
enum GL_CLIP_DISTANCE4_EXT = 0x3004; ///
enum GL_CLIP_DISTANCE5 = 0x3005; ///
enum GL_CLIP_DISTANCE5_APPLE = 0x3005; ///
enum GL_CLIP_DISTANCE5_EXT = 0x3005; ///
enum GL_CLIP_DISTANCE6 = 0x3006; ///
enum GL_CLIP_DISTANCE6_APPLE = 0x3006; ///
enum GL_CLIP_DISTANCE6_EXT = 0x3006; ///
enum GL_CLIP_DISTANCE7 = 0x3007; ///
enum GL_CLIP_DISTANCE7_APPLE = 0x3007; ///
enum GL_CLIP_DISTANCE7_EXT = 0x3007; ///
enum GL_CLIP_DISTANCE_NV = 0x8C7A; ///
enum GL_CLIP_FAR_HINT_PGI = 0x1A221; ///
enum GL_CLIP_NEAR_HINT_PGI = 0x1A220; ///
enum GL_CLIP_ORIGIN = 0x935C; ///
enum GL_CLIP_PLANE0 = 0x3000; ///
enum GL_CLIP_PLANE0_IMG = 0x3000; ///
enum GL_CLIP_PLANE1 = 0x3001; ///
enum GL_CLIP_PLANE1_IMG = 0x3001; ///
enum GL_CLIP_PLANE2 = 0x3002; ///
enum GL_CLIP_PLANE2_IMG = 0x3002; ///
enum GL_CLIP_PLANE3 = 0x3003; ///
enum GL_CLIP_PLANE3_IMG = 0x3003; ///
enum GL_CLIP_PLANE4 = 0x3004; ///
enum GL_CLIP_PLANE4_IMG = 0x3004; ///
enum GL_CLIP_PLANE5 = 0x3005; ///
enum GL_CLIP_PLANE5_IMG = 0x3005; ///
enum GL_CLIP_VOLUME_CLIPPING_HINT_EXT = 0x80F0; ///
enum GL_CLOSE_PATH_NV = 0x00; ///
enum GL_CMYKA_EXT = 0x800D; ///
enum GL_CMYK_EXT = 0x800C; ///
enum GL_CND0_ATI = 0x896B; ///
enum GL_CND_ATI = 0x896A; ///
enum GL_COEFF = 0x0A00; ///
enum GL_COLOR = 0x1800; ///
enum GL_COLOR3_BIT_PGI = 0x00010000; ///
enum GL_COLOR4_BIT_PGI = 0x00020000; ///
enum GL_COLORBURN = 0x929A; ///
enum GL_COLORBURN_KHR = 0x929A; ///
enum GL_COLORBURN_NV = 0x929A; ///
enum GL_COLORDODGE = 0x9299; ///
enum GL_COLORDODGE_KHR = 0x9299; ///
enum GL_COLORDODGE_NV = 0x9299; ///
enum GL_COLOR_ALPHA_PAIRING_ATI = 0x8975; ///
enum GL_COLOR_ARRAY = 0x8076; ///
enum GL_COLOR_ARRAY_ADDRESS_NV = 0x8F23; ///
enum GL_COLOR_ARRAY_BUFFER_BINDING = 0x8898; ///
enum GL_COLOR_ARRAY_BUFFER_BINDING_ARB = 0x8898; ///
enum GL_COLOR_ARRAY_COUNT_EXT = 0x8084; ///
enum GL_COLOR_ARRAY_EXT = 0x8076; ///
enum GL_COLOR_ARRAY_LENGTH_NV = 0x8F2D; ///
enum GL_COLOR_ARRAY_LIST_IBM = 0x103072; ///
enum GL_COLOR_ARRAY_LIST_STRIDE_IBM = 0x103082; ///
enum GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F7; ///
enum GL_COLOR_ARRAY_POINTER = 0x8090; ///
enum GL_COLOR_ARRAY_POINTER_EXT = 0x8090; ///
enum GL_COLOR_ARRAY_SIZE = 0x8081; ///
enum GL_COLOR_ARRAY_SIZE_EXT = 0x8081; ///
enum GL_COLOR_ARRAY_STRIDE = 0x8083; ///
enum GL_COLOR_ARRAY_STRIDE_EXT = 0x8083; ///
enum GL_COLOR_ARRAY_TYPE = 0x8082; ///
enum GL_COLOR_ARRAY_TYPE_EXT = 0x8082; ///
enum GL_COLOR_ATTACHMENT0 = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_EXT = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_NV = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_OES = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT1 = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT10 = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT10_EXT = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT10_NV = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT11 = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT11_EXT = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT11_NV = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT12 = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT12_EXT = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT12_NV = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT13 = 0x8CED; ///
enum GL_COLOR_ATTACHMENT13_EXT = 0x8CED; ///
enum GL_COLOR_ATTACHMENT13_NV = 0x8CED; ///
enum GL_COLOR_ATTACHMENT14 = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT14_EXT = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT14_NV = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT15 = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT15_EXT = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT15_NV = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT16 = 0x8CF0; ///
enum GL_COLOR_ATTACHMENT17 = 0x8CF1; ///
enum GL_COLOR_ATTACHMENT18 = 0x8CF2; ///
enum GL_COLOR_ATTACHMENT19 = 0x8CF3; ///
enum GL_COLOR_ATTACHMENT1_EXT = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT1_NV = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT2 = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT20 = 0x8CF4; ///
enum GL_COLOR_ATTACHMENT21 = 0x8CF5; ///
enum GL_COLOR_ATTACHMENT22 = 0x8CF6; ///
enum GL_COLOR_ATTACHMENT23 = 0x8CF7; ///
enum GL_COLOR_ATTACHMENT24 = 0x8CF8; ///
enum GL_COLOR_ATTACHMENT25 = 0x8CF9; ///
enum GL_COLOR_ATTACHMENT26 = 0x8CFA; ///
enum GL_COLOR_ATTACHMENT27 = 0x8CFB; ///
enum GL_COLOR_ATTACHMENT28 = 0x8CFC; ///
enum GL_COLOR_ATTACHMENT29 = 0x8CFD; ///
enum GL_COLOR_ATTACHMENT2_EXT = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT2_NV = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT3 = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT30 = 0x8CFE; ///
enum GL_COLOR_ATTACHMENT31 = 0x8CFF; ///
enum GL_COLOR_ATTACHMENT3_EXT = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT3_NV = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT4 = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT4_EXT = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT4_NV = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT5 = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT5_EXT = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT5_NV = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT6 = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT6_EXT = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT6_NV = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT7 = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT7_EXT = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT7_NV = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT8 = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT8_EXT = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT8_NV = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT9 = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT9_EXT = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT9_NV = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT_EXT = 0x90F0; ///
enum GL_COLOR_BUFFER_BIT = 0x00004000; ///
enum GL_COLOR_BUFFER_BIT0_QCOM = 0x00000001; ///
enum GL_COLOR_BUFFER_BIT1_QCOM = 0x00000002; ///
enum GL_COLOR_BUFFER_BIT2_QCOM = 0x00000004; ///
enum GL_COLOR_BUFFER_BIT3_QCOM = 0x00000008; ///
enum GL_COLOR_BUFFER_BIT4_QCOM = 0x00000010; ///
enum GL_COLOR_BUFFER_BIT5_QCOM = 0x00000020; ///
enum GL_COLOR_BUFFER_BIT6_QCOM = 0x00000040; ///
enum GL_COLOR_BUFFER_BIT7_QCOM = 0x00000080; ///
enum GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI = 0x8835; ///
enum GL_COLOR_CLEAR_VALUE = 0x0C22; ///
enum GL_COLOR_COMPONENTS = 0x8283; ///
enum GL_COLOR_ENCODING = 0x8296; ///
enum GL_COLOR_EXT = 0x1800; ///
enum GL_COLOR_FLOAT_APPLE = 0x8A0F; ///
enum GL_COLOR_INDEX = 0x1900; ///
enum GL_COLOR_INDEX12_EXT = 0x80E6; ///
enum GL_COLOR_INDEX16_EXT = 0x80E7; ///
enum GL_COLOR_INDEX1_EXT = 0x80E2; ///
enum GL_COLOR_INDEX2_EXT = 0x80E3; ///
enum GL_COLOR_INDEX4_EXT = 0x80E4; ///
enum GL_COLOR_INDEX8_EXT = 0x80E5; ///
enum GL_COLOR_INDEXES = 0x1603; ///
enum GL_COLOR_LOGIC_OP = 0x0BF2; ///
enum GL_COLOR_MATERIAL = 0x0B57; ///
enum GL_COLOR_MATERIAL_FACE = 0x0B55; ///
enum GL_COLOR_MATERIAL_PARAMETER = 0x0B56; ///
enum GL_COLOR_MATRIX = 0x80B1; ///
enum GL_COLOR_MATRIX_SGI = 0x80B1; ///
enum GL_COLOR_MATRIX_STACK_DEPTH = 0x80B2; ///
enum GL_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B2; ///
enum GL_COLOR_RENDERABLE = 0x8286; ///
enum GL_COLOR_SAMPLES_NV = 0x8E20; ///
enum GL_COLOR_SUM = 0x8458; ///
enum GL_COLOR_SUM_ARB = 0x8458; ///
enum GL_COLOR_SUM_CLAMP_NV = 0x854F; ///
enum GL_COLOR_SUM_EXT = 0x8458; ///
enum GL_COLOR_TABLE = 0x80D0; ///
enum GL_COLOR_TABLE_ALPHA_SIZE = 0x80DD; ///
enum GL_COLOR_TABLE_ALPHA_SIZE_SGI = 0x80DD; ///
enum GL_COLOR_TABLE_BIAS = 0x80D7; ///
enum GL_COLOR_TABLE_BIAS_SGI = 0x80D7; ///
enum GL_COLOR_TABLE_BLUE_SIZE = 0x80DC; ///
enum GL_COLOR_TABLE_BLUE_SIZE_SGI = 0x80DC; ///
enum GL_COLOR_TABLE_FORMAT = 0x80D8; ///
enum GL_COLOR_TABLE_FORMAT_SGI = 0x80D8; ///
enum GL_COLOR_TABLE_GREEN_SIZE = 0x80DB; ///
enum GL_COLOR_TABLE_GREEN_SIZE_SGI = 0x80DB; ///
enum GL_COLOR_TABLE_INTENSITY_SIZE = 0x80DF; ///
enum GL_COLOR_TABLE_INTENSITY_SIZE_SGI = 0x80DF; ///
enum GL_COLOR_TABLE_LUMINANCE_SIZE = 0x80DE; ///
enum GL_COLOR_TABLE_LUMINANCE_SIZE_SGI = 0x80DE; ///
enum GL_COLOR_TABLE_RED_SIZE = 0x80DA; ///
enum GL_COLOR_TABLE_RED_SIZE_SGI = 0x80DA; ///
enum GL_COLOR_TABLE_SCALE = 0x80D6; ///
enum GL_COLOR_TABLE_SCALE_SGI = 0x80D6; ///
enum GL_COLOR_TABLE_SGI = 0x80D0; ///
enum GL_COLOR_TABLE_WIDTH = 0x80D9; ///
enum GL_COLOR_TABLE_WIDTH_SGI = 0x80D9; ///
enum GL_COLOR_WRITEMASK = 0x0C23; ///
enum GL_COMBINE = 0x8570; ///
enum GL_COMBINE4_NV = 0x8503; ///
enum GL_COMBINER0_NV = 0x8550; ///
enum GL_COMBINER1_NV = 0x8551; ///
enum GL_COMBINER2_NV = 0x8552; ///
enum GL_COMBINER3_NV = 0x8553; ///
enum GL_COMBINER4_NV = 0x8554; ///
enum GL_COMBINER5_NV = 0x8555; ///
enum GL_COMBINER6_NV = 0x8556; ///
enum GL_COMBINER7_NV = 0x8557; ///
enum GL_COMBINER_AB_DOT_PRODUCT_NV = 0x8545; ///
enum GL_COMBINER_AB_OUTPUT_NV = 0x854A; ///
enum GL_COMBINER_BIAS_NV = 0x8549; ///
enum GL_COMBINER_CD_DOT_PRODUCT_NV = 0x8546; ///
enum GL_COMBINER_CD_OUTPUT_NV = 0x854B; ///
enum GL_COMBINER_COMPONENT_USAGE_NV = 0x8544; ///
enum GL_COMBINER_INPUT_NV = 0x8542; ///
enum GL_COMBINER_MAPPING_NV = 0x8543; ///
enum GL_COMBINER_MUX_SUM_NV = 0x8547; ///
enum GL_COMBINER_SCALE_NV = 0x8548; ///
enum GL_COMBINER_SUM_OUTPUT_NV = 0x854C; ///
enum GL_COMBINE_ALPHA = 0x8572; ///
enum GL_COMBINE_ALPHA_ARB = 0x8572; ///
enum GL_COMBINE_ALPHA_EXT = 0x8572; ///
enum GL_COMBINE_ARB = 0x8570; ///
enum GL_COMBINE_EXT = 0x8570; ///
enum GL_COMBINE_RGB = 0x8571; ///
enum GL_COMBINE_RGB_ARB = 0x8571; ///
enum GL_COMBINE_RGB_EXT = 0x8571; ///
enum GL_COMMAND_BARRIER_BIT = 0x00000040; ///
enum GL_COMMAND_BARRIER_BIT_EXT = 0x00000040; ///
enum GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT = 0x884E; ///
enum GL_COMPARE_REF_TO_TEXTURE = 0x884E; ///
enum GL_COMPARE_REF_TO_TEXTURE_EXT = 0x884E; ///
enum GL_COMPARE_R_TO_TEXTURE = 0x884E; ///
enum GL_COMPARE_R_TO_TEXTURE_ARB = 0x884E; ///
enum GL_COMPATIBLE_SUBROUTINES = 0x8E4B; ///
enum GL_COMPILE = 0x1300; ///
enum GL_COMPILE_AND_EXECUTE = 0x1301; ///
enum GL_COMPILE_STATUS = 0x8B81; ///
enum GL_COMPLETION_STATUS_ARB = 0x91B1; ///
enum GL_COMPRESSED_ALPHA = 0x84E9; ///
enum GL_COMPRESSED_ALPHA_ARB = 0x84E9; ///
enum GL_COMPRESSED_INTENSITY = 0x84EC; ///
enum GL_COMPRESSED_INTENSITY_ARB = 0x84EC; ///
enum GL_COMPRESSED_LUMINANCE = 0x84EA; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA = 0x84EB; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI = 0x8837; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_ARB = 0x84EB; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT = 0x8C72; ///
enum GL_COMPRESSED_LUMINANCE_ARB = 0x84EA; ///
enum GL_COMPRESSED_LUMINANCE_LATC1_EXT = 0x8C70; ///
enum GL_COMPRESSED_R11_EAC = 0x9270; ///
enum GL_COMPRESSED_R11_EAC_OES = 0x9270; ///
enum GL_COMPRESSED_RED = 0x8225; ///
enum GL_COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD; ///
enum GL_COMPRESSED_RED_RGTC1 = 0x8DBB; ///
enum GL_COMPRESSED_RED_RGTC1_EXT = 0x8DBB; ///
enum GL_COMPRESSED_RG = 0x8226; ///
enum GL_COMPRESSED_RG11_EAC = 0x9272; ///
enum GL_COMPRESSED_RG11_EAC_OES = 0x9272; ///
enum GL_COMPRESSED_RGB = 0x84ED; ///
enum GL_COMPRESSED_RGB8_ETC2 = 0x9274; ///
enum GL_COMPRESSED_RGB8_ETC2_OES = 0x9274; ///
enum GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276; ///
enum GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = 0x9276; ///
enum GL_COMPRESSED_RGBA = 0x84EE; ///
enum GL_COMPRESSED_RGBA8_ETC2_EAC = 0x9278; ///
enum GL_COMPRESSED_RGBA8_ETC2_EAC_OES = 0x9278; ///
enum GL_COMPRESSED_RGBA_ARB = 0x84EE; ///
enum GL_COMPRESSED_RGBA_ASTC_10x10 = 0x93BB; ///
enum GL_COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB; ///
enum GL_COMPRESSED_RGBA_ASTC_10x5 = 0x93B8; ///
enum GL_COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8; ///
enum GL_COMPRESSED_RGBA_ASTC_10x6 = 0x93B9; ///
enum GL_COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9; ///
enum GL_COMPRESSED_RGBA_ASTC_10x8 = 0x93BA; ///
enum GL_COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA; ///
enum GL_COMPRESSED_RGBA_ASTC_12x10 = 0x93BC; ///
enum GL_COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC; ///
enum GL_COMPRESSED_RGBA_ASTC_12x12 = 0x93BD; ///
enum GL_COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD; ///
enum GL_COMPRESSED_RGBA_ASTC_3x3x3_OES = 0x93C0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x3x3_OES = 0x93C1; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4 = 0x93B0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4x3_OES = 0x93C2; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4x4_OES = 0x93C3; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4 = 0x93B1; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4x4_OES = 0x93C4; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5 = 0x93B2; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5x4_OES = 0x93C5; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5x5_OES = 0x93C6; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5 = 0x93B3; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5x5_OES = 0x93C7; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6 = 0x93B4; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6x5_OES = 0x93C8; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6x6_OES = 0x93C9; ///
enum GL_COMPRESSED_RGBA_ASTC_8x5 = 0x93B5; ///
enum GL_COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5; ///
enum GL_COMPRESSED_RGBA_ASTC_8x6 = 0x93B6; ///
enum GL_COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6; ///
enum GL_COMPRESSED_RGBA_ASTC_8x8 = 0x93B7; ///
enum GL_COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7; ///
enum GL_COMPRESSED_RGBA_BPTC_UNORM = 0x8E8C; ///
enum GL_COMPRESSED_RGBA_BPTC_UNORM_ARB = 0x8E8C; ///
enum GL_COMPRESSED_RGBA_FXT1_3DFX = 0x86B1; ///
enum GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03; ///
enum GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG = 0x9137; ///
enum GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02; ///
enum GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG = 0x9138; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE = 0x83F2; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE = 0x83F3; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3; ///
enum GL_COMPRESSED_RGB_ARB = 0x84ED; ///
enum GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 0x8E8E; ///
enum GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = 0x8E8E; ///
enum GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 0x8E8F; ///
enum GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = 0x8E8F; ///
enum GL_COMPRESSED_RGB_FXT1_3DFX = 0x86B0; ///
enum GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01; ///
enum GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00; ///
enum GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0; ///
enum GL_COMPRESSED_RG_RGTC2 = 0x8DBD; ///
enum GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT = 0x8C73; ///
enum GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT = 0x8C71; ///
enum GL_COMPRESSED_SIGNED_R11_EAC = 0x9271; ///
enum GL_COMPRESSED_SIGNED_R11_EAC_OES = 0x9271; ///
enum GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE; ///
enum GL_COMPRESSED_SIGNED_RED_RGTC1 = 0x8DBC; ///
enum GL_COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC; ///
enum GL_COMPRESSED_SIGNED_RG11_EAC = 0x9273; ///
enum GL_COMPRESSED_SIGNED_RG11_EAC_OES = 0x9273; ///
enum GL_COMPRESSED_SIGNED_RG_RGTC2 = 0x8DBE; ///
enum GL_COMPRESSED_SLUMINANCE = 0x8C4A; ///
enum GL_COMPRESSED_SLUMINANCE_ALPHA = 0x8C4B; ///
enum GL_COMPRESSED_SLUMINANCE_ALPHA_EXT = 0x8C4B; ///
enum GL_COMPRESSED_SLUMINANCE_EXT = 0x8C4A; ///
enum GL_COMPRESSED_SRGB = 0x8C48; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10 = 0x93DB; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5 = 0x93D8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6 = 0x93D9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8 = 0x93DA; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10 = 0x93DC; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12 = 0x93DD; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES = 0x93E0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES = 0x93E1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4 = 0x93D0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES = 0x93E2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES = 0x93E3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4 = 0x93D1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES = 0x93E4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5 = 0x93D2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES = 0x93E5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES = 0x93E6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5 = 0x93D3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES = 0x93E7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6 = 0x93D4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES = 0x93E8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES = 0x93E9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5 = 0x93D5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6 = 0x93D6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8 = 0x93D7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC_OES = 0x9279; ///
enum GL_COMPRESSED_SRGB8_ETC2 = 0x9275; ///
enum GL_COMPRESSED_SRGB8_ETC2_OES = 0x9275; ///
enum GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277; ///
enum GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = 0x9277; ///
enum GL_COMPRESSED_SRGB_ALPHA = 0x8C49; ///
enum GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 0x8E8D; ///
enum GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = 0x8E8D; ///
enum GL_COMPRESSED_SRGB_ALPHA_EXT = 0x8C49; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT = 0x8A56; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG = 0x93F0; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT = 0x8A57; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG = 0x93F1; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 0x8C4D; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV = 0x8C4D; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 0x8C4E; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV = 0x8C4E; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 0x8C4F; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV = 0x8C4F; ///
enum GL_COMPRESSED_SRGB_EXT = 0x8C48; ///
enum GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT = 0x8A54; ///
enum GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT = 0x8A55; ///
enum GL_COMPRESSED_SRGB_S3TC_DXT1_EXT = 0x8C4C; ///
enum GL_COMPRESSED_SRGB_S3TC_DXT1_NV = 0x8C4C; ///
enum GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3; ///
enum GL_COMPRESSED_TEXTURE_FORMATS_ARB = 0x86A3; ///
enum GL_COMPUTE_PROGRAM_NV = 0x90FB; ///
enum GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV = 0x90FC; ///
enum GL_COMPUTE_SHADER = 0x91B9; ///
enum GL_COMPUTE_SHADER_BIT = 0x00000020; ///
enum GL_COMPUTE_SHADER_INVOCATIONS_ARB = 0x82F5; ///
enum GL_COMPUTE_SUBROUTINE = 0x92ED; ///
enum GL_COMPUTE_SUBROUTINE_UNIFORM = 0x92F3; ///
enum GL_COMPUTE_TEXTURE = 0x82A0; ///
enum GL_COMPUTE_WORK_GROUP_SIZE = 0x8267; ///
enum GL_COMP_BIT_ATI = 0x00000002; ///
enum GL_CONDITION_SATISFIED = 0x911C; ///
enum GL_CONDITION_SATISFIED_APPLE = 0x911C; ///
enum GL_CONFORMANT_NV = 0x9374; ///
enum GL_CONIC_CURVE_TO_NV = 0x1A; ///
enum GL_CONJOINT_NV = 0x9284; ///
enum GL_CONSERVATIVE_RASTERIZATION_INTEL = 0x83FE; ///
enum GL_CONSERVATIVE_RASTERIZATION_NV = 0x9346; ///
enum GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV = 0x937B; ///
enum GL_CONSERVATIVE_RASTER_DILATE_NV = 0x9379; ///
enum GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV = 0x937A; ///
enum GL_CONSERVATIVE_RASTER_MODE_NV = 0x954D; ///
enum GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV = 0x954E; ///
enum GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV = 0x954F; ///
enum GL_CONSERVE_MEMORY_HINT_PGI = 0x1A1FD; ///
enum GL_CONSTANT = 0x8576; ///
enum GL_CONSTANT_ALPHA = 0x8003; ///
enum GL_CONSTANT_ALPHA_EXT = 0x8003; ///
enum GL_CONSTANT_ARB = 0x8576; ///
enum GL_CONSTANT_ATTENUATION = 0x1207; ///
enum GL_CONSTANT_BORDER = 0x8151; ///
enum GL_CONSTANT_BORDER_HP = 0x8151; ///
enum GL_CONSTANT_COLOR = 0x8001; ///
enum GL_CONSTANT_COLOR0_NV = 0x852A; ///
enum GL_CONSTANT_COLOR1_NV = 0x852B; ///
enum GL_CONSTANT_COLOR_EXT = 0x8001; ///
enum GL_CONSTANT_EXT = 0x8576; ///
enum GL_CONSTANT_NV = 0x8576; ///
enum GL_CONST_EYE_NV = 0x86E5; ///
enum GL_CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002; ///
enum GL_CONTEXT_CORE_PROFILE_BIT = 0x00000001; ///
enum GL_CONTEXT_FLAGS = 0x821E; ///
enum GL_CONTEXT_FLAG_DEBUG_BIT = 0x00000002; ///
enum GL_CONTEXT_FLAG_DEBUG_BIT_KHR = 0x00000002; ///
enum GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001; ///
enum GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR = 0x00000008; ///
enum GL_CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = 0x00000010; ///
enum GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT = 0x00000004; ///
enum GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004; ///
enum GL_CONTEXT_LOST = 0x0507; ///
enum GL_CONTEXT_LOST_KHR = 0x0507; ///
enum GL_CONTEXT_LOST_WEBGL = 0x9242; ///
enum GL_CONTEXT_PROFILE_MASK = 0x9126; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR = 0x82FB; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x82FC; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR = 0x82FC; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_KHR = 0x82FB; ///
enum GL_CONTEXT_ROBUST_ACCESS = 0x90F3; ///
enum GL_CONTEXT_ROBUST_ACCESS_EXT = 0x90F3; ///
enum GL_CONTEXT_ROBUST_ACCESS_KHR = 0x90F3; ///
enum GL_CONTINUOUS_AMD = 0x9007; ///
enum GL_CONTRAST_NV = 0x92A1; ///
enum GL_CONVEX_HULL_NV = 0x908B; ///
enum GL_CONVOLUTION_1D = 0x8010; ///
enum GL_CONVOLUTION_1D_EXT = 0x8010; ///
enum GL_CONVOLUTION_2D = 0x8011; ///
enum GL_CONVOLUTION_2D_EXT = 0x8011; ///
enum GL_CONVOLUTION_BORDER_COLOR = 0x8154; ///
enum GL_CONVOLUTION_BORDER_COLOR_HP = 0x8154; ///
enum GL_CONVOLUTION_BORDER_MODE = 0x8013; ///
enum GL_CONVOLUTION_BORDER_MODE_EXT = 0x8013; ///
enum GL_CONVOLUTION_FILTER_BIAS = 0x8015; ///
enum GL_CONVOLUTION_FILTER_BIAS_EXT = 0x8015; ///
enum GL_CONVOLUTION_FILTER_SCALE = 0x8014; ///
enum GL_CONVOLUTION_FILTER_SCALE_EXT = 0x8014; ///
enum GL_CONVOLUTION_FORMAT = 0x8017; ///
enum GL_CONVOLUTION_FORMAT_EXT = 0x8017; ///
enum GL_CONVOLUTION_HEIGHT = 0x8019; ///
enum GL_CONVOLUTION_HEIGHT_EXT = 0x8019; ///
enum GL_CONVOLUTION_HINT_SGIX = 0x8316; ///
enum GL_CONVOLUTION_WIDTH = 0x8018; ///
enum GL_CONVOLUTION_WIDTH_EXT = 0x8018; ///
enum GL_CON_0_ATI = 0x8941; ///
enum GL_CON_10_ATI = 0x894B; ///
enum GL_CON_11_ATI = 0x894C; ///
enum GL_CON_12_ATI = 0x894D; ///
enum GL_CON_13_ATI = 0x894E; ///
enum GL_CON_14_ATI = 0x894F; ///
enum GL_CON_15_ATI = 0x8950; ///
enum GL_CON_16_ATI = 0x8951; ///
enum GL_CON_17_ATI = 0x8952; ///
enum GL_CON_18_ATI = 0x8953; ///
enum GL_CON_19_ATI = 0x8954; ///
enum GL_CON_1_ATI = 0x8942; ///
enum GL_CON_20_ATI = 0x8955; ///
enum GL_CON_21_ATI = 0x8956; ///
enum GL_CON_22_ATI = 0x8957; ///
enum GL_CON_23_ATI = 0x8958; ///
enum GL_CON_24_ATI = 0x8959; ///
enum GL_CON_25_ATI = 0x895A; ///
enum GL_CON_26_ATI = 0x895B; ///
enum GL_CON_27_ATI = 0x895C; ///
enum GL_CON_28_ATI = 0x895D; ///
enum GL_CON_29_ATI = 0x895E; ///
enum GL_CON_2_ATI = 0x8943; ///
enum GL_CON_30_ATI = 0x895F; ///
enum GL_CON_31_ATI = 0x8960; ///
enum GL_CON_3_ATI = 0x8944; ///
enum GL_CON_4_ATI = 0x8945; ///
enum GL_CON_5_ATI = 0x8946; ///
enum GL_CON_6_ATI = 0x8947; ///
enum GL_CON_7_ATI = 0x8948; ///
enum GL_CON_8_ATI = 0x8949; ///
enum GL_CON_9_ATI = 0x894A; ///
enum GL_COORD_REPLACE = 0x8862; ///
enum GL_COORD_REPLACE_ARB = 0x8862; ///
enum GL_COORD_REPLACE_NV = 0x8862; ///
enum GL_COORD_REPLACE_OES = 0x8862; ///
enum GL_COPY = 0x1503; ///
enum GL_COPY_INVERTED = 0x150C; ///
enum GL_COPY_PIXEL_TOKEN = 0x0706; ///
enum GL_COPY_READ_BUFFER = 0x8F36; ///
enum GL_COPY_READ_BUFFER_BINDING = 0x8F36; ///
enum GL_COPY_READ_BUFFER_NV = 0x8F36; ///
enum GL_COPY_WRITE_BUFFER = 0x8F37; ///
enum GL_COPY_WRITE_BUFFER_BINDING = 0x8F37; ///
enum GL_COPY_WRITE_BUFFER_NV = 0x8F37; ///
enum GL_COUNTER_RANGE_AMD = 0x8BC1; ///
enum GL_COUNTER_TYPE_AMD = 0x8BC0; ///
enum GL_COUNT_DOWN_NV = 0x9089; ///
enum GL_COUNT_UP_NV = 0x9088; ///
enum GL_COVERAGE_ALL_FRAGMENTS_NV = 0x8ED5; ///
enum GL_COVERAGE_ATTACHMENT_NV = 0x8ED2; ///
enum GL_COVERAGE_AUTOMATIC_NV = 0x8ED7; ///
enum GL_COVERAGE_BUFFERS_NV = 0x8ED3; ///
enum GL_COVERAGE_BUFFER_BIT_NV = 0x00008000; ///
enum GL_COVERAGE_COMPONENT4_NV = 0x8ED1; ///
enum GL_COVERAGE_COMPONENT_NV = 0x8ED0; ///
enum GL_COVERAGE_EDGE_FRAGMENTS_NV = 0x8ED6; ///
enum GL_COVERAGE_MODULATION_NV = 0x9332; ///
enum GL_COVERAGE_MODULATION_TABLE_NV = 0x9331; ///
enum GL_COVERAGE_MODULATION_TABLE_SIZE_NV = 0x9333; ///
enum GL_COVERAGE_SAMPLES_NV = 0x8ED4; ///
enum GL_CPU_OPTIMIZED_QCOM = 0x8FB1; ///
enum GL_CUBIC_CURVE_TO_NV = 0x0C; ///
enum GL_CUBIC_EXT = 0x8334; ///
enum GL_CUBIC_HP = 0x815F; ///
enum GL_CUBIC_IMG = 0x9139; ///
enum GL_CUBIC_MIPMAP_LINEAR_IMG = 0x913B; ///
enum GL_CUBIC_MIPMAP_NEAREST_IMG = 0x913A; ///
enum GL_CULL_FACE = 0x0B44; ///
enum GL_CULL_FACE_MODE = 0x0B45; ///
enum GL_CULL_FRAGMENT_NV = 0x86E7; ///
enum GL_CULL_MODES_NV = 0x86E0; ///
enum GL_CULL_VERTEX_EXT = 0x81AA; ///
enum GL_CULL_VERTEX_EYE_POSITION_EXT = 0x81AB; ///
enum GL_CULL_VERTEX_IBM = 0x103050; ///
enum GL_CULL_VERTEX_OBJECT_POSITION_EXT = 0x81AC; ///
enum GL_CURRENT_ATTRIB_NV = 0x8626; ///
enum GL_CURRENT_BINORMAL_EXT = 0x843C; ///
enum GL_CURRENT_BIT = 0x00000001; ///
enum GL_CURRENT_COLOR = 0x0B00; ///
enum GL_CURRENT_FOG_COORD = 0x8453; ///
enum GL_CURRENT_FOG_COORDINATE = 0x8453; ///
enum GL_CURRENT_FOG_COORDINATE_EXT = 0x8453; ///
enum GL_CURRENT_INDEX = 0x0B01; ///
enum GL_CURRENT_MATRIX_ARB = 0x8641; ///
enum GL_CURRENT_MATRIX_INDEX_ARB = 0x8845; ///
enum GL_CURRENT_MATRIX_NV = 0x8641; ///
enum GL_CURRENT_MATRIX_STACK_DEPTH_ARB = 0x8640; ///
enum GL_CURRENT_MATRIX_STACK_DEPTH_NV = 0x8640; ///
enum GL_CURRENT_NORMAL = 0x0B02; ///
enum GL_CURRENT_OCCLUSION_QUERY_ID_NV = 0x8865; ///
enum GL_CURRENT_PALETTE_MATRIX_ARB = 0x8843; ///
enum GL_CURRENT_PALETTE_MATRIX_OES = 0x8843; ///
enum GL_CURRENT_PROGRAM = 0x8B8D; ///
enum GL_CURRENT_QUERY = 0x8865; ///
enum GL_CURRENT_QUERY_ARB = 0x8865; ///
enum GL_CURRENT_QUERY_EXT = 0x8865; ///
enum GL_CURRENT_RASTER_COLOR = 0x0B04; ///
enum GL_CURRENT_RASTER_DISTANCE = 0x0B09; ///
enum GL_CURRENT_RASTER_INDEX = 0x0B05; ///
enum GL_CURRENT_RASTER_NORMAL_SGIX = 0x8406; ///
enum GL_CURRENT_RASTER_POSITION = 0x0B07; ///
enum GL_CURRENT_RASTER_POSITION_VALID = 0x0B08; ///
enum GL_CURRENT_RASTER_SECONDARY_COLOR = 0x845F; ///
enum GL_CURRENT_RASTER_TEXTURE_COORDS = 0x0B06; ///
enum GL_CURRENT_SECONDARY_COLOR = 0x8459; ///
enum GL_CURRENT_SECONDARY_COLOR_EXT = 0x8459; ///
enum GL_CURRENT_TANGENT_EXT = 0x843B; ///
enum GL_CURRENT_TEXTURE_COORDS = 0x0B03; ///
enum GL_CURRENT_TIME_NV = 0x8E28; ///
enum GL_CURRENT_VERTEX_ATTRIB = 0x8626; ///
enum GL_CURRENT_VERTEX_ATTRIB_ARB = 0x8626; ///
enum GL_CURRENT_VERTEX_EXT = 0x87E2; ///
enum GL_CURRENT_VERTEX_WEIGHT_EXT = 0x850B; ///
enum GL_CURRENT_WEIGHT_ARB = 0x86A8; ///
enum GL_CW = 0x0900; ///
enum GL_DARKEN = 0x9297; ///
enum GL_DARKEN_KHR = 0x9297; ///
enum GL_DARKEN_NV = 0x9297; ///
enum GL_DATA_BUFFER_AMD = 0x9151; ///
enum GL_DEBUG_ASSERT_MESA = 0x875B; ///
enum GL_DEBUG_CALLBACK_FUNCTION = 0x8244; ///
enum GL_DEBUG_CALLBACK_FUNCTION_ARB = 0x8244; ///
enum GL_DEBUG_CALLBACK_FUNCTION_KHR = 0x8244; ///
enum GL_DEBUG_CALLBACK_USER_PARAM = 0x8245; ///
enum GL_DEBUG_CALLBACK_USER_PARAM_ARB = 0x8245; ///
enum GL_DEBUG_CALLBACK_USER_PARAM_KHR = 0x8245; ///
enum GL_DEBUG_CATEGORY_API_ERROR_AMD = 0x9149; ///
enum GL_DEBUG_CATEGORY_APPLICATION_AMD = 0x914F; ///
enum GL_DEBUG_CATEGORY_DEPRECATION_AMD = 0x914B; ///
enum GL_DEBUG_CATEGORY_OTHER_AMD = 0x9150; ///
enum GL_DEBUG_CATEGORY_PERFORMANCE_AMD = 0x914D; ///
enum GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD = 0x914E; ///
enum GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD = 0x914C; ///
enum GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD = 0x914A; ///
enum GL_DEBUG_GROUP_STACK_DEPTH = 0x826D; ///
enum GL_DEBUG_GROUP_STACK_DEPTH_KHR = 0x826D; ///
enum GL_DEBUG_LOGGED_MESSAGES = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_AMD = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_ARB = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_KHR = 0x9145; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = 0x8243; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = 0x8243; ///
enum GL_DEBUG_OBJECT_MESA = 0x8759; ///
enum GL_DEBUG_OUTPUT = 0x92E0; ///
enum GL_DEBUG_OUTPUT_KHR = 0x92E0; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS = 0x8242; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB = 0x8242; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR = 0x8242; ///
enum GL_DEBUG_PRINT_MESA = 0x875A; ///
enum GL_DEBUG_SEVERITY_HIGH = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_AMD = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_ARB = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_KHR = 0x9146; ///
enum GL_DEBUG_SEVERITY_LOW = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_AMD = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_ARB = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_KHR = 0x9148; ///
enum GL_DEBUG_SEVERITY_MEDIUM = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_AMD = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_ARB = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_KHR = 0x9147; ///
enum GL_DEBUG_SEVERITY_NOTIFICATION = 0x826B; ///
enum GL_DEBUG_SEVERITY_NOTIFICATION_KHR = 0x826B; ///
enum GL_DEBUG_SOURCE_API = 0x8246; ///
enum GL_DEBUG_SOURCE_API_ARB = 0x8246; ///
enum GL_DEBUG_SOURCE_API_KHR = 0x8246; ///
enum GL_DEBUG_SOURCE_APPLICATION = 0x824A; ///
enum GL_DEBUG_SOURCE_APPLICATION_ARB = 0x824A; ///
enum GL_DEBUG_SOURCE_APPLICATION_KHR = 0x824A; ///
enum GL_DEBUG_SOURCE_OTHER = 0x824B; ///
enum GL_DEBUG_SOURCE_OTHER_ARB = 0x824B; ///
enum GL_DEBUG_SOURCE_OTHER_KHR = 0x824B; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER = 0x8248; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = 0x8248; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER_KHR = 0x8248; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY = 0x8249; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY_ARB = 0x8249; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY_KHR = 0x8249; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM = 0x8247; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = 0x8247; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR = 0x8247; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = 0x824D; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = 0x824D; ///
enum GL_DEBUG_TYPE_ERROR = 0x824C; ///
enum GL_DEBUG_TYPE_ERROR_ARB = 0x824C; ///
enum GL_DEBUG_TYPE_ERROR_KHR = 0x824C; ///
enum GL_DEBUG_TYPE_MARKER = 0x8268; ///
enum GL_DEBUG_TYPE_MARKER_KHR = 0x8268; ///
enum GL_DEBUG_TYPE_OTHER = 0x8251; ///
enum GL_DEBUG_TYPE_OTHER_ARB = 0x8251; ///
enum GL_DEBUG_TYPE_OTHER_KHR = 0x8251; ///
enum GL_DEBUG_TYPE_PERFORMANCE = 0x8250; ///
enum GL_DEBUG_TYPE_PERFORMANCE_ARB = 0x8250; ///
enum GL_DEBUG_TYPE_PERFORMANCE_KHR = 0x8250; ///
enum GL_DEBUG_TYPE_POP_GROUP = 0x826A; ///
enum GL_DEBUG_TYPE_POP_GROUP_KHR = 0x826A; ///
enum GL_DEBUG_TYPE_PORTABILITY = 0x824F; ///
enum GL_DEBUG_TYPE_PORTABILITY_ARB = 0x824F; ///
enum GL_DEBUG_TYPE_PORTABILITY_KHR = 0x824F; ///
enum GL_DEBUG_TYPE_PUSH_GROUP = 0x8269; ///
enum GL_DEBUG_TYPE_PUSH_GROUP_KHR = 0x8269; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = 0x824E; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = 0x824E; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = 0x824E; ///
enum GL_DECAL = 0x2101; ///
enum GL_DECODE_EXT = 0x8A49; ///
enum GL_DECR = 0x1E03; ///
enum GL_DECR_WRAP = 0x8508; ///
enum GL_DECR_WRAP_EXT = 0x8508; ///
enum GL_DECR_WRAP_OES = 0x8508; ///
enum GL_DEFORMATIONS_MASK_SGIX = 0x8196; ///
enum GL_DELETE_STATUS = 0x8B80; ///
enum GL_DEPENDENT_AR_TEXTURE_2D_NV = 0x86E9; ///
enum GL_DEPENDENT_GB_TEXTURE_2D_NV = 0x86EA; ///
enum GL_DEPENDENT_HILO_TEXTURE_2D_NV = 0x8858; ///
enum GL_DEPENDENT_RGB_TEXTURE_3D_NV = 0x8859; ///
enum GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV = 0x885A; ///
enum GL_DEPTH = 0x1801; ///
enum GL_DEPTH24_STENCIL8 = 0x88F0; ///
enum GL_DEPTH24_STENCIL8_EXT = 0x88F0; ///
enum GL_DEPTH24_STENCIL8_OES = 0x88F0; ///
enum GL_DEPTH32F_STENCIL8 = 0x8CAD; ///
enum GL_DEPTH32F_STENCIL8_NV = 0x8DAC; ///
enum GL_DEPTH_ATTACHMENT = 0x8D00; ///
enum GL_DEPTH_ATTACHMENT_EXT = 0x8D00; ///
enum GL_DEPTH_ATTACHMENT_OES = 0x8D00; ///
enum GL_DEPTH_BIAS = 0x0D1F; ///
enum GL_DEPTH_BITS = 0x0D56; ///
enum GL_DEPTH_BOUNDS_EXT = 0x8891; ///
enum GL_DEPTH_BOUNDS_TEST_EXT = 0x8890; ///
enum GL_DEPTH_BUFFER_BIT = 0x00000100; ///
enum GL_DEPTH_BUFFER_BIT0_QCOM = 0x00000100; ///
enum GL_DEPTH_BUFFER_BIT1_QCOM = 0x00000200; ///
enum GL_DEPTH_BUFFER_BIT2_QCOM = 0x00000400; ///
enum GL_DEPTH_BUFFER_BIT3_QCOM = 0x00000800; ///
enum GL_DEPTH_BUFFER_BIT4_QCOM = 0x00001000; ///
enum GL_DEPTH_BUFFER_BIT5_QCOM = 0x00002000; ///
enum GL_DEPTH_BUFFER_BIT6_QCOM = 0x00004000; ///
enum GL_DEPTH_BUFFER_BIT7_QCOM = 0x00008000; ///
enum GL_DEPTH_BUFFER_FLOAT_MODE_NV = 0x8DAF; ///
enum GL_DEPTH_CLAMP = 0x864F; ///
enum GL_DEPTH_CLAMP_FAR_AMD = 0x901F; ///
enum GL_DEPTH_CLAMP_NEAR_AMD = 0x901E; ///
enum GL_DEPTH_CLAMP_NV = 0x864F; ///
enum GL_DEPTH_CLEAR_VALUE = 0x0B73; ///
enum GL_DEPTH_COMPONENT = 0x1902; ///
enum GL_DEPTH_COMPONENT16 = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_ARB = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_NONLINEAR_NV = 0x8E2C; ///
enum GL_DEPTH_COMPONENT16_OES = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_SGIX = 0x81A5; ///
enum GL_DEPTH_COMPONENT24 = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_ARB = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_OES = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_SGIX = 0x81A6; ///
enum GL_DEPTH_COMPONENT32 = 0x81A7; ///
enum GL_DEPTH_COMPONENT32F = 0x8CAC; ///
enum GL_DEPTH_COMPONENT32F_NV = 0x8DAB; ///
enum GL_DEPTH_COMPONENT32_ARB = 0x81A7; ///
enum GL_DEPTH_COMPONENT32_OES = 0x81A7; ///
enum GL_DEPTH_COMPONENT32_SGIX = 0x81A7; ///
enum GL_DEPTH_COMPONENTS = 0x8284; ///
enum GL_DEPTH_EXT = 0x1801; ///
enum GL_DEPTH_FUNC = 0x0B74; ///
enum GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX = 0x8311; ///
enum GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX = 0x8312; ///
enum GL_DEPTH_PASS_INSTRUMENT_SGIX = 0x8310; ///
enum GL_DEPTH_RANGE = 0x0B70; ///
enum GL_DEPTH_RENDERABLE = 0x8287; ///
enum GL_DEPTH_SAMPLES_NV = 0x932D; ///
enum GL_DEPTH_SCALE = 0x0D1E; ///
enum GL_DEPTH_STENCIL = 0x84F9; ///
enum GL_DEPTH_STENCIL_ATTACHMENT = 0x821A; ///
enum GL_DEPTH_STENCIL_EXT = 0x84F9; ///
enum GL_DEPTH_STENCIL_MESA = 0x8750; ///
enum GL_DEPTH_STENCIL_NV = 0x84F9; ///
enum GL_DEPTH_STENCIL_OES = 0x84F9; ///
enum GL_DEPTH_STENCIL_TEXTURE_MODE = 0x90EA; ///
enum GL_DEPTH_STENCIL_TO_BGRA_NV = 0x886F; ///
enum GL_DEPTH_STENCIL_TO_RGBA_NV = 0x886E; ///
enum GL_DEPTH_TEST = 0x0B71; ///
enum GL_DEPTH_TEXTURE_MODE = 0x884B; ///
enum GL_DEPTH_TEXTURE_MODE_ARB = 0x884B; ///
enum GL_DEPTH_WRITEMASK = 0x0B72; ///
enum GL_DETAIL_TEXTURE_2D_BINDING_SGIS = 0x8096; ///
enum GL_DETAIL_TEXTURE_2D_SGIS = 0x8095; ///
enum GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS = 0x809C; ///
enum GL_DETAIL_TEXTURE_LEVEL_SGIS = 0x809A; ///
enum GL_DETAIL_TEXTURE_MODE_SGIS = 0x809B; ///
enum GL_DIFFERENCE = 0x929E; ///
enum GL_DIFFERENCE_KHR = 0x929E; ///
enum GL_DIFFERENCE_NV = 0x929E; ///
enum GL_DIFFUSE = 0x1201; ///
enum GL_DISCARD_ATI = 0x8763; ///
enum GL_DISCARD_NV = 0x8530; ///
enum GL_DISCRETE_AMD = 0x9006; ///
enum GL_DISJOINT_NV = 0x9283; ///
enum GL_DISPATCH_INDIRECT_BUFFER = 0x90EE; ///
enum GL_DISPATCH_INDIRECT_BUFFER_BINDING = 0x90EF; ///
enum GL_DISPLAY_LIST = 0x82E7; ///
enum GL_DISTANCE_ATTENUATION_EXT = 0x8129; ///
enum GL_DISTANCE_ATTENUATION_SGIS = 0x8129; ///
enum GL_DITHER = 0x0BD0; ///
enum GL_DMP_PROGRAM_BINARY_DMP = 0x9253; ///
enum GL_DOMAIN = 0x0A02; ///
enum GL_DONT_CARE = 0x1100; ///
enum GL_DOT2_ADD_ATI = 0x896C; ///
enum GL_DOT3_ATI = 0x8966; ///
enum GL_DOT3_RGB = 0x86AE; ///
enum GL_DOT3_RGBA = 0x86AF; ///
enum GL_DOT3_RGBA_ARB = 0x86AF; ///
enum GL_DOT3_RGBA_EXT = 0x8741; ///
enum GL_DOT3_RGBA_IMG = 0x86AF; ///
enum GL_DOT3_RGB_ARB = 0x86AE; ///
enum GL_DOT3_RGB_EXT = 0x8740; ///
enum GL_DOT4_ATI = 0x8967; ///
enum GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV = 0x885D; ///
enum GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV = 0x86F3; ///
enum GL_DOT_PRODUCT_DEPTH_REPLACE_NV = 0x86ED; ///
enum GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV = 0x86F1; ///
enum GL_DOT_PRODUCT_NV = 0x86EC; ///
enum GL_DOT_PRODUCT_PASS_THROUGH_NV = 0x885B; ///
enum GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV = 0x86F2; ///
enum GL_DOT_PRODUCT_TEXTURE_1D_NV = 0x885C; ///
enum GL_DOT_PRODUCT_TEXTURE_2D_NV = 0x86EE; ///
enum GL_DOT_PRODUCT_TEXTURE_3D_NV = 0x86EF; ///
enum GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV = 0x86F0; ///
enum GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV = 0x864E; ///
enum GL_DOUBLE = 0x140A; ///
enum GL_DOUBLEBUFFER = 0x0C32; ///
enum GL_DOUBLE_EXT = 0x140A; ///
enum GL_DOUBLE_MAT2 = 0x8F46; ///
enum GL_DOUBLE_MAT2_EXT = 0x8F46; ///
enum GL_DOUBLE_MAT2x3 = 0x8F49; ///
enum GL_DOUBLE_MAT2x3_EXT = 0x8F49; ///
enum GL_DOUBLE_MAT2x4 = 0x8F4A; ///
enum GL_DOUBLE_MAT2x4_EXT = 0x8F4A; ///
enum GL_DOUBLE_MAT3 = 0x8F47; ///
enum GL_DOUBLE_MAT3_EXT = 0x8F47; ///
enum GL_DOUBLE_MAT3x2 = 0x8F4B; ///
enum GL_DOUBLE_MAT3x2_EXT = 0x8F4B; ///
enum GL_DOUBLE_MAT3x4 = 0x8F4C; ///
enum GL_DOUBLE_MAT3x4_EXT = 0x8F4C; ///
enum GL_DOUBLE_MAT4 = 0x8F48; ///
enum GL_DOUBLE_MAT4_EXT = 0x8F48; ///
enum GL_DOUBLE_MAT4x2 = 0x8F4D; ///
enum GL_DOUBLE_MAT4x2_EXT = 0x8F4D; ///
enum GL_DOUBLE_MAT4x3 = 0x8F4E; ///
enum GL_DOUBLE_MAT4x3_EXT = 0x8F4E; ///
enum GL_DOUBLE_VEC2 = 0x8FFC; ///
enum GL_DOUBLE_VEC2_EXT = 0x8FFC; ///
enum GL_DOUBLE_VEC3 = 0x8FFD; ///
enum GL_DOUBLE_VEC3_EXT = 0x8FFD; ///
enum GL_DOUBLE_VEC4 = 0x8FFE; ///
enum GL_DOUBLE_VEC4_EXT = 0x8FFE; ///
enum GL_DOWNSAMPLE_SCALES_IMG = 0x913E; ///
enum GL_DRAW_ARRAYS_COMMAND_NV = 0x0003; ///
enum GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV = 0x0007; ///
enum GL_DRAW_ARRAYS_STRIP_COMMAND_NV = 0x0005; ///
enum GL_DRAW_BUFFER = 0x0C01; ///
enum GL_DRAW_BUFFER0 = 0x8825; ///
enum GL_DRAW_BUFFER0_ARB = 0x8825; ///
enum GL_DRAW_BUFFER0_ATI = 0x8825; ///
enum GL_DRAW_BUFFER0_EXT = 0x8825; ///
enum GL_DRAW_BUFFER0_NV = 0x8825; ///
enum GL_DRAW_BUFFER1 = 0x8826; ///
enum GL_DRAW_BUFFER10 = 0x882F; ///
enum GL_DRAW_BUFFER10_ARB = 0x882F; ///
enum GL_DRAW_BUFFER10_ATI = 0x882F; ///
enum GL_DRAW_BUFFER10_EXT = 0x882F; ///
enum GL_DRAW_BUFFER10_NV = 0x882F; ///
enum GL_DRAW_BUFFER11 = 0x8830; ///
enum GL_DRAW_BUFFER11_ARB = 0x8830; ///
enum GL_DRAW_BUFFER11_ATI = 0x8830; ///
enum GL_DRAW_BUFFER11_EXT = 0x8830; ///
enum GL_DRAW_BUFFER11_NV = 0x8830; ///
enum GL_DRAW_BUFFER12 = 0x8831; ///
enum GL_DRAW_BUFFER12_ARB = 0x8831; ///
enum GL_DRAW_BUFFER12_ATI = 0x8831; ///
enum GL_DRAW_BUFFER12_EXT = 0x8831; ///
enum GL_DRAW_BUFFER12_NV = 0x8831; ///
enum GL_DRAW_BUFFER13 = 0x8832; ///
enum GL_DRAW_BUFFER13_ARB = 0x8832; ///
enum GL_DRAW_BUFFER13_ATI = 0x8832; ///
enum GL_DRAW_BUFFER13_EXT = 0x8832; ///
enum GL_DRAW_BUFFER13_NV = 0x8832; ///
enum GL_DRAW_BUFFER14 = 0x8833; ///
enum GL_DRAW_BUFFER14_ARB = 0x8833; ///
enum GL_DRAW_BUFFER14_ATI = 0x8833; ///
enum GL_DRAW_BUFFER14_EXT = 0x8833; ///
enum GL_DRAW_BUFFER14_NV = 0x8833; ///
enum GL_DRAW_BUFFER15 = 0x8834; ///
enum GL_DRAW_BUFFER15_ARB = 0x8834; ///
enum GL_DRAW_BUFFER15_ATI = 0x8834; ///
enum GL_DRAW_BUFFER15_EXT = 0x8834; ///
enum GL_DRAW_BUFFER15_NV = 0x8834; ///
enum GL_DRAW_BUFFER1_ARB = 0x8826; ///
enum GL_DRAW_BUFFER1_ATI = 0x8826; ///
enum GL_DRAW_BUFFER1_EXT = 0x8826; ///
enum GL_DRAW_BUFFER1_NV = 0x8826; ///
enum GL_DRAW_BUFFER2 = 0x8827; ///
enum GL_DRAW_BUFFER2_ARB = 0x8827; ///
enum GL_DRAW_BUFFER2_ATI = 0x8827; ///
enum GL_DRAW_BUFFER2_EXT = 0x8827; ///
enum GL_DRAW_BUFFER2_NV = 0x8827; ///
enum GL_DRAW_BUFFER3 = 0x8828; ///
enum GL_DRAW_BUFFER3_ARB = 0x8828; ///
enum GL_DRAW_BUFFER3_ATI = 0x8828; ///
enum GL_DRAW_BUFFER3_EXT = 0x8828; ///
enum GL_DRAW_BUFFER3_NV = 0x8828; ///
enum GL_DRAW_BUFFER4 = 0x8829; ///
enum GL_DRAW_BUFFER4_ARB = 0x8829; ///
enum GL_DRAW_BUFFER4_ATI = 0x8829; ///
enum GL_DRAW_BUFFER4_EXT = 0x8829; ///
enum GL_DRAW_BUFFER4_NV = 0x8829; ///
enum GL_DRAW_BUFFER5 = 0x882A; ///
enum GL_DRAW_BUFFER5_ARB = 0x882A; ///
enum GL_DRAW_BUFFER5_ATI = 0x882A; ///
enum GL_DRAW_BUFFER5_EXT = 0x882A; ///
enum GL_DRAW_BUFFER5_NV = 0x882A; ///
enum GL_DRAW_BUFFER6 = 0x882B; ///
enum GL_DRAW_BUFFER6_ARB = 0x882B; ///
enum GL_DRAW_BUFFER6_ATI = 0x882B; ///
enum GL_DRAW_BUFFER6_EXT = 0x882B; ///
enum GL_DRAW_BUFFER6_NV = 0x882B; ///
enum GL_DRAW_BUFFER7 = 0x882C; ///
enum GL_DRAW_BUFFER7_ARB = 0x882C; ///
enum GL_DRAW_BUFFER7_ATI = 0x882C; ///
enum GL_DRAW_BUFFER7_EXT = 0x882C; ///
enum GL_DRAW_BUFFER7_NV = 0x882C; ///
enum GL_DRAW_BUFFER8 = 0x882D; ///
enum GL_DRAW_BUFFER8_ARB = 0x882D; ///
enum GL_DRAW_BUFFER8_ATI = 0x882D; ///
enum GL_DRAW_BUFFER8_EXT = 0x882D; ///
enum GL_DRAW_BUFFER8_NV = 0x882D; ///
enum GL_DRAW_BUFFER9 = 0x882E; ///
enum GL_DRAW_BUFFER9_ARB = 0x882E; ///
enum GL_DRAW_BUFFER9_ATI = 0x882E; ///
enum GL_DRAW_BUFFER9_EXT = 0x882E; ///
enum GL_DRAW_BUFFER9_NV = 0x882E; ///
enum GL_DRAW_BUFFER_EXT = 0x0C01; ///
enum GL_DRAW_ELEMENTS_COMMAND_NV = 0x0002; ///
enum GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV = 0x0006; ///
enum GL_DRAW_ELEMENTS_STRIP_COMMAND_NV = 0x0004; ///
enum GL_DRAW_FRAMEBUFFER = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_ANGLE = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_APPLE = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_BINDING = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_ANGLE = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_APPLE = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_EXT = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_NV = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_EXT = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_NV = 0x8CA9; ///
enum GL_DRAW_INDIRECT_ADDRESS_NV = 0x8F41; ///
enum GL_DRAW_INDIRECT_BUFFER = 0x8F3F; ///
enum GL_DRAW_INDIRECT_BUFFER_BINDING = 0x8F43; ///
enum GL_DRAW_INDIRECT_LENGTH_NV = 0x8F42; ///
enum GL_DRAW_INDIRECT_UNIFIED_NV = 0x8F40; ///
enum GL_DRAW_PIXELS_APPLE = 0x8A0A; ///
enum GL_DRAW_PIXEL_TOKEN = 0x0705; ///
enum GL_DSDT8_MAG8_INTENSITY8_NV = 0x870B; ///
enum GL_DSDT8_MAG8_NV = 0x870A; ///
enum GL_DSDT8_NV = 0x8709; ///
enum GL_DSDT_MAG_INTENSITY_NV = 0x86DC; ///
enum GL_DSDT_MAG_NV = 0x86F6; ///
enum GL_DSDT_MAG_VIB_NV = 0x86F7; ///
enum GL_DSDT_NV = 0x86F5; ///
enum GL_DST_ALPHA = 0x0304; ///
enum GL_DST_ATOP_NV = 0x928F; ///
enum GL_DST_COLOR = 0x0306; ///
enum GL_DST_IN_NV = 0x928B; ///
enum GL_DST_NV = 0x9287; ///
enum GL_DST_OUT_NV = 0x928D; ///
enum GL_DST_OVER_NV = 0x9289; ///
enum GL_DS_BIAS_NV = 0x8716; ///
enum GL_DS_SCALE_NV = 0x8710; ///
enum GL_DT_BIAS_NV = 0x8717; ///
enum GL_DT_SCALE_NV = 0x8711; ///
enum GL_DU8DV8_ATI = 0x877A; ///
enum GL_DUAL_ALPHA12_SGIS = 0x8112; ///
enum GL_DUAL_ALPHA16_SGIS = 0x8113; ///
enum GL_DUAL_ALPHA4_SGIS = 0x8110; ///
enum GL_DUAL_ALPHA8_SGIS = 0x8111; ///
enum GL_DUAL_INTENSITY12_SGIS = 0x811A; ///
enum GL_DUAL_INTENSITY16_SGIS = 0x811B; ///
enum GL_DUAL_INTENSITY4_SGIS = 0x8118; ///
enum GL_DUAL_INTENSITY8_SGIS = 0x8119; ///
enum GL_DUAL_LUMINANCE12_SGIS = 0x8116; ///
enum GL_DUAL_LUMINANCE16_SGIS = 0x8117; ///
enum GL_DUAL_LUMINANCE4_SGIS = 0x8114; ///
enum GL_DUAL_LUMINANCE8_SGIS = 0x8115; ///
enum GL_DUAL_LUMINANCE_ALPHA4_SGIS = 0x811C; ///
enum GL_DUAL_LUMINANCE_ALPHA8_SGIS = 0x811D; ///
enum GL_DUAL_TEXTURE_SELECT_SGIS = 0x8124; ///
enum GL_DUDV_ATI = 0x8779; ///
enum GL_DUP_FIRST_CUBIC_CURVE_TO_NV = 0xF2; ///
enum GL_DUP_LAST_CUBIC_CURVE_TO_NV = 0xF4; ///
enum GL_DYNAMIC_ATI = 0x8761; ///
enum GL_DYNAMIC_COPY = 0x88EA; ///
enum GL_DYNAMIC_COPY_ARB = 0x88EA; ///
enum GL_DYNAMIC_DRAW = 0x88E8; ///
enum GL_DYNAMIC_DRAW_ARB = 0x88E8; ///
enum GL_DYNAMIC_READ = 0x88E9; ///
enum GL_DYNAMIC_READ_ARB = 0x88E9; ///
enum GL_DYNAMIC_STORAGE_BIT = 0x0100; ///
enum GL_DYNAMIC_STORAGE_BIT_EXT = 0x0100; ///
enum GL_EDGEFLAG_BIT_PGI = 0x00040000; ///
enum GL_EDGE_FLAG = 0x0B43; ///
enum GL_EDGE_FLAG_ARRAY = 0x8079; ///
enum GL_EDGE_FLAG_ARRAY_ADDRESS_NV = 0x8F26; ///
enum GL_EDGE_FLAG_ARRAY_BUFFER_BINDING = 0x889B; ///
enum GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB = 0x889B; ///
enum GL_EDGE_FLAG_ARRAY_COUNT_EXT = 0x808D; ///
enum GL_EDGE_FLAG_ARRAY_EXT = 0x8079; ///
enum GL_EDGE_FLAG_ARRAY_LENGTH_NV = 0x8F30; ///
enum GL_EDGE_FLAG_ARRAY_LIST_IBM = 0x103075; ///
enum GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM = 0x103085; ///
enum GL_EDGE_FLAG_ARRAY_POINTER = 0x8093; ///
enum GL_EDGE_FLAG_ARRAY_POINTER_EXT = 0x8093; ///
enum GL_EDGE_FLAG_ARRAY_STRIDE = 0x808C; ///
enum GL_EDGE_FLAG_ARRAY_STRIDE_EXT = 0x808C; ///
enum GL_EFFECTIVE_RASTER_SAMPLES_EXT = 0x932C; ///
enum GL_EIGHTH_BIT_ATI = 0x00000020; ///
enum GL_ELEMENT_ADDRESS_COMMAND_NV = 0x0008; ///
enum GL_ELEMENT_ARRAY_ADDRESS_NV = 0x8F29; ///
enum GL_ELEMENT_ARRAY_APPLE = 0x8A0C; ///
enum GL_ELEMENT_ARRAY_ATI = 0x8768; ///
enum GL_ELEMENT_ARRAY_BARRIER_BIT = 0x00000002; ///
enum GL_ELEMENT_ARRAY_BARRIER_BIT_EXT = 0x00000002; ///
enum GL_ELEMENT_ARRAY_BUFFER = 0x8893; ///
enum GL_ELEMENT_ARRAY_BUFFER_ARB = 0x8893; ///
enum GL_ELEMENT_ARRAY_BUFFER_BINDING = 0x8895; ///
enum GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB = 0x8895; ///
enum GL_ELEMENT_ARRAY_LENGTH_NV = 0x8F33; ///
enum GL_ELEMENT_ARRAY_POINTER_APPLE = 0x8A0E; ///
enum GL_ELEMENT_ARRAY_POINTER_ATI = 0x876A; ///
enum GL_ELEMENT_ARRAY_TYPE_APPLE = 0x8A0D; ///
enum GL_ELEMENT_ARRAY_TYPE_ATI = 0x8769; ///
enum GL_ELEMENT_ARRAY_UNIFIED_NV = 0x8F1F; ///
enum GL_EMBOSS_CONSTANT_NV = 0x855E; ///
enum GL_EMBOSS_LIGHT_NV = 0x855D; ///
enum GL_EMBOSS_MAP_NV = 0x855F; ///
enum GL_EMISSION = 0x1600; ///
enum GL_ENABLE_BIT = 0x00002000; ///
enum GL_EQUAL = 0x0202; ///
enum GL_EQUIV = 0x1509; ///
enum GL_ETC1_RGB8_OES = 0x8D64; ///
enum GL_ETC1_SRGB8_NV = 0x88EE; ///
enum GL_EVAL_2D_NV = 0x86C0; ///
enum GL_EVAL_BIT = 0x00010000; ///
enum GL_EVAL_FRACTIONAL_TESSELLATION_NV = 0x86C5; ///
enum GL_EVAL_TRIANGULAR_2D_NV = 0x86C1; ///
enum GL_EVAL_VERTEX_ATTRIB0_NV = 0x86C6; ///
enum GL_EVAL_VERTEX_ATTRIB10_NV = 0x86D0; ///
enum GL_EVAL_VERTEX_ATTRIB11_NV = 0x86D1; ///
enum GL_EVAL_VERTEX_ATTRIB12_NV = 0x86D2; ///
enum GL_EVAL_VERTEX_ATTRIB13_NV = 0x86D3; ///
enum GL_EVAL_VERTEX_ATTRIB14_NV = 0x86D4; ///
enum GL_EVAL_VERTEX_ATTRIB15_NV = 0x86D5; ///
enum GL_EVAL_VERTEX_ATTRIB1_NV = 0x86C7; ///
enum GL_EVAL_VERTEX_ATTRIB2_NV = 0x86C8; ///
enum GL_EVAL_VERTEX_ATTRIB3_NV = 0x86C9; ///
enum GL_EVAL_VERTEX_ATTRIB4_NV = 0x86CA; ///
enum GL_EVAL_VERTEX_ATTRIB5_NV = 0x86CB; ///
enum GL_EVAL_VERTEX_ATTRIB6_NV = 0x86CC; ///
enum GL_EVAL_VERTEX_ATTRIB7_NV = 0x86CD; ///
enum GL_EVAL_VERTEX_ATTRIB8_NV = 0x86CE; ///
enum GL_EVAL_VERTEX_ATTRIB9_NV = 0x86CF; ///
enum GL_EXCLUSION = 0x92A0; ///
enum GL_EXCLUSION_KHR = 0x92A0; ///
enum GL_EXCLUSION_NV = 0x92A0; ///
enum GL_EXCLUSIVE_EXT = 0x8F11; ///
enum GL_EXP = 0x0800; ///
enum GL_EXP2 = 0x0801; ///
enum GL_EXPAND_NEGATE_NV = 0x8539; ///
enum GL_EXPAND_NORMAL_NV = 0x8538; ///
enum GL_EXTENSIONS = 0x1F03; ///
enum GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD = 0x9160; ///
enum GL_EYE_DISTANCE_TO_LINE_SGIS = 0x81F2; ///
enum GL_EYE_DISTANCE_TO_POINT_SGIS = 0x81F0; ///
enum GL_EYE_LINEAR = 0x2400; ///
enum GL_EYE_LINEAR_NV = 0x2400; ///
enum GL_EYE_LINE_SGIS = 0x81F6; ///
enum GL_EYE_PLANE = 0x2502; ///
enum GL_EYE_PLANE_ABSOLUTE_NV = 0x855C; ///
enum GL_EYE_POINT_SGIS = 0x81F4; ///
enum GL_EYE_RADIAL_NV = 0x855B; ///
enum GL_E_TIMES_F_NV = 0x8531; ///
enum GL_FACTOR_ALPHA_MODULATE_IMG = 0x8C07; ///
enum GL_FACTOR_MAX_AMD = 0x901D; ///
enum GL_FACTOR_MIN_AMD = 0x901C; ///
enum GL_FAILURE_NV = 0x9030; ///
enum GL_FALSE = 0; ///
enum GL_FASTEST = 0x1101; ///
enum GL_FEEDBACK = 0x1C01; ///
enum GL_FEEDBACK_BUFFER_POINTER = 0x0DF0; ///
enum GL_FEEDBACK_BUFFER_SIZE = 0x0DF1; ///
enum GL_FEEDBACK_BUFFER_TYPE = 0x0DF2; ///
enum GL_FENCE_APPLE = 0x8A0B; ///
enum GL_FENCE_CONDITION_NV = 0x84F4; ///
enum GL_FENCE_STATUS_NV = 0x84F3; ///
enum GL_FETCH_PER_SAMPLE_ARM = 0x8F65; ///
enum GL_FIELDS_NV = 0x8E27; ///
enum GL_FIELD_LOWER_NV = 0x9023; ///
enum GL_FIELD_UPPER_NV = 0x9022; ///
enum GL_FILE_NAME_NV = 0x9074; ///
enum GL_FILL = 0x1B02; ///
enum GL_FILL_NV = 0x1B02; ///
enum GL_FILL_RECTANGLE_NV = 0x933C; ///
enum GL_FILTER = 0x829A; ///
enum GL_FILTER4_SGIS = 0x8146; ///
enum GL_FIRST_TO_REST_NV = 0x90AF; ///
enum GL_FIRST_VERTEX_CONVENTION = 0x8E4D; ///
enum GL_FIRST_VERTEX_CONVENTION_EXT = 0x8E4D; ///
enum GL_FIRST_VERTEX_CONVENTION_OES = 0x8E4D; ///
enum GL_FIXED = 0x140C; ///
enum GL_FIXED_OES = 0x140C; ///
enum GL_FIXED_ONLY = 0x891D; ///
enum GL_FIXED_ONLY_ARB = 0x891D; ///
enum GL_FLAT = 0x1D00; ///
enum GL_FLOAT = 0x1406; ///
enum GL_FLOAT16_MAT2_AMD = 0x91C5; ///
enum GL_FLOAT16_MAT2x3_AMD = 0x91C8; ///
enum GL_FLOAT16_MAT2x4_AMD = 0x91C9; ///
enum GL_FLOAT16_MAT3_AMD = 0x91C6; ///
enum GL_FLOAT16_MAT3x2_AMD = 0x91CA; ///
enum GL_FLOAT16_MAT3x4_AMD = 0x91CB; ///
enum GL_FLOAT16_MAT4_AMD = 0x91C7; ///
enum GL_FLOAT16_MAT4x2_AMD = 0x91CC; ///
enum GL_FLOAT16_MAT4x3_AMD = 0x91CD; ///
enum GL_FLOAT16_NV = 0x8FF8; ///
enum GL_FLOAT16_VEC2_NV = 0x8FF9; ///
enum GL_FLOAT16_VEC3_NV = 0x8FFA; ///
enum GL_FLOAT16_VEC4_NV = 0x8FFB; ///
enum GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD; ///
enum GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV = 0x8DAD; ///
enum GL_FLOAT_CLEAR_COLOR_VALUE_NV = 0x888D; ///
enum GL_FLOAT_MAT2 = 0x8B5A; ///
enum GL_FLOAT_MAT2_ARB = 0x8B5A; ///
enum GL_FLOAT_MAT2x3 = 0x8B65; ///
enum GL_FLOAT_MAT2x3_NV = 0x8B65; ///
enum GL_FLOAT_MAT2x4 = 0x8B66; ///
enum GL_FLOAT_MAT2x4_NV = 0x8B66; ///
enum GL_FLOAT_MAT3 = 0x8B5B; ///
enum GL_FLOAT_MAT3_ARB = 0x8B5B; ///
enum GL_FLOAT_MAT3x2 = 0x8B67; ///
enum GL_FLOAT_MAT3x2_NV = 0x8B67; ///
enum GL_FLOAT_MAT3x4 = 0x8B68; ///
enum GL_FLOAT_MAT3x4_NV = 0x8B68; ///
enum GL_FLOAT_MAT4 = 0x8B5C; ///
enum GL_FLOAT_MAT4_ARB = 0x8B5C; ///
enum GL_FLOAT_MAT4x2 = 0x8B69; ///
enum GL_FLOAT_MAT4x2_NV = 0x8B69; ///
enum GL_FLOAT_MAT4x3 = 0x8B6A; ///
enum GL_FLOAT_MAT4x3_NV = 0x8B6A; ///
enum GL_FLOAT_R16_NV = 0x8884; ///
enum GL_FLOAT_R32_NV = 0x8885; ///
enum GL_FLOAT_RG16_NV = 0x8886; ///
enum GL_FLOAT_RG32_NV = 0x8887; ///
enum GL_FLOAT_RGB16_NV = 0x8888; ///
enum GL_FLOAT_RGB32_NV = 0x8889; ///
enum GL_FLOAT_RGBA16_NV = 0x888A; ///
enum GL_FLOAT_RGBA32_NV = 0x888B; ///
enum GL_FLOAT_RGBA_MODE_NV = 0x888E; ///
enum GL_FLOAT_RGBA_NV = 0x8883; ///
enum GL_FLOAT_RGB_NV = 0x8882; ///
enum GL_FLOAT_RG_NV = 0x8881; ///
enum GL_FLOAT_R_NV = 0x8880; ///
enum GL_FLOAT_VEC2 = 0x8B50; ///
enum GL_FLOAT_VEC2_ARB = 0x8B50; ///
enum GL_FLOAT_VEC3 = 0x8B51; ///
enum GL_FLOAT_VEC3_ARB = 0x8B51; ///
enum GL_FLOAT_VEC4 = 0x8B52; ///
enum GL_FLOAT_VEC4_ARB = 0x8B52; ///
enum GL_FOG = 0x0B60; ///
enum GL_FOG_BIT = 0x00000080; ///
enum GL_FOG_COLOR = 0x0B66; ///
enum GL_FOG_COORD = 0x8451; ///
enum GL_FOG_COORDINATE = 0x8451; ///
enum GL_FOG_COORDINATE_ARRAY = 0x8457; ///
enum GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = 0x889D; ///
enum GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB = 0x889D; ///
enum GL_FOG_COORDINATE_ARRAY_EXT = 0x8457; ///
enum GL_FOG_COORDINATE_ARRAY_LIST_IBM = 0x103076; ///
enum GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM = 0x103086; ///
enum GL_FOG_COORDINATE_ARRAY_POINTER = 0x8456; ///
enum GL_FOG_COORDINATE_ARRAY_POINTER_EXT = 0x8456; ///
enum GL_FOG_COORDINATE_ARRAY_STRIDE = 0x8455; ///
enum GL_FOG_COORDINATE_ARRAY_STRIDE_EXT = 0x8455; ///
enum GL_FOG_COORDINATE_ARRAY_TYPE = 0x8454; ///
enum GL_FOG_COORDINATE_ARRAY_TYPE_EXT = 0x8454; ///
enum GL_FOG_COORDINATE_EXT = 0x8451; ///
enum GL_FOG_COORDINATE_SOURCE = 0x8450; ///
enum GL_FOG_COORDINATE_SOURCE_EXT = 0x8450; ///
enum GL_FOG_COORD_ARRAY = 0x8457; ///
enum GL_FOG_COORD_ARRAY_ADDRESS_NV = 0x8F28; ///
enum GL_FOG_COORD_ARRAY_BUFFER_BINDING = 0x889D; ///
enum GL_FOG_COORD_ARRAY_LENGTH_NV = 0x8F32; ///
enum GL_FOG_COORD_ARRAY_POINTER = 0x8456; ///
enum GL_FOG_COORD_ARRAY_STRIDE = 0x8455; ///
enum GL_FOG_COORD_ARRAY_TYPE = 0x8454; ///
enum GL_FOG_COORD_SRC = 0x8450; ///
enum GL_FOG_DENSITY = 0x0B62; ///
enum GL_FOG_DISTANCE_MODE_NV = 0x855A; ///
enum GL_FOG_END = 0x0B64; ///
enum GL_FOG_FUNC_POINTS_SGIS = 0x812B; ///
enum GL_FOG_FUNC_SGIS = 0x812A; ///
enum GL_FOG_HINT = 0x0C54; ///
enum GL_FOG_INDEX = 0x0B61; ///
enum GL_FOG_MODE = 0x0B65; ///
enum GL_FOG_OFFSET_SGIX = 0x8198; ///
enum GL_FOG_OFFSET_VALUE_SGIX = 0x8199; ///
enum GL_FOG_SPECULAR_TEXTURE_WIN = 0x80EC; ///
enum GL_FOG_START = 0x0B63; ///
enum GL_FONT_ASCENDER_BIT_NV = 0x00200000; ///
enum GL_FONT_DESCENDER_BIT_NV = 0x00400000; ///
enum GL_FONT_GLYPHS_AVAILABLE_NV = 0x9368; ///
enum GL_FONT_HAS_KERNING_BIT_NV = 0x10000000; ///
enum GL_FONT_HEIGHT_BIT_NV = 0x00800000; ///
enum GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV = 0x02000000; ///
enum GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV = 0x01000000; ///
enum GL_FONT_NUM_GLYPH_INDICES_BIT_NV = 0x20000000; ///
enum GL_FONT_TARGET_UNAVAILABLE_NV = 0x9369; ///
enum GL_FONT_UNAVAILABLE_NV = 0x936A; ///
enum GL_FONT_UNDERLINE_POSITION_BIT_NV = 0x04000000; ///
enum GL_FONT_UNDERLINE_THICKNESS_BIT_NV = 0x08000000; ///
enum GL_FONT_UNINTELLIGIBLE_NV = 0x936B; ///
enum GL_FONT_UNITS_PER_EM_BIT_NV = 0x00100000; ///
enum GL_FONT_X_MAX_BOUNDS_BIT_NV = 0x00040000; ///
enum GL_FONT_X_MIN_BOUNDS_BIT_NV = 0x00010000; ///
enum GL_FONT_Y_MAX_BOUNDS_BIT_NV = 0x00080000; ///
enum GL_FONT_Y_MIN_BOUNDS_BIT_NV = 0x00020000; ///
enum GL_FORCE_BLUE_TO_ONE_NV = 0x8860; ///
enum GL_FORMAT_SUBSAMPLE_244_244_OML = 0x8983; ///
enum GL_FORMAT_SUBSAMPLE_24_24_OML = 0x8982; ///
enum GL_FRACTIONAL_EVEN = 0x8E7C; ///
enum GL_FRACTIONAL_EVEN_EXT = 0x8E7C; ///
enum GL_FRACTIONAL_EVEN_OES = 0x8E7C; ///
enum GL_FRACTIONAL_ODD = 0x8E7B; ///
enum GL_FRACTIONAL_ODD_EXT = 0x8E7B; ///
enum GL_FRACTIONAL_ODD_OES = 0x8E7B; ///
enum GL_FRAGMENTS_INSTRUMENT_COUNTERS_SGIX = 0x8314; ///
enum GL_FRAGMENTS_INSTRUMENT_MAX_SGIX = 0x8315; ///
enum GL_FRAGMENTS_INSTRUMENT_SGIX = 0x8313; ///
enum GL_FRAGMENT_ALPHA_MODULATE_IMG = 0x8C08; ///
enum GL_FRAGMENT_COLOR_EXT = 0x834C; ///
enum GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 0x8402; ///
enum GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 0x8403; ///
enum GL_FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401; ///
enum GL_FRAGMENT_COVERAGE_COLOR_NV = 0x92DE; ///
enum GL_FRAGMENT_COVERAGE_TO_COLOR_NV = 0x92DD; ///
enum GL_FRAGMENT_DEPTH = 0x8452; ///
enum GL_FRAGMENT_DEPTH_EXT = 0x8452; ///
enum GL_FRAGMENT_INPUT_NV = 0x936D; ///
enum GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D; ///
enum GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES = 0x8E5D; ///
enum GL_FRAGMENT_LIGHT0_SGIX = 0x840C; ///
enum GL_FRAGMENT_LIGHT1_SGIX = 0x840D; ///
enum GL_FRAGMENT_LIGHT2_SGIX = 0x840E; ///
enum GL_FRAGMENT_LIGHT3_SGIX = 0x840F; ///
enum GL_FRAGMENT_LIGHT4_SGIX = 0x8410; ///
enum GL_FRAGMENT_LIGHT5_SGIX = 0x8411; ///
enum GL_FRAGMENT_LIGHT6_SGIX = 0x8412; ///
enum GL_FRAGMENT_LIGHT7_SGIX = 0x8413; ///
enum GL_FRAGMENT_LIGHTING_SGIX = 0x8400; ///
enum GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A; ///
enum GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408; ///
enum GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B; ///
enum GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409; ///
enum GL_FRAGMENT_MATERIAL_EXT = 0x8349; ///
enum GL_FRAGMENT_NORMAL_EXT = 0x834A; ///
enum GL_FRAGMENT_PROGRAM_ARB = 0x8804; ///
enum GL_FRAGMENT_PROGRAM_BINDING_NV = 0x8873; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA = 0x8BB3; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA = 0x8BB2; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_MESA = 0x8BB1; ///
enum GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV = 0x8E5D; ///
enum GL_FRAGMENT_PROGRAM_NV = 0x8870; ///
enum GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA4; ///
enum GL_FRAGMENT_PROGRAM_POSITION_MESA = 0x8BB0; ///
enum GL_FRAGMENT_SHADER = 0x8B30; ///
enum GL_FRAGMENT_SHADER_ARB = 0x8B30; ///
enum GL_FRAGMENT_SHADER_ATI = 0x8920; ///
enum GL_FRAGMENT_SHADER_BIT = 0x00000002; ///
enum GL_FRAGMENT_SHADER_BIT_EXT = 0x00000002; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = 0x8A52; ///
enum GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM = 0x8F66; ///
enum GL_FRAGMENT_SHADER_INVOCATIONS_ARB = 0x82F4; ///
enum GL_FRAGMENT_SUBROUTINE = 0x92EC; ///
enum GL_FRAGMENT_SUBROUTINE_UNIFORM = 0x92F2; ///
enum GL_FRAGMENT_TEXTURE = 0x829F; ///
enum GL_FRAMEBUFFER = 0x8D40; ///
enum GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215; ///
enum GL_FRAMEBUFFER_ATTACHMENT_ANGLE = 0x93A3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 0x8210; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 0x8211; ///
enum GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216; ///
enum GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212; ///
enum GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = 0x9632; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = 0x9630; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT = 0x8D6C; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG = 0x913F; ///
enum GL_FRAMEBUFFER_BARRIER_BIT = 0x00000400; ///
enum GL_FRAMEBUFFER_BARRIER_BIT_EXT = 0x00000400; ///
enum GL_FRAMEBUFFER_BINDING = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_ANGLE = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_EXT = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_OES = 0x8CA6; ///
enum GL_FRAMEBUFFER_BLEND = 0x828B; ///
enum GL_FRAMEBUFFER_COMPLETE = 0x8CD5; ///
enum GL_FRAMEBUFFER_COMPLETE_EXT = 0x8CD5; ///
enum GL_FRAMEBUFFER_COMPLETE_OES = 0x8CD5; ///
enum GL_FRAMEBUFFER_DEFAULT = 0x8218; ///
enum GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314; ///
enum GL_FRAMEBUFFER_DEFAULT_HEIGHT = 0x9311; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS_OES = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_SAMPLES = 0x9313; ///
enum GL_FRAMEBUFFER_DEFAULT_WIDTH = 0x9310; ///
enum GL_FRAMEBUFFER_EXT = 0x8D40; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_OES = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT = 0x8CDA; ///
enum GL_FRAMEBUFFER_INCOMPLETE_FORMATS_OES = 0x8CDA; ///
enum GL_FRAMEBUFFER_INCOMPLETE_INSUFFICIENT_SHADER_COMBINED_LOCAL_STORAGE_EXT = 0x9652; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB = 0x8DA9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT = 0x8DA9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_AND_DOWNSAMPLE_IMG = 0x913C; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = 0x9134; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_OES = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR = 0x9633; ///
enum GL_FRAMEBUFFER_OES = 0x8D40; ///
enum GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB = 0x9342; ///
enum GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV = 0x9342; ///
enum GL_FRAMEBUFFER_RENDERABLE = 0x8289; ///
enum GL_FRAMEBUFFER_RENDERABLE_LAYERED = 0x828A; ///
enum GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB = 0x9343; ///
enum GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV = 0x9343; ///
enum GL_FRAMEBUFFER_SRGB = 0x8DB9; ///
enum GL_FRAMEBUFFER_SRGB_CAPABLE_EXT = 0x8DBA; ///
enum GL_FRAMEBUFFER_SRGB_EXT = 0x8DB9; ///
enum GL_FRAMEBUFFER_UNDEFINED = 0x8219; ///
enum GL_FRAMEBUFFER_UNDEFINED_OES = 0x8219; ///
enum GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD; ///
enum GL_FRAMEBUFFER_UNSUPPORTED_EXT = 0x8CDD; ///
enum GL_FRAMEBUFFER_UNSUPPORTED_OES = 0x8CDD; ///
enum GL_FRAMEZOOM_FACTOR_SGIX = 0x818C; ///
enum GL_FRAMEZOOM_SGIX = 0x818B; ///
enum GL_FRAME_NV = 0x8E26; ///
enum GL_FRONT = 0x0404; ///
enum GL_FRONT_AND_BACK = 0x0408; ///
enum GL_FRONT_FACE = 0x0B46; ///
enum GL_FRONT_FACE_COMMAND_NV = 0x0012; ///
enum GL_FRONT_LEFT = 0x0400; ///
enum GL_FRONT_RIGHT = 0x0401; ///
enum GL_FULL_RANGE_EXT = 0x87E1; ///
enum GL_FULL_STIPPLE_HINT_PGI = 0x1A219; ///
enum GL_FULL_SUPPORT = 0x82B7; ///
enum GL_FUNC_ADD = 0x8006; ///
enum GL_FUNC_ADD_EXT = 0x8006; ///
enum GL_FUNC_ADD_OES = 0x8006; ///
enum GL_FUNC_REVERSE_SUBTRACT = 0x800B; ///
enum GL_FUNC_REVERSE_SUBTRACT_EXT = 0x800B; ///
enum GL_FUNC_REVERSE_SUBTRACT_OES = 0x800B; ///
enum GL_FUNC_SUBTRACT = 0x800A; ///
enum GL_FUNC_SUBTRACT_EXT = 0x800A; ///
enum GL_FUNC_SUBTRACT_OES = 0x800A; ///
enum GL_GCCSO_SHADER_BINARY_FJ = 0x9260; ///
enum GL_GENERATE_MIPMAP = 0x8191; ///
enum GL_GENERATE_MIPMAP_HINT = 0x8192; ///
enum GL_GENERATE_MIPMAP_HINT_SGIS = 0x8192; ///
enum GL_GENERATE_MIPMAP_SGIS = 0x8191; ///
enum GL_GENERIC_ATTRIB_NV = 0x8C7D; ///
enum GL_GEOMETRY_DEFORMATION_BIT_SGIX = 0x00000002; ///
enum GL_GEOMETRY_DEFORMATION_SGIX = 0x8194; ///
enum GL_GEOMETRY_INPUT_TYPE = 0x8917; ///
enum GL_GEOMETRY_INPUT_TYPE_ARB = 0x8DDB; ///
enum GL_GEOMETRY_INPUT_TYPE_EXT = 0x8DDB; ///
enum GL_GEOMETRY_LINKED_INPUT_TYPE_EXT = 0x8917; ///
enum GL_GEOMETRY_LINKED_INPUT_TYPE_OES = 0x8917; ///
enum GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT = 0x8918; ///
enum GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES = 0x8918; ///
enum GL_GEOMETRY_LINKED_VERTICES_OUT_EXT = 0x8916; ///
enum GL_GEOMETRY_LINKED_VERTICES_OUT_OES = 0x8916; ///
enum GL_GEOMETRY_OUTPUT_TYPE = 0x8918; ///
enum GL_GEOMETRY_OUTPUT_TYPE_ARB = 0x8DDC; ///
enum GL_GEOMETRY_OUTPUT_TYPE_EXT = 0x8DDC; ///
enum GL_GEOMETRY_PROGRAM_NV = 0x8C26; ///
enum GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA3; ///
enum GL_GEOMETRY_SHADER = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_ARB = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_BIT = 0x00000004; ///
enum GL_GEOMETRY_SHADER_BIT_EXT = 0x00000004; ///
enum GL_GEOMETRY_SHADER_BIT_OES = 0x00000004; ///
enum GL_GEOMETRY_SHADER_EXT = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS = 0x887F; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x887F; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS_OES = 0x887F; ///
enum GL_GEOMETRY_SHADER_OES = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB = 0x82F3; ///
enum GL_GEOMETRY_SUBROUTINE = 0x92EB; ///
enum GL_GEOMETRY_SUBROUTINE_UNIFORM = 0x92F1; ///
enum GL_GEOMETRY_TEXTURE = 0x829E; ///
enum GL_GEOMETRY_VERTICES_OUT = 0x8916; ///
enum GL_GEOMETRY_VERTICES_OUT_ARB = 0x8DDA; ///
enum GL_GEOMETRY_VERTICES_OUT_EXT = 0x8DDA; ///
enum GL_GEQUAL = 0x0206; ///
enum GL_GET_TEXTURE_IMAGE_FORMAT = 0x8291; ///
enum GL_GET_TEXTURE_IMAGE_TYPE = 0x8292; ///
enum GL_GLOBAL_ALPHA_FACTOR_SUN = 0x81DA; ///
enum GL_GLOBAL_ALPHA_SUN = 0x81D9; ///
enum GL_GLYPH_HAS_KERNING_BIT_NV = 0x100; ///
enum GL_GLYPH_HEIGHT_BIT_NV = 0x02; ///
enum GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = 0x10; ///
enum GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV = 0x04; ///
enum GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV = 0x08; ///
enum GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV = 0x80; ///
enum GL_GLYPH_VERTICAL_BEARING_X_BIT_NV = 0x20; ///
enum GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV = 0x40; ///
enum GL_GLYPH_WIDTH_BIT_NV = 0x01; ///
enum GL_GPU_ADDRESS_NV = 0x8F34; ///
enum GL_GPU_DISJOINT_EXT = 0x8FBB; ///
enum GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX = 0x9049; ///
enum GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX = 0x9047; ///
enum GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX = 0x904B; ///
enum GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX = 0x904A; ///
enum GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX = 0x9048; ///
enum GL_GPU_OPTIMIZED_QCOM = 0x8FB2; ///
enum GL_GREATER = 0x0204; ///
enum GL_GREEN = 0x1904; ///
enum GL_GREEN_BIAS = 0x0D19; ///
enum GL_GREEN_BITS = 0x0D53; ///
enum GL_GREEN_BIT_ATI = 0x00000002; ///
enum GL_GREEN_INTEGER = 0x8D95; ///
enum GL_GREEN_INTEGER_EXT = 0x8D95; ///
enum GL_GREEN_MAX_CLAMP_INGR = 0x8565; ///
enum GL_GREEN_MIN_CLAMP_INGR = 0x8561; ///
enum GL_GREEN_NV = 0x1904; ///
enum GL_GREEN_SCALE = 0x0D18; ///
enum GL_GS_PROGRAM_BINARY_MTK = 0x9641; ///
enum GL_GS_SHADER_BINARY_MTK = 0x9640; ///
enum GL_GUILTY_CONTEXT_RESET = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_ARB = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_EXT = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_KHR = 0x8253; ///
enum GL_HALF_APPLE = 0x140B; ///
enum GL_HALF_BIAS_NEGATE_NV = 0x853B; ///
enum GL_HALF_BIAS_NORMAL_NV = 0x853A; ///
enum GL_HALF_BIT_ATI = 0x00000008; ///
enum GL_HALF_FLOAT = 0x140B; ///
enum GL_HALF_FLOAT_ARB = 0x140B; ///
enum GL_HALF_FLOAT_NV = 0x140B; ///
enum GL_HALF_FLOAT_OES = 0x8D61; ///
enum GL_HARDLIGHT = 0x929B; ///
enum GL_HARDLIGHT_KHR = 0x929B; ///
enum GL_HARDLIGHT_NV = 0x929B; ///
enum GL_HARDMIX_NV = 0x92A9; ///
enum GL_HIGH_FLOAT = 0x8DF2; ///
enum GL_HIGH_INT = 0x8DF5; ///
enum GL_HILO16_NV = 0x86F8; ///
enum GL_HILO8_NV = 0x885E; ///
enum GL_HILO_NV = 0x86F4; ///
enum GL_HINT_BIT = 0x00008000; ///
enum GL_HISTOGRAM = 0x8024; ///
enum GL_HISTOGRAM_ALPHA_SIZE = 0x802B; ///
enum GL_HISTOGRAM_ALPHA_SIZE_EXT = 0x802B; ///
enum GL_HISTOGRAM_BLUE_SIZE = 0x802A; ///
enum GL_HISTOGRAM_BLUE_SIZE_EXT = 0x802A; ///
enum GL_HISTOGRAM_EXT = 0x8024; ///
enum GL_HISTOGRAM_FORMAT = 0x8027; ///
enum GL_HISTOGRAM_FORMAT_EXT = 0x8027; ///
enum GL_HISTOGRAM_GREEN_SIZE = 0x8029; ///
enum GL_HISTOGRAM_GREEN_SIZE_EXT = 0x8029; ///
enum GL_HISTOGRAM_LUMINANCE_SIZE = 0x802C; ///
enum GL_HISTOGRAM_LUMINANCE_SIZE_EXT = 0x802C; ///
enum GL_HISTOGRAM_RED_SIZE = 0x8028; ///
enum GL_HISTOGRAM_RED_SIZE_EXT = 0x8028; ///
enum GL_HISTOGRAM_SINK = 0x802D; ///
enum GL_HISTOGRAM_SINK_EXT = 0x802D; ///
enum GL_HISTOGRAM_WIDTH = 0x8026; ///
enum GL_HISTOGRAM_WIDTH_EXT = 0x8026; ///
enum GL_HI_BIAS_NV = 0x8714; ///
enum GL_HI_SCALE_NV = 0x870E; ///
enum GL_HORIZONTAL_LINE_TO_NV = 0x06; ///
enum GL_HSL_COLOR = 0x92AF; ///
enum GL_HSL_COLOR_KHR = 0x92AF; ///
enum GL_HSL_COLOR_NV = 0x92AF; ///
enum GL_HSL_HUE = 0x92AD; ///
enum GL_HSL_HUE_KHR = 0x92AD; ///
enum GL_HSL_HUE_NV = 0x92AD; ///
enum GL_HSL_LUMINOSITY = 0x92B0; ///
enum GL_HSL_LUMINOSITY_KHR = 0x92B0; ///
enum GL_HSL_LUMINOSITY_NV = 0x92B0; ///
enum GL_HSL_SATURATION = 0x92AE; ///
enum GL_HSL_SATURATION_KHR = 0x92AE; ///
enum GL_HSL_SATURATION_NV = 0x92AE; ///
enum GL_IDENTITY_NV = 0x862A; ///
enum GL_IGNORE_BORDER_HP = 0x8150; ///
enum GL_IMAGE_1D = 0x904C; ///
enum GL_IMAGE_1D_ARRAY = 0x9052; ///
enum GL_IMAGE_1D_ARRAY_EXT = 0x9052; ///
enum GL_IMAGE_1D_EXT = 0x904C; ///
enum GL_IMAGE_2D = 0x904D; ///
enum GL_IMAGE_2D_ARRAY = 0x9053; ///
enum GL_IMAGE_2D_ARRAY_EXT = 0x9053; ///
enum GL_IMAGE_2D_EXT = 0x904D; ///
enum GL_IMAGE_2D_MULTISAMPLE = 0x9055; ///
enum GL_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9056; ///
enum GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x9056; ///
enum GL_IMAGE_2D_MULTISAMPLE_EXT = 0x9055; ///
enum GL_IMAGE_2D_RECT = 0x904F; ///
enum GL_IMAGE_2D_RECT_EXT = 0x904F; ///
enum GL_IMAGE_3D = 0x904E; ///
enum GL_IMAGE_3D_EXT = 0x904E; ///
enum GL_IMAGE_BINDING_ACCESS = 0x8F3E; ///
enum GL_IMAGE_BINDING_ACCESS_EXT = 0x8F3E; ///
enum GL_IMAGE_BINDING_FORMAT = 0x906E; ///
enum GL_IMAGE_BINDING_FORMAT_EXT = 0x906E; ///
enum GL_IMAGE_BINDING_LAYER = 0x8F3D; ///
enum GL_IMAGE_BINDING_LAYERED = 0x8F3C; ///
enum GL_IMAGE_BINDING_LAYERED_EXT = 0x8F3C; ///
enum GL_IMAGE_BINDING_LAYER_EXT = 0x8F3D; ///
enum GL_IMAGE_BINDING_LEVEL = 0x8F3B; ///
enum GL_IMAGE_BINDING_LEVEL_EXT = 0x8F3B; ///
enum GL_IMAGE_BINDING_NAME = 0x8F3A; ///
enum GL_IMAGE_BINDING_NAME_EXT = 0x8F3A; ///
enum GL_IMAGE_BUFFER = 0x9051; ///
enum GL_IMAGE_BUFFER_EXT = 0x9051; ///
enum GL_IMAGE_BUFFER_OES = 0x9051; ///
enum GL_IMAGE_CLASS_10_10_10_2 = 0x82C3; ///
enum GL_IMAGE_CLASS_11_11_10 = 0x82C2; ///
enum GL_IMAGE_CLASS_1_X_16 = 0x82BE; ///
enum GL_IMAGE_CLASS_1_X_32 = 0x82BB; ///
enum GL_IMAGE_CLASS_1_X_8 = 0x82C1; ///
enum GL_IMAGE_CLASS_2_X_16 = 0x82BD; ///
enum GL_IMAGE_CLASS_2_X_32 = 0x82BA; ///
enum GL_IMAGE_CLASS_2_X_8 = 0x82C0; ///
enum GL_IMAGE_CLASS_4_X_16 = 0x82BC; ///
enum GL_IMAGE_CLASS_4_X_32 = 0x82B9; ///
enum GL_IMAGE_CLASS_4_X_8 = 0x82BF; ///
enum GL_IMAGE_COMPATIBILITY_CLASS = 0x82A8; ///
enum GL_IMAGE_CUBE = 0x9050; ///
enum GL_IMAGE_CUBE_EXT = 0x9050; ///
enum GL_IMAGE_CUBE_MAP_ARRAY = 0x9054; ///
enum GL_IMAGE_CUBE_MAP_ARRAY_EXT = 0x9054; ///
enum GL_IMAGE_CUBE_MAP_ARRAY_OES = 0x9054; ///
enum GL_IMAGE_CUBIC_WEIGHT_HP = 0x815E; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7; ///
enum GL_IMAGE_MAG_FILTER_HP = 0x815C; ///
enum GL_IMAGE_MIN_FILTER_HP = 0x815D; ///
enum GL_IMAGE_PIXEL_FORMAT = 0x82A9; ///
enum GL_IMAGE_PIXEL_TYPE = 0x82AA; ///
enum GL_IMAGE_ROTATE_ANGLE_HP = 0x8159; ///
enum GL_IMAGE_ROTATE_ORIGIN_X_HP = 0x815A; ///
enum GL_IMAGE_ROTATE_ORIGIN_Y_HP = 0x815B; ///
enum GL_IMAGE_SCALE_X_HP = 0x8155; ///
enum GL_IMAGE_SCALE_Y_HP = 0x8156; ///
enum GL_IMAGE_TEXEL_SIZE = 0x82A7; ///
enum GL_IMAGE_TRANSFORM_2D_HP = 0x8161; ///
enum GL_IMAGE_TRANSLATE_X_HP = 0x8157; ///
enum GL_IMAGE_TRANSLATE_Y_HP = 0x8158; ///
enum GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B; ///
enum GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES = 0x8B9B; ///
enum GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A; ///
enum GL_IMPLEMENTATION_COLOR_READ_TYPE_OES = 0x8B9A; ///
enum GL_INCLUSIVE_EXT = 0x8F10; ///
enum GL_INCR = 0x1E02; ///
enum GL_INCR_WRAP = 0x8507; ///
enum GL_INCR_WRAP_EXT = 0x8507; ///
enum GL_INCR_WRAP_OES = 0x8507; ///
enum GL_INDEX = 0x8222; ///
enum GL_INDEX_ARRAY = 0x8077; ///
enum GL_INDEX_ARRAY_ADDRESS_NV = 0x8F24; ///
enum GL_INDEX_ARRAY_BUFFER_BINDING = 0x8899; ///
enum GL_INDEX_ARRAY_BUFFER_BINDING_ARB = 0x8899; ///
enum GL_INDEX_ARRAY_COUNT_EXT = 0x8087; ///
enum GL_INDEX_ARRAY_EXT = 0x8077; ///
enum GL_INDEX_ARRAY_LENGTH_NV = 0x8F2E; ///
enum GL_INDEX_ARRAY_LIST_IBM = 0x103073; ///
enum GL_INDEX_ARRAY_LIST_STRIDE_IBM = 0x103083; ///
enum GL_INDEX_ARRAY_POINTER = 0x8091; ///
enum GL_INDEX_ARRAY_POINTER_EXT = 0x8091; ///
enum GL_INDEX_ARRAY_STRIDE = 0x8086; ///
enum GL_INDEX_ARRAY_STRIDE_EXT = 0x8086; ///
enum GL_INDEX_ARRAY_TYPE = 0x8085; ///
enum GL_INDEX_ARRAY_TYPE_EXT = 0x8085; ///
enum GL_INDEX_BITS = 0x0D51; ///
enum GL_INDEX_BIT_PGI = 0x00080000; ///
enum GL_INDEX_CLEAR_VALUE = 0x0C20; ///
enum GL_INDEX_LOGIC_OP = 0x0BF1; ///
enum GL_INDEX_MATERIAL_EXT = 0x81B8; ///
enum GL_INDEX_MATERIAL_FACE_EXT = 0x81BA; ///
enum GL_INDEX_MATERIAL_PARAMETER_EXT = 0x81B9; ///
enum GL_INDEX_MODE = 0x0C30; ///
enum GL_INDEX_OFFSET = 0x0D13; ///
enum GL_INDEX_SHIFT = 0x0D12; ///
enum GL_INDEX_TEST_EXT = 0x81B5; ///
enum GL_INDEX_TEST_FUNC_EXT = 0x81B6; ///
enum GL_INDEX_TEST_REF_EXT = 0x81B7; ///
enum GL_INDEX_WRITEMASK = 0x0C21; ///
enum GL_INFO_LOG_LENGTH = 0x8B84; ///
enum GL_INNOCENT_CONTEXT_RESET = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_ARB = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_EXT = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_KHR = 0x8254; ///
enum GL_INSTRUMENT_BUFFER_POINTER_SGIX = 0x8180; ///
enum GL_INSTRUMENT_MEASUREMENTS_SGIX = 0x8181; ///
enum GL_INT = 0x1404; ///
enum GL_INT16_NV = 0x8FE4; ///
enum GL_INT16_VEC2_NV = 0x8FE5; ///
enum GL_INT16_VEC3_NV = 0x8FE6; ///
enum GL_INT16_VEC4_NV = 0x8FE7; ///
enum GL_INT64_ARB = 0x140E; ///
enum GL_INT64_NV = 0x140E; ///
enum GL_INT64_VEC2_ARB = 0x8FE9; ///
enum GL_INT64_VEC2_NV = 0x8FE9; ///
enum GL_INT64_VEC3_ARB = 0x8FEA; ///
enum GL_INT64_VEC3_NV = 0x8FEA; ///
enum GL_INT64_VEC4_ARB = 0x8FEB; ///
enum GL_INT64_VEC4_NV = 0x8FEB; ///
enum GL_INT8_NV = 0x8FE0; ///
enum GL_INT8_VEC2_NV = 0x8FE1; ///
enum GL_INT8_VEC3_NV = 0x8FE2; ///
enum GL_INT8_VEC4_NV = 0x8FE3; ///
enum GL_INTENSITY = 0x8049; ///
enum GL_INTENSITY12 = 0x804C; ///
enum GL_INTENSITY12_EXT = 0x804C; ///
enum GL_INTENSITY16 = 0x804D; ///
enum GL_INTENSITY16F_ARB = 0x881D; ///
enum GL_INTENSITY16I_EXT = 0x8D8B; ///
enum GL_INTENSITY16UI_EXT = 0x8D79; ///
enum GL_INTENSITY16_EXT = 0x804D; ///
enum GL_INTENSITY16_SNORM = 0x901B; ///
enum GL_INTENSITY32F_ARB = 0x8817; ///
enum GL_INTENSITY32I_EXT = 0x8D85; ///
enum GL_INTENSITY32UI_EXT = 0x8D73; ///
enum GL_INTENSITY4 = 0x804A; ///
enum GL_INTENSITY4_EXT = 0x804A; ///
enum GL_INTENSITY8 = 0x804B; ///
enum GL_INTENSITY8I_EXT = 0x8D91; ///
enum GL_INTENSITY8UI_EXT = 0x8D7F; ///
enum GL_INTENSITY8_EXT = 0x804B; ///
enum GL_INTENSITY8_SNORM = 0x9017; ///
enum GL_INTENSITY_EXT = 0x8049; ///
enum GL_INTENSITY_FLOAT16_APPLE = 0x881D; ///
enum GL_INTENSITY_FLOAT16_ATI = 0x881D; ///
enum GL_INTENSITY_FLOAT32_APPLE = 0x8817; ///
enum GL_INTENSITY_FLOAT32_ATI = 0x8817; ///
enum GL_INTENSITY_SNORM = 0x9013; ///
enum GL_INTERLACE_OML = 0x8980; ///
enum GL_INTERLACE_READ_INGR = 0x8568; ///
enum GL_INTERLACE_READ_OML = 0x8981; ///
enum GL_INTERLACE_SGIX = 0x8094; ///
enum GL_INTERLEAVED_ATTRIBS = 0x8C8C; ///
enum GL_INTERLEAVED_ATTRIBS_EXT = 0x8C8C; ///
enum GL_INTERLEAVED_ATTRIBS_NV = 0x8C8C; ///
enum GL_INTERNALFORMAT_ALPHA_SIZE = 0x8274; ///
enum GL_INTERNALFORMAT_ALPHA_TYPE = 0x827B; ///
enum GL_INTERNALFORMAT_BLUE_SIZE = 0x8273; ///
enum GL_INTERNALFORMAT_BLUE_TYPE = 0x827A; ///
enum GL_INTERNALFORMAT_DEPTH_SIZE = 0x8275; ///
enum GL_INTERNALFORMAT_DEPTH_TYPE = 0x827C; ///
enum GL_INTERNALFORMAT_GREEN_SIZE = 0x8272; ///
enum GL_INTERNALFORMAT_GREEN_TYPE = 0x8279; ///
enum GL_INTERNALFORMAT_PREFERRED = 0x8270; ///
enum GL_INTERNALFORMAT_RED_SIZE = 0x8271; ///
enum GL_INTERNALFORMAT_RED_TYPE = 0x8278; ///
enum GL_INTERNALFORMAT_SHARED_SIZE = 0x8277; ///
enum GL_INTERNALFORMAT_STENCIL_SIZE = 0x8276; ///
enum GL_INTERNALFORMAT_STENCIL_TYPE = 0x827D; ///
enum GL_INTERNALFORMAT_SUPPORTED = 0x826F; ///
enum GL_INTERPOLATE = 0x8575; ///
enum GL_INTERPOLATE_ARB = 0x8575; ///
enum GL_INTERPOLATE_EXT = 0x8575; ///
enum GL_INT_10_10_10_2_OES = 0x8DF7; ///
enum GL_INT_2_10_10_10_REV = 0x8D9F; ///
enum GL_INT_IMAGE_1D = 0x9057; ///
enum GL_INT_IMAGE_1D_ARRAY = 0x905D; ///
enum GL_INT_IMAGE_1D_ARRAY_EXT = 0x905D; ///
enum GL_INT_IMAGE_1D_EXT = 0x9057; ///
enum GL_INT_IMAGE_2D = 0x9058; ///
enum GL_INT_IMAGE_2D_ARRAY = 0x905E; ///
enum GL_INT_IMAGE_2D_ARRAY_EXT = 0x905E; ///
enum GL_INT_IMAGE_2D_EXT = 0x9058; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE = 0x9060; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x9061; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_EXT = 0x9060; ///
enum GL_INT_IMAGE_2D_RECT = 0x905A; ///
enum GL_INT_IMAGE_2D_RECT_EXT = 0x905A; ///
enum GL_INT_IMAGE_3D = 0x9059; ///
enum GL_INT_IMAGE_3D_EXT = 0x9059; ///
enum GL_INT_IMAGE_BUFFER = 0x905C; ///
enum GL_INT_IMAGE_BUFFER_EXT = 0x905C; ///
enum GL_INT_IMAGE_BUFFER_OES = 0x905C; ///
enum GL_INT_IMAGE_CUBE = 0x905B; ///
enum GL_INT_IMAGE_CUBE_EXT = 0x905B; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY = 0x905F; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x905F; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x905F; ///
enum GL_INT_SAMPLER_1D = 0x8DC9; ///
enum GL_INT_SAMPLER_1D_ARRAY = 0x8DCE; ///
enum GL_INT_SAMPLER_1D_ARRAY_EXT = 0x8DCE; ///
enum GL_INT_SAMPLER_1D_EXT = 0x8DC9; ///
enum GL_INT_SAMPLER_2D = 0x8DCA; ///
enum GL_INT_SAMPLER_2D_ARRAY = 0x8DCF; ///
enum GL_INT_SAMPLER_2D_ARRAY_EXT = 0x8DCF; ///
enum GL_INT_SAMPLER_2D_EXT = 0x8DCA; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE = 0x9109; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910C; ///
enum GL_INT_SAMPLER_2D_RECT = 0x8DCD; ///
enum GL_INT_SAMPLER_2D_RECT_EXT = 0x8DCD; ///
enum GL_INT_SAMPLER_3D = 0x8DCB; ///
enum GL_INT_SAMPLER_3D_EXT = 0x8DCB; ///
enum GL_INT_SAMPLER_BUFFER = 0x8DD0; ///
enum GL_INT_SAMPLER_BUFFER_AMD = 0x9002; ///
enum GL_INT_SAMPLER_BUFFER_EXT = 0x8DD0; ///
enum GL_INT_SAMPLER_BUFFER_OES = 0x8DD0; ///
enum GL_INT_SAMPLER_CUBE = 0x8DCC; ///
enum GL_INT_SAMPLER_CUBE_EXT = 0x8DCC; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900E; ///
enum GL_INT_SAMPLER_RENDERBUFFER_NV = 0x8E57; ///
enum GL_INT_VEC2 = 0x8B53; ///
enum GL_INT_VEC2_ARB = 0x8B53; ///
enum GL_INT_VEC3 = 0x8B54; ///
enum GL_INT_VEC3_ARB = 0x8B54; ///
enum GL_INT_VEC4 = 0x8B55; ///
enum GL_INT_VEC4_ARB = 0x8B55; ///
enum GL_INVALID_ENUM = 0x0500; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION = 0x0506; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION_EXT = 0x0506; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION_OES = 0x0506; ///
enum GL_INVALID_INDEX = 0xFFFFFFFF; ///
enum GL_INVALID_OPERATION = 0x0502; ///
enum GL_INVALID_VALUE = 0x0501; ///
enum GL_INVARIANT_DATATYPE_EXT = 0x87EB; ///
enum GL_INVARIANT_EXT = 0x87C2; ///
enum GL_INVARIANT_VALUE_EXT = 0x87EA; ///
enum GL_INVERSE_NV = 0x862B; ///
enum GL_INVERSE_TRANSPOSE_NV = 0x862D; ///
enum GL_INVERT = 0x150A; ///
enum GL_INVERTED_SCREEN_W_REND = 0x8491; ///
enum GL_INVERT_OVG_NV = 0x92B4; ///
enum GL_INVERT_RGB_NV = 0x92A3; ///
enum GL_IR_INSTRUMENT1_SGIX = 0x817F; ///
enum GL_ISOLINES = 0x8E7A; ///
enum GL_ISOLINES_EXT = 0x8E7A; ///
enum GL_ISOLINES_OES = 0x8E7A; ///
enum GL_IS_PER_PATCH = 0x92E7; ///
enum GL_IS_PER_PATCH_EXT = 0x92E7; ///
enum GL_IS_PER_PATCH_OES = 0x92E7; ///
enum GL_IS_ROW_MAJOR = 0x9300; ///
enum GL_ITALIC_BIT_NV = 0x02; ///
enum GL_IUI_N3F_V2F_EXT = 0x81AF; ///
enum GL_IUI_N3F_V3F_EXT = 0x81B0; ///
enum GL_IUI_V2F_EXT = 0x81AD; ///
enum GL_IUI_V3F_EXT = 0x81AE; ///
enum GL_KEEP = 0x1E00; ///
enum GL_LARGE_CCW_ARC_TO_NV = 0x16; ///
enum GL_LARGE_CW_ARC_TO_NV = 0x18; ///
enum GL_LAST_VERTEX_CONVENTION = 0x8E4E; ///
enum GL_LAST_VERTEX_CONVENTION_EXT = 0x8E4E; ///
enum GL_LAST_VERTEX_CONVENTION_OES = 0x8E4E; ///
enum GL_LAST_VIDEO_CAPTURE_STATUS_NV = 0x9027; ///
enum GL_LAYER_NV = 0x8DAA; ///
enum GL_LAYER_PROVOKING_VERTEX = 0x825E; ///
enum GL_LAYER_PROVOKING_VERTEX_EXT = 0x825E; ///
enum GL_LAYER_PROVOKING_VERTEX_OES = 0x825E; ///
enum GL_LAYOUT_DEFAULT_INTEL = 0; ///
enum GL_LAYOUT_LINEAR_CPU_CACHED_INTEL = 2; ///
enum GL_LAYOUT_LINEAR_INTEL = 1; ///
enum GL_LEFT = 0x0406; ///
enum GL_LEQUAL = 0x0203; ///
enum GL_LERP_ATI = 0x8969; ///
enum GL_LESS = 0x0201; ///
enum GL_LIGHT0 = 0x4000; ///
enum GL_LIGHT1 = 0x4001; ///
enum GL_LIGHT2 = 0x4002; ///
enum GL_LIGHT3 = 0x4003; ///
enum GL_LIGHT4 = 0x4004; ///
enum GL_LIGHT5 = 0x4005; ///
enum GL_LIGHT6 = 0x4006; ///
enum GL_LIGHT7 = 0x4007; ///
enum GL_LIGHTEN = 0x9298; ///
enum GL_LIGHTEN_KHR = 0x9298; ///
enum GL_LIGHTEN_NV = 0x9298; ///
enum GL_LIGHTING = 0x0B50; ///
enum GL_LIGHTING_BIT = 0x00000040; ///
enum GL_LIGHT_ENV_MODE_SGIX = 0x8407; ///
enum GL_LIGHT_MODEL_AMBIENT = 0x0B53; ///
enum GL_LIGHT_MODEL_COLOR_CONTROL = 0x81F8; ///
enum GL_LIGHT_MODEL_COLOR_CONTROL_EXT = 0x81F8; ///
enum GL_LIGHT_MODEL_LOCAL_VIEWER = 0x0B51; ///
enum GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE = 0x85B0; ///
enum GL_LIGHT_MODEL_TWO_SIDE = 0x0B52; ///
enum GL_LINE = 0x1B01; ///
enum GL_LINEAR = 0x2601; ///
enum GL_LINEARBURN_NV = 0x92A5; ///
enum GL_LINEARDODGE_NV = 0x92A4; ///
enum GL_LINEARLIGHT_NV = 0x92A7; ///
enum GL_LINEAR_ATTENUATION = 0x1208; ///
enum GL_LINEAR_CLIPMAP_LINEAR_SGIX = 0x8170; ///
enum GL_LINEAR_CLIPMAP_NEAREST_SGIX = 0x844F; ///
enum GL_LINEAR_DETAIL_ALPHA_SGIS = 0x8098; ///
enum GL_LINEAR_DETAIL_COLOR_SGIS = 0x8099; ///
enum GL_LINEAR_DETAIL_SGIS = 0x8097; ///
enum GL_LINEAR_MIPMAP_LINEAR = 0x2703; ///
enum GL_LINEAR_MIPMAP_NEAREST = 0x2701; ///
enum GL_LINEAR_SHARPEN_ALPHA_SGIS = 0x80AE; ///
enum GL_LINEAR_SHARPEN_COLOR_SGIS = 0x80AF; ///
enum GL_LINEAR_SHARPEN_SGIS = 0x80AD; ///
enum GL_LINES = 0x0001; ///
enum GL_LINES_ADJACENCY = 0x000A; ///
enum GL_LINES_ADJACENCY_ARB = 0x000A; ///
enum GL_LINES_ADJACENCY_EXT = 0x000A; ///
enum GL_LINES_ADJACENCY_OES = 0x000A; ///
enum GL_LINE_BIT = 0x00000004; ///
enum GL_LINE_LOOP = 0x0002; ///
enum GL_LINE_NV = 0x1B01; ///
enum GL_LINE_QUALITY_HINT_SGIX = 0x835B; ///
enum GL_LINE_RESET_TOKEN = 0x0707; ///
enum GL_LINE_SMOOTH = 0x0B20; ///
enum GL_LINE_SMOOTH_HINT = 0x0C52; ///
enum GL_LINE_STIPPLE = 0x0B24; ///
enum GL_LINE_STIPPLE_PATTERN = 0x0B25; ///
enum GL_LINE_STIPPLE_REPEAT = 0x0B26; ///
enum GL_LINE_STRIP = 0x0003; ///
enum GL_LINE_STRIP_ADJACENCY = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_ARB = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_EXT = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_OES = 0x000B; ///
enum GL_LINE_TOKEN = 0x0702; ///
enum GL_LINE_TO_NV = 0x04; ///
enum GL_LINE_WIDTH = 0x0B21; ///
enum GL_LINE_WIDTH_COMMAND_NV = 0x000D; ///
enum GL_LINE_WIDTH_GRANULARITY = 0x0B23; ///
enum GL_LINE_WIDTH_RANGE = 0x0B22; ///
enum GL_LINK_STATUS = 0x8B82; ///
enum GL_LIST_BASE = 0x0B32; ///
enum GL_LIST_BIT = 0x00020000; ///
enum GL_LIST_INDEX = 0x0B33; ///
enum GL_LIST_MODE = 0x0B30; ///
enum GL_LIST_PRIORITY_SGIX = 0x8182; ///
enum GL_LOAD = 0x0101; ///
enum GL_LOCAL_CONSTANT_DATATYPE_EXT = 0x87ED; ///
enum GL_LOCAL_CONSTANT_EXT = 0x87C3; ///
enum GL_LOCAL_CONSTANT_VALUE_EXT = 0x87EC; ///
enum GL_LOCAL_EXT = 0x87C4; ///
enum GL_LOCATION = 0x930E; ///
enum GL_LOCATION_COMPONENT = 0x934A; ///
enum GL_LOCATION_INDEX = 0x930F; ///
enum GL_LOCATION_INDEX_EXT = 0x930F; ///
enum GL_LOGIC_OP = 0x0BF1; ///
enum GL_LOGIC_OP_MODE = 0x0BF0; ///
enum GL_LOSE_CONTEXT_ON_RESET = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_ARB = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_EXT = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_KHR = 0x8252; ///
enum GL_LOWER_LEFT = 0x8CA1; ///
enum GL_LOW_FLOAT = 0x8DF0; ///
enum GL_LOW_INT = 0x8DF3; ///
enum GL_LO_BIAS_NV = 0x8715; ///
enum GL_LO_SCALE_NV = 0x870F; ///
enum GL_LUMINANCE = 0x1909; ///
enum GL_LUMINANCE12 = 0x8041; ///
enum GL_LUMINANCE12_ALPHA12 = 0x8047; ///
enum GL_LUMINANCE12_ALPHA12_EXT = 0x8047; ///
enum GL_LUMINANCE12_ALPHA4 = 0x8046; ///
enum GL_LUMINANCE12_ALPHA4_EXT = 0x8046; ///
enum GL_LUMINANCE12_EXT = 0x8041; ///
enum GL_LUMINANCE16 = 0x8042; ///
enum GL_LUMINANCE16F_ARB = 0x881E; ///
enum GL_LUMINANCE16F_EXT = 0x881E; ///
enum GL_LUMINANCE16I_EXT = 0x8D8C; ///
enum GL_LUMINANCE16UI_EXT = 0x8D7A; ///
enum GL_LUMINANCE16_ALPHA16 = 0x8048; ///
enum GL_LUMINANCE16_ALPHA16_EXT = 0x8048; ///
enum GL_LUMINANCE16_ALPHA16_SNORM = 0x901A; ///
enum GL_LUMINANCE16_EXT = 0x8042; ///
enum GL_LUMINANCE16_SNORM = 0x9019; ///
enum GL_LUMINANCE32F_ARB = 0x8818; ///
enum GL_LUMINANCE32F_EXT = 0x8818; ///
enum GL_LUMINANCE32I_EXT = 0x8D86; ///
enum GL_LUMINANCE32UI_EXT = 0x8D74; ///
enum GL_LUMINANCE4 = 0x803F; ///
enum GL_LUMINANCE4_ALPHA4 = 0x8043; ///
enum GL_LUMINANCE4_ALPHA4_EXT = 0x8043; ///
enum GL_LUMINANCE4_ALPHA4_OES = 0x8043; ///
enum GL_LUMINANCE4_EXT = 0x803F; ///
enum GL_LUMINANCE6_ALPHA2 = 0x8044; ///
enum GL_LUMINANCE6_ALPHA2_EXT = 0x8044; ///
enum GL_LUMINANCE8 = 0x8040; ///
enum GL_LUMINANCE8I_EXT = 0x8D92; ///
enum GL_LUMINANCE8UI_EXT = 0x8D80; ///
enum GL_LUMINANCE8_ALPHA8 = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_EXT = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_OES = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_SNORM = 0x9016; ///
enum GL_LUMINANCE8_EXT = 0x8040; ///
enum GL_LUMINANCE8_OES = 0x8040; ///
enum GL_LUMINANCE8_SNORM = 0x9015; ///
enum GL_LUMINANCE_ALPHA = 0x190A; ///
enum GL_LUMINANCE_ALPHA16F_ARB = 0x881F; ///
enum GL_LUMINANCE_ALPHA16F_EXT = 0x881F; ///
enum GL_LUMINANCE_ALPHA16I_EXT = 0x8D8D; ///
enum GL_LUMINANCE_ALPHA16UI_EXT = 0x8D7B; ///
enum GL_LUMINANCE_ALPHA32F_ARB = 0x8819; ///
enum GL_LUMINANCE_ALPHA32F_EXT = 0x8819; ///
enum GL_LUMINANCE_ALPHA32I_EXT = 0x8D87; ///
enum GL_LUMINANCE_ALPHA32UI_EXT = 0x8D75; ///
enum GL_LUMINANCE_ALPHA8I_EXT = 0x8D93; ///
enum GL_LUMINANCE_ALPHA8UI_EXT = 0x8D81; ///
enum GL_LUMINANCE_ALPHA_FLOAT16_APPLE = 0x881F; ///
enum GL_LUMINANCE_ALPHA_FLOAT16_ATI = 0x881F; ///
enum GL_LUMINANCE_ALPHA_FLOAT32_APPLE = 0x8819; ///
enum GL_LUMINANCE_ALPHA_FLOAT32_ATI = 0x8819; ///
enum GL_LUMINANCE_ALPHA_INTEGER_EXT = 0x8D9D; ///
enum GL_LUMINANCE_ALPHA_SNORM = 0x9012; ///
enum GL_LUMINANCE_FLOAT16_APPLE = 0x881E; ///
enum GL_LUMINANCE_FLOAT16_ATI = 0x881E; ///
enum GL_LUMINANCE_FLOAT32_APPLE = 0x8818; ///
enum GL_LUMINANCE_FLOAT32_ATI = 0x8818; ///
enum GL_LUMINANCE_INTEGER_EXT = 0x8D9C; ///
enum GL_LUMINANCE_SNORM = 0x9011; ///
enum GL_MAD_ATI = 0x8968; ///
enum GL_MAGNITUDE_BIAS_NV = 0x8718; ///
enum GL_MAGNITUDE_SCALE_NV = 0x8712; ///
enum GL_MAJOR_VERSION = 0x821B; ///
enum GL_MALI_PROGRAM_BINARY_ARM = 0x8F61; ///
enum GL_MALI_SHADER_BINARY_ARM = 0x8F60; ///
enum GL_MANUAL_GENERATE_MIPMAP = 0x8294; ///
enum GL_MAP1_BINORMAL_EXT = 0x8446; ///
enum GL_MAP1_COLOR_4 = 0x0D90; ///
enum GL_MAP1_GRID_DOMAIN = 0x0DD0; ///
enum GL_MAP1_GRID_SEGMENTS = 0x0DD1; ///
enum GL_MAP1_INDEX = 0x0D91; ///
enum GL_MAP1_NORMAL = 0x0D92; ///
enum GL_MAP1_TANGENT_EXT = 0x8444; ///
enum GL_MAP1_TEXTURE_COORD_1 = 0x0D93; ///
enum GL_MAP1_TEXTURE_COORD_2 = 0x0D94; ///
enum GL_MAP1_TEXTURE_COORD_3 = 0x0D95; ///
enum GL_MAP1_TEXTURE_COORD_4 = 0x0D96; ///
enum GL_MAP1_VERTEX_3 = 0x0D97; ///
enum GL_MAP1_VERTEX_4 = 0x0D98; ///
enum GL_MAP1_VERTEX_ATTRIB0_4_NV = 0x8660; ///
enum GL_MAP1_VERTEX_ATTRIB10_4_NV = 0x866A; ///
enum GL_MAP1_VERTEX_ATTRIB11_4_NV = 0x866B; ///
enum GL_MAP1_VERTEX_ATTRIB12_4_NV = 0x866C; ///
enum GL_MAP1_VERTEX_ATTRIB13_4_NV = 0x866D; ///
enum GL_MAP1_VERTEX_ATTRIB14_4_NV = 0x866E; ///
enum GL_MAP1_VERTEX_ATTRIB15_4_NV = 0x866F; ///
enum GL_MAP1_VERTEX_ATTRIB1_4_NV = 0x8661; ///
enum GL_MAP1_VERTEX_ATTRIB2_4_NV = 0x8662; ///
enum GL_MAP1_VERTEX_ATTRIB3_4_NV = 0x8663; ///
enum GL_MAP1_VERTEX_ATTRIB4_4_NV = 0x8664; ///
enum GL_MAP1_VERTEX_ATTRIB5_4_NV = 0x8665; ///
enum GL_MAP1_VERTEX_ATTRIB6_4_NV = 0x8666; ///
enum GL_MAP1_VERTEX_ATTRIB7_4_NV = 0x8667; ///
enum GL_MAP1_VERTEX_ATTRIB8_4_NV = 0x8668; ///
enum GL_MAP1_VERTEX_ATTRIB9_4_NV = 0x8669; ///
enum GL_MAP2_BINORMAL_EXT = 0x8447; ///
enum GL_MAP2_COLOR_4 = 0x0DB0; ///
enum GL_MAP2_GRID_DOMAIN = 0x0DD2; ///
enum GL_MAP2_GRID_SEGMENTS = 0x0DD3; ///
enum GL_MAP2_INDEX = 0x0DB1; ///
enum GL_MAP2_NORMAL = 0x0DB2; ///
enum GL_MAP2_TANGENT_EXT = 0x8445; ///
enum GL_MAP2_TEXTURE_COORD_1 = 0x0DB3; ///
enum GL_MAP2_TEXTURE_COORD_2 = 0x0DB4; ///
enum GL_MAP2_TEXTURE_COORD_3 = 0x0DB5; ///
enum GL_MAP2_TEXTURE_COORD_4 = 0x0DB6; ///
enum GL_MAP2_VERTEX_3 = 0x0DB7; ///
enum GL_MAP2_VERTEX_4 = 0x0DB8; ///
enum GL_MAP2_VERTEX_ATTRIB0_4_NV = 0x8670; ///
enum GL_MAP2_VERTEX_ATTRIB10_4_NV = 0x867A; ///
enum GL_MAP2_VERTEX_ATTRIB11_4_NV = 0x867B; ///
enum GL_MAP2_VERTEX_ATTRIB12_4_NV = 0x867C; ///
enum GL_MAP2_VERTEX_ATTRIB13_4_NV = 0x867D; ///
enum GL_MAP2_VERTEX_ATTRIB14_4_NV = 0x867E; ///
enum GL_MAP2_VERTEX_ATTRIB15_4_NV = 0x867F; ///
enum GL_MAP2_VERTEX_ATTRIB1_4_NV = 0x8671; ///
enum GL_MAP2_VERTEX_ATTRIB2_4_NV = 0x8672; ///
enum GL_MAP2_VERTEX_ATTRIB3_4_NV = 0x8673; ///
enum GL_MAP2_VERTEX_ATTRIB4_4_NV = 0x8674; ///
enum GL_MAP2_VERTEX_ATTRIB5_4_NV = 0x8675; ///
enum GL_MAP2_VERTEX_ATTRIB6_4_NV = 0x8676; ///
enum GL_MAP2_VERTEX_ATTRIB7_4_NV = 0x8677; ///
enum GL_MAP2_VERTEX_ATTRIB8_4_NV = 0x8678; ///
enum GL_MAP2_VERTEX_ATTRIB9_4_NV = 0x8679; ///
enum GL_MAP_ATTRIB_U_ORDER_NV = 0x86C3; ///
enum GL_MAP_ATTRIB_V_ORDER_NV = 0x86C4; ///
enum GL_MAP_COHERENT_BIT = 0x0080; ///
enum GL_MAP_COHERENT_BIT_EXT = 0x0080; ///
enum GL_MAP_COLOR = 0x0D10; ///
enum GL_MAP_FLUSH_EXPLICIT_BIT = 0x0010; ///
enum GL_MAP_FLUSH_EXPLICIT_BIT_EXT = 0x0010; ///
enum GL_MAP_INVALIDATE_BUFFER_BIT = 0x0008; ///
enum GL_MAP_INVALIDATE_BUFFER_BIT_EXT = 0x0008; ///
enum GL_MAP_INVALIDATE_RANGE_BIT = 0x0004; ///
enum GL_MAP_INVALIDATE_RANGE_BIT_EXT = 0x0004; ///
enum GL_MAP_PERSISTENT_BIT = 0x0040; ///
enum GL_MAP_PERSISTENT_BIT_EXT = 0x0040; ///
enum GL_MAP_READ_BIT = 0x0001; ///
enum GL_MAP_READ_BIT_EXT = 0x0001; ///
enum GL_MAP_STENCIL = 0x0D11; ///
enum GL_MAP_TESSELLATION_NV = 0x86C2; ///
enum GL_MAP_UNSYNCHRONIZED_BIT = 0x0020; ///
enum GL_MAP_UNSYNCHRONIZED_BIT_EXT = 0x0020; ///
enum GL_MAP_WRITE_BIT = 0x0002; ///
enum GL_MAP_WRITE_BIT_EXT = 0x0002; ///
enum GL_MATERIAL_SIDE_HINT_PGI = 0x1A22C; ///
enum GL_MATRIX0_ARB = 0x88C0; ///
enum GL_MATRIX0_NV = 0x8630; ///
enum GL_MATRIX10_ARB = 0x88CA; ///
enum GL_MATRIX11_ARB = 0x88CB; ///
enum GL_MATRIX12_ARB = 0x88CC; ///
enum GL_MATRIX13_ARB = 0x88CD; ///
enum GL_MATRIX14_ARB = 0x88CE; ///
enum GL_MATRIX15_ARB = 0x88CF; ///
enum GL_MATRIX16_ARB = 0x88D0; ///
enum GL_MATRIX17_ARB = 0x88D1; ///
enum GL_MATRIX18_ARB = 0x88D2; ///
enum GL_MATRIX19_ARB = 0x88D3; ///
enum GL_MATRIX1_ARB = 0x88C1; ///
enum GL_MATRIX1_NV = 0x8631; ///
enum GL_MATRIX20_ARB = 0x88D4; ///
enum GL_MATRIX21_ARB = 0x88D5; ///
enum GL_MATRIX22_ARB = 0x88D6; ///
enum GL_MATRIX23_ARB = 0x88D7; ///
enum GL_MATRIX24_ARB = 0x88D8; ///
enum GL_MATRIX25_ARB = 0x88D9; ///
enum GL_MATRIX26_ARB = 0x88DA; ///
enum GL_MATRIX27_ARB = 0x88DB; ///
enum GL_MATRIX28_ARB = 0x88DC; ///
enum GL_MATRIX29_ARB = 0x88DD; ///
enum GL_MATRIX2_ARB = 0x88C2; ///
enum GL_MATRIX2_NV = 0x8632; ///
enum GL_MATRIX30_ARB = 0x88DE; ///
enum GL_MATRIX31_ARB = 0x88DF; ///
enum GL_MATRIX3_ARB = 0x88C3; ///
enum GL_MATRIX3_NV = 0x8633; ///
enum GL_MATRIX4_ARB = 0x88C4; ///
enum GL_MATRIX4_NV = 0x8634; ///
enum GL_MATRIX5_ARB = 0x88C5; ///
enum GL_MATRIX5_NV = 0x8635; ///
enum GL_MATRIX6_ARB = 0x88C6; ///
enum GL_MATRIX6_NV = 0x8636; ///
enum GL_MATRIX7_ARB = 0x88C7; ///
enum GL_MATRIX7_NV = 0x8637; ///
enum GL_MATRIX8_ARB = 0x88C8; ///
enum GL_MATRIX9_ARB = 0x88C9; ///
enum GL_MATRIX_EXT = 0x87C0; ///
enum GL_MATRIX_INDEX_ARRAY_ARB = 0x8844; ///
enum GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES = 0x8B9E; ///
enum GL_MATRIX_INDEX_ARRAY_OES = 0x8844; ///
enum GL_MATRIX_INDEX_ARRAY_POINTER_ARB = 0x8849; ///
enum GL_MATRIX_INDEX_ARRAY_POINTER_OES = 0x8849; ///
enum GL_MATRIX_INDEX_ARRAY_SIZE_ARB = 0x8846; ///
enum GL_MATRIX_INDEX_ARRAY_SIZE_OES = 0x8846; ///
enum GL_MATRIX_INDEX_ARRAY_STRIDE_ARB = 0x8848; ///
enum GL_MATRIX_INDEX_ARRAY_STRIDE_OES = 0x8848; ///
enum GL_MATRIX_INDEX_ARRAY_TYPE_ARB = 0x8847; ///
enum GL_MATRIX_INDEX_ARRAY_TYPE_OES = 0x8847; ///
enum GL_MATRIX_MODE = 0x0BA0; ///
enum GL_MATRIX_PALETTE_ARB = 0x8840; ///
enum GL_MATRIX_PALETTE_OES = 0x8840; ///
enum GL_MATRIX_STRIDE = 0x92FF; ///
enum GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI = 0x00200000; ///
enum GL_MAT_AMBIENT_BIT_PGI = 0x00100000; ///
enum GL_MAT_COLOR_INDEXES_BIT_PGI = 0x01000000; ///
enum GL_MAT_DIFFUSE_BIT_PGI = 0x00400000; ///
enum GL_MAT_EMISSION_BIT_PGI = 0x00800000; ///
enum GL_MAT_SHININESS_BIT_PGI = 0x02000000; ///
enum GL_MAT_SPECULAR_BIT_PGI = 0x04000000; ///
enum GL_MAX = 0x8008; ///
enum GL_MAX_3D_TEXTURE_SIZE = 0x8073; ///
enum GL_MAX_3D_TEXTURE_SIZE_EXT = 0x8073; ///
enum GL_MAX_3D_TEXTURE_SIZE_OES = 0x8073; ///
enum GL_MAX_4D_TEXTURE_SIZE_SGIS = 0x8138; ///
enum GL_MAX_ACTIVE_LIGHTS_SGIX = 0x8405; ///
enum GL_MAX_ARRAY_TEXTURE_LAYERS = 0x88FF; ///
enum GL_MAX_ARRAY_TEXTURE_LAYERS_EXT = 0x88FF; ///
enum GL_MAX_ASYNC_DRAW_PIXELS_SGIX = 0x8360; ///
enum GL_MAX_ASYNC_HISTOGRAM_SGIX = 0x832D; ///
enum GL_MAX_ASYNC_READ_PIXELS_SGIX = 0x8361; ///
enum GL_MAX_ASYNC_TEX_IMAGE_SGIX = 0x835F; ///
enum GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC; ///
enum GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8; ///
enum GL_MAX_ATTRIB_STACK_DEPTH = 0x0D35; ///
enum GL_MAX_BINDABLE_UNIFORM_SIZE_EXT = 0x8DED; ///
enum GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B; ///
enum GL_MAX_CLIPMAP_DEPTH_SGIX = 0x8177; ///
enum GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8178; ///
enum GL_MAX_CLIP_DISTANCES = 0x0D32; ///
enum GL_MAX_CLIP_DISTANCES_APPLE = 0x0D32; ///
enum GL_MAX_CLIP_DISTANCES_EXT = 0x0D32; ///
enum GL_MAX_CLIP_PLANES = 0x0D32; ///
enum GL_MAX_CLIP_PLANES_IMG = 0x0D32; ///
enum GL_MAX_COLOR_ATTACHMENTS = 0x8CDF; ///
enum GL_MAX_COLOR_ATTACHMENTS_EXT = 0x8CDF; ///
enum GL_MAX_COLOR_ATTACHMENTS_NV = 0x8CDF; ///
enum GL_MAX_COLOR_MATRIX_STACK_DEPTH = 0x80B3; ///
enum GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B3; ///
enum GL_MAX_COLOR_TEXTURE_SAMPLES = 0x910E; ///
enum GL_MAX_COMBINED_ATOMIC_COUNTERS = 0x92D7; ///
enum GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1; ///
enum GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = 0x82FA; ///
enum GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT = 0x82FA; ///
enum GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266; ///
enum GL_MAX_COMBINED_DIMENSIONS = 0x8282; ///
enum GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x8A32; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x8A32; ///
enum GL_MAX_COMBINED_IMAGE_UNIFORMS = 0x90CF; ///
enum GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39; ///
enum GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT = 0x8F39; ///
enum GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39; ///
enum GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x8E1F; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x8E1F; ///
enum GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D; ///
enum GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB = 0x8B4D; ///
enum GL_MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E; ///
enum GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31; ///
enum GL_MAX_COMPUTE_ATOMIC_COUNTERS = 0x8265; ///
enum GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264; ///
enum GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB = 0x90EB; ///
enum GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB = 0x91BF; ///
enum GL_MAX_COMPUTE_IMAGE_UNIFORMS = 0x91BD; ///
enum GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB; ///
enum GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = 0x8262; ///
enum GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = 0x91BC; ///
enum GL_MAX_COMPUTE_UNIFORM_BLOCKS = 0x91BB; ///
enum GL_MAX_COMPUTE_UNIFORM_COMPONENTS = 0x8263; ///
enum GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB = 0x9344; ///
enum GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB = 0x9345; ///
enum GL_MAX_COMPUTE_WORK_GROUP_COUNT = 0x91BE; ///
enum GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = 0x90EB; ///
enum GL_MAX_COMPUTE_WORK_GROUP_SIZE = 0x91BF; ///
enum GL_MAX_CONVOLUTION_HEIGHT = 0x801B; ///
enum GL_MAX_CONVOLUTION_HEIGHT_EXT = 0x801B; ///
enum GL_MAX_CONVOLUTION_WIDTH = 0x801A; ///
enum GL_MAX_CONVOLUTION_WIDTH_EXT = 0x801A; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_OES = 0x851C; ///
enum GL_MAX_CULL_DISTANCES = 0x82F9; ///
enum GL_MAX_CULL_DISTANCES_EXT = 0x82F9; ///
enum GL_MAX_DEBUG_GROUP_STACK_DEPTH = 0x826C; ///
enum GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR = 0x826C; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_AMD = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_ARB = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_KHR = 0x9144; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_AMD = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_ARB = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_KHR = 0x9143; ///
enum GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV = 0x90D1; ///
enum GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV = 0x90D0; ///
enum GL_MAX_DEFORMATION_ORDER_SGIX = 0x8197; ///
enum GL_MAX_DEPTH = 0x8280; ///
enum GL_MAX_DEPTH_TEXTURE_SAMPLES = 0x910F; ///
enum GL_MAX_DRAW_BUFFERS = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_ARB = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_ATI = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_EXT = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_NV = 0x8824; ///
enum GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = 0x88FC; ///
enum GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT = 0x88FC; ///
enum GL_MAX_ELEMENTS_INDICES = 0x80E9; ///
enum GL_MAX_ELEMENTS_INDICES_EXT = 0x80E9; ///
enum GL_MAX_ELEMENTS_VERTICES = 0x80E8; ///
enum GL_MAX_ELEMENTS_VERTICES_EXT = 0x80E8; ///
enum GL_MAX_ELEMENT_INDEX = 0x8D6B; ///
enum GL_MAX_EVAL_ORDER = 0x0D30; ///
enum GL_MAX_EXT = 0x8008; ///
enum GL_MAX_FOG_FUNC_POINTS_SGIS = 0x812C; ///
enum GL_MAX_FRAGMENT_ATOMIC_COUNTERS = 0x92D6; ///
enum GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0; ///
enum GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT = 0x8DE3; ///
enum GL_MAX_FRAGMENT_IMAGE_UNIFORMS = 0x90CE; ///
enum GL_MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV = 0x8E5C; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5C; ///
enum GL_MAX_FRAGMENT_LIGHTS_SGIX = 0x8404; ///
enum GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV = 0x8868; ///
enum GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA; ///
enum GL_MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D; ///
enum GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49; ///
enum GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB = 0x8B49; ///
enum GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD; ///
enum GL_MAX_FRAMEBUFFER_HEIGHT = 0x9316; ///
enum GL_MAX_FRAMEBUFFER_LAYERS = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_LAYERS_EXT = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_LAYERS_OES = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_SAMPLES = 0x9318; ///
enum GL_MAX_FRAMEBUFFER_WIDTH = 0x9315; ///
enum GL_MAX_FRAMEZOOM_FACTOR_SGIX = 0x818D; ///
enum GL_MAX_GENERAL_COMBINERS_NV = 0x854D; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CF; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES = 0x92CF; ///
enum GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT = 0x8DE4; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS = 0x90CD; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT = 0x90CD; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES = 0x90CD; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS = 0x9123; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT = 0x9123; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES = 0x9123; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES = 0x8DE0; ///
enum GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT = 0x90D7; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES = 0x90D7; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES = 0x8C29; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES = 0x8DE1; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x8DDF; ///
enum GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB = 0x8DDD; ///
enum GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT = 0x8DDD; ///
enum GL_MAX_HEIGHT = 0x827F; ///
enum GL_MAX_IMAGE_SAMPLES = 0x906D; ///
enum GL_MAX_IMAGE_SAMPLES_EXT = 0x906D; ///
enum GL_MAX_IMAGE_UNITS = 0x8F38; ///
enum GL_MAX_IMAGE_UNITS_EXT = 0x8F38; ///
enum GL_MAX_INTEGER_SAMPLES = 0x9110; ///
enum GL_MAX_LABEL_LENGTH = 0x82E8; ///
enum GL_MAX_LABEL_LENGTH_KHR = 0x82E8; ///
enum GL_MAX_LAYERS = 0x8281; ///
enum GL_MAX_LIGHTS = 0x0D31; ///
enum GL_MAX_LIST_NESTING = 0x0B31; ///
enum GL_MAX_MAP_TESSELLATION_NV = 0x86D6; ///
enum GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB = 0x8841; ///
enum GL_MAX_MODELVIEW_STACK_DEPTH = 0x0D36; ///
enum GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV = 0x8E11; ///
enum GL_MAX_MULTIVIEW_BUFFERS_EXT = 0x90F2; ///
enum GL_MAX_NAME_LENGTH = 0x92F6; ///
enum GL_MAX_NAME_STACK_DEPTH = 0x0D37; ///
enum GL_MAX_NUM_ACTIVE_VARIABLES = 0x92F7; ///
enum GL_MAX_NUM_COMPATIBLE_SUBROUTINES = 0x92F8; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87CA; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT = 0x87CD; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT = 0x87CE; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87CC; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT = 0x87CB; ///
enum GL_MAX_PALETTE_MATRICES_ARB = 0x8842; ///
enum GL_MAX_PALETTE_MATRICES_OES = 0x8842; ///
enum GL_MAX_PATCH_VERTICES = 0x8E7D; ///
enum GL_MAX_PATCH_VERTICES_EXT = 0x8E7D; ///
enum GL_MAX_PATCH_VERTICES_OES = 0x8E7D; ///
enum GL_MAX_PIXEL_MAP_TABLE = 0x0D34; ///
enum GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 0x8337; ///
enum GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 0x87F1; ///
enum GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB = 0x88B1; ///
enum GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB = 0x880B; ///
enum GL_MAX_PROGRAM_ATTRIBS_ARB = 0x88AD; ///
enum GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV = 0x8908; ///
enum GL_MAX_PROGRAM_CALL_DEPTH_NV = 0x88F5; ///
enum GL_MAX_PROGRAM_ENV_PARAMETERS_ARB = 0x88B5; ///
enum GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV = 0x88F4; ///
enum GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV = 0x8DA5; ///
enum GL_MAX_PROGRAM_GENERIC_RESULTS_NV = 0x8DA6; ///
enum GL_MAX_PROGRAM_IF_DEPTH_NV = 0x88F6; ///
enum GL_MAX_PROGRAM_INSTRUCTIONS_ARB = 0x88A1; ///
enum GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB = 0x88B4; ///
enum GL_MAX_PROGRAM_LOOP_COUNT_NV = 0x88F8; ///
enum GL_MAX_PROGRAM_LOOP_DEPTH_NV = 0x88F7; ///
enum GL_MAX_PROGRAM_MATRICES_ARB = 0x862F; ///
enum GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB = 0x862E; ///
enum GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 0x88B3; ///
enum GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 0x880E; ///
enum GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB = 0x88AF; ///
enum GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 0x88A3; ///
enum GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB = 0x88AB; ///
enum GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB = 0x88A7; ///
enum GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 0x8810; ///
enum GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 0x880F; ///
enum GL_MAX_PROGRAM_OUTPUT_VERTICES_NV = 0x8C27; ///
enum GL_MAX_PROGRAM_PARAMETERS_ARB = 0x88A9; ///
enum GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV = 0x8DA0; ///
enum GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV = 0x8DA1; ///
enum GL_MAX_PROGRAM_PATCH_ATTRIBS_NV = 0x86D8; ///
enum GL_MAX_PROGRAM_RESULT_COMPONENTS_NV = 0x8909; ///
enum GL_MAX_PROGRAM_SUBROUTINE_NUM_NV = 0x8F45; ///
enum GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV = 0x8F44; ///
enum GL_MAX_PROGRAM_TEMPORARIES_ARB = 0x88A5; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET = 0x8905; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET_EXT = 0x8905; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET_NV = 0x8905; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB = 0x8F9F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB = 0x880D; ///
enum GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB = 0x880C; ///
enum GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV = 0x8C28; ///
enum GL_MAX_PROJECTION_STACK_DEPTH = 0x0D38; ///
enum GL_MAX_RASTER_SAMPLES_EXT = 0x9329; ///
enum GL_MAX_RATIONAL_EVAL_ORDER_NV = 0x86D7; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE = 0x84F8; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB = 0x84F8; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE_NV = 0x84F8; ///
enum GL_MAX_RENDERBUFFER_SIZE = 0x84E8; ///
enum GL_MAX_RENDERBUFFER_SIZE_EXT = 0x84E8; ///
enum GL_MAX_RENDERBUFFER_SIZE_OES = 0x84E8; ///
enum GL_MAX_SAMPLES = 0x8D57; ///
enum GL_MAX_SAMPLES_ANGLE = 0x8D57; ///
enum GL_MAX_SAMPLES_APPLE = 0x8D57; ///
enum GL_MAX_SAMPLES_EXT = 0x8D57; ///
enum GL_MAX_SAMPLES_IMG = 0x9135; ///
enum GL_MAX_SAMPLES_NV = 0x8D57; ///
enum GL_MAX_SAMPLE_MASK_WORDS = 0x8E59; ///
enum GL_MAX_SAMPLE_MASK_WORDS_NV = 0x8E59; ///
enum GL_MAX_SERVER_WAIT_TIMEOUT = 0x9111; ///
enum GL_MAX_SERVER_WAIT_TIMEOUT_APPLE = 0x9111; ///
enum GL_MAX_SHADER_BUFFER_ADDRESS_NV = 0x8F35; ///
enum GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_FAST_SIZE_EXT = 0x9650; ///
enum GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_SIZE_EXT = 0x9651; ///
enum GL_MAX_SHADER_COMPILER_THREADS_ARB = 0x91B0; ///
enum GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT = 0x8F63; ///
enum GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT = 0x8F67; ///
enum GL_MAX_SHADER_STORAGE_BLOCK_SIZE = 0x90DE; ///
enum GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD; ///
enum GL_MAX_SHININESS_NV = 0x8504; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD = 0x9199; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB = 0x9199; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT = 0x9199; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS = 0x919A; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB = 0x919A; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT = 0x919A; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_AMD = 0x9198; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_ARB = 0x9198; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_EXT = 0x9198; ///
enum GL_MAX_SPOT_EXPONENT_NV = 0x8505; ///
enum GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV = 0x9349; ///
enum GL_MAX_SUBROUTINES = 0x8DE7; ///
enum GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT = 0x886C; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES = 0x886C; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x8E7F; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x8E7F; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x8E80; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x8E80; ///
enum GL_MAX_TESS_GEN_LEVEL = 0x8E7E; ///
enum GL_MAX_TESS_GEN_LEVEL_EXT = 0x8E7E; ///
enum GL_MAX_TESS_GEN_LEVEL_OES = 0x8E7E; ///
enum GL_MAX_TESS_PATCH_COMPONENTS = 0x8E84; ///
enum GL_MAX_TESS_PATCH_COMPONENTS_EXT = 0x8E84; ///
enum GL_MAX_TESS_PATCH_COMPONENTS_OES = 0x8E84; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_ARB = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_EXT = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_OES = 0x8C2B; ///
enum GL_MAX_TEXTURE_COORDS = 0x8871; ///
enum GL_MAX_TEXTURE_COORDS_ARB = 0x8871; ///
enum GL_MAX_TEXTURE_COORDS_NV = 0x8871; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS_ARB = 0x8872; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS_NV = 0x8872; ///
enum GL_MAX_TEXTURE_LOD_BIAS = 0x84FD; ///
enum GL_MAX_TEXTURE_LOD_BIAS_EXT = 0x84FD; ///
enum GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF; ///
enum GL_MAX_TEXTURE_SIZE = 0x0D33; ///
enum GL_MAX_TEXTURE_STACK_DEPTH = 0x0D39; ///
enum GL_MAX_TEXTURE_UNITS = 0x84E2; ///
enum GL_MAX_TEXTURE_UNITS_ARB = 0x84E2; ///
enum GL_MAX_TRACK_MATRICES_NV = 0x862F; ///
enum GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV = 0x862E; ///
enum GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT = 0x8C80; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV = 0x8C80; ///
enum GL_MAX_UNIFORM_BLOCK_SIZE = 0x8A30; ///
enum GL_MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F; ///
enum GL_MAX_UNIFORM_LOCATIONS = 0x826E; ///
enum GL_MAX_VARYING_COMPONENTS = 0x8B4B; ///
enum GL_MAX_VARYING_COMPONENTS_EXT = 0x8B4B; ///
enum GL_MAX_VARYING_FLOATS = 0x8B4B; ///
enum GL_MAX_VARYING_FLOATS_ARB = 0x8B4B; ///
enum GL_MAX_VARYING_VECTORS = 0x8DFC; ///
enum GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV = 0x8520; ///
enum GL_MAX_VERTEX_ATOMIC_COUNTERS = 0x92D2; ///
enum GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC; ///
enum GL_MAX_VERTEX_ATTRIBS = 0x8869; ///
enum GL_MAX_VERTEX_ATTRIBS_ARB = 0x8869; ///
enum GL_MAX_VERTEX_ATTRIB_BINDINGS = 0x82DA; ///
enum GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D9; ///
enum GL_MAX_VERTEX_ATTRIB_STRIDE = 0x82E5; ///
enum GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT = 0x8DE2; ///
enum GL_MAX_VERTEX_HINT_PGI = 0x1A22D; ///
enum GL_MAX_VERTEX_IMAGE_UNIFORMS = 0x90CA; ///
enum GL_MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122; ///
enum GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87C5; ///
enum GL_MAX_VERTEX_SHADER_INVARIANTS_EXT = 0x87C7; ///
enum GL_MAX_VERTEX_SHADER_LOCALS_EXT = 0x87C9; ///
enum GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87C8; ///
enum GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6; ///
enum GL_MAX_VERTEX_SHADER_VARIANTS_EXT = 0x87C6; ///
enum GL_MAX_VERTEX_STREAMS = 0x8E71; ///
enum GL_MAX_VERTEX_STREAMS_ATI = 0x876B; ///
enum GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C; ///
enum GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB = 0x8B4C; ///
enum GL_MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B; ///
enum GL_MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A; ///
enum GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB = 0x8B4A; ///
enum GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB; ///
enum GL_MAX_VERTEX_UNITS_ARB = 0x86A4; ///
enum GL_MAX_VERTEX_UNITS_OES = 0x86A4; ///
enum GL_MAX_VERTEX_VARYING_COMPONENTS_ARB = 0x8DDE; ///
enum GL_MAX_VERTEX_VARYING_COMPONENTS_EXT = 0x8DDE; ///
enum GL_MAX_VIEWPORTS = 0x825B; ///
enum GL_MAX_VIEWPORTS_NV = 0x825B; ///
enum GL_MAX_VIEWPORTS_OES = 0x825B; ///
enum GL_MAX_VIEWPORT_DIMS = 0x0D3A; ///
enum GL_MAX_VIEWS_OVR = 0x9631; ///
enum GL_MAX_WIDTH = 0x827E; ///
enum GL_MAX_WINDOW_RECTANGLES_EXT = 0x8F14; ///
enum GL_MEDIUM_FLOAT = 0x8DF1; ///
enum GL_MEDIUM_INT = 0x8DF4; ///
enum GL_MIN = 0x8007; ///
enum GL_MINMAX = 0x802E; ///
enum GL_MINMAX_EXT = 0x802E; ///
enum GL_MINMAX_FORMAT = 0x802F; ///
enum GL_MINMAX_FORMAT_EXT = 0x802F; ///
enum GL_MINMAX_SINK = 0x8030; ///
enum GL_MINMAX_SINK_EXT = 0x8030; ///
enum GL_MINOR_VERSION = 0x821C; ///
enum GL_MINUS_CLAMPED_NV = 0x92B3; ///
enum GL_MINUS_NV = 0x929F; ///
enum GL_MIN_EXT = 0x8007; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV = 0x8E5B; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5B; ///
enum GL_MIN_LOD_WARNING_AMD = 0x919C; ///
enum GL_MIN_MAP_BUFFER_ALIGNMENT = 0x90BC; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET = 0x8904; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET_EXT = 0x8904; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET_NV = 0x8904; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5E; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV = 0x8E5E; ///
enum GL_MIN_SAMPLE_SHADING_VALUE = 0x8C37; ///
enum GL_MIN_SAMPLE_SHADING_VALUE_ARB = 0x8C37; ///
enum GL_MIN_SAMPLE_SHADING_VALUE_OES = 0x8C37; ///
enum GL_MIN_SPARSE_LEVEL_AMD = 0x919B; ///
enum GL_MIPMAP = 0x8293; ///
enum GL_MIRRORED_REPEAT = 0x8370; ///
enum GL_MIRRORED_REPEAT_ARB = 0x8370; ///
enum GL_MIRRORED_REPEAT_IBM = 0x8370; ///
enum GL_MIRRORED_REPEAT_OES = 0x8370; ///
enum GL_MIRROR_CLAMP_ATI = 0x8742; ///
enum GL_MIRROR_CLAMP_EXT = 0x8742; ///
enum GL_MIRROR_CLAMP_TO_BORDER_EXT = 0x8912; ///
enum GL_MIRROR_CLAMP_TO_EDGE = 0x8743; ///
enum GL_MIRROR_CLAMP_TO_EDGE_ATI = 0x8743; ///
enum GL_MIRROR_CLAMP_TO_EDGE_EXT = 0x8743; ///
enum GL_MITER_REVERT_NV = 0x90A7; ///
enum GL_MITER_TRUNCATE_NV = 0x90A8; ///
enum GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV = 0x932F; ///
enum GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV = 0x9330; ///
enum GL_MODELVIEW = 0x1700; ///
enum GL_MODELVIEW0_ARB = 0x1700; ///
enum GL_MODELVIEW0_EXT = 0x1700; ///
enum GL_MODELVIEW0_MATRIX_EXT = 0x0BA6; ///
enum GL_MODELVIEW0_STACK_DEPTH_EXT = 0x0BA3; ///
enum GL_MODELVIEW10_ARB = 0x872A; ///
enum GL_MODELVIEW11_ARB = 0x872B; ///
enum GL_MODELVIEW12_ARB = 0x872C; ///
enum GL_MODELVIEW13_ARB = 0x872D; ///
enum GL_MODELVIEW14_ARB = 0x872E; ///
enum GL_MODELVIEW15_ARB = 0x872F; ///
enum GL_MODELVIEW16_ARB = 0x8730; ///
enum GL_MODELVIEW17_ARB = 0x8731; ///
enum GL_MODELVIEW18_ARB = 0x8732; ///
enum GL_MODELVIEW19_ARB = 0x8733; ///
enum GL_MODELVIEW1_ARB = 0x850A; ///
enum GL_MODELVIEW1_EXT = 0x850A; ///
enum GL_MODELVIEW1_MATRIX_EXT = 0x8506; ///
enum GL_MODELVIEW1_STACK_DEPTH_EXT = 0x8502; ///
enum GL_MODELVIEW20_ARB = 0x8734; ///
enum GL_MODELVIEW21_ARB = 0x8735; ///
enum GL_MODELVIEW22_ARB = 0x8736; ///
enum GL_MODELVIEW23_ARB = 0x8737; ///
enum GL_MODELVIEW24_ARB = 0x8738; ///
enum GL_MODELVIEW25_ARB = 0x8739; ///
enum GL_MODELVIEW26_ARB = 0x873A; ///
enum GL_MODELVIEW27_ARB = 0x873B; ///
enum GL_MODELVIEW28_ARB = 0x873C; ///
enum GL_MODELVIEW29_ARB = 0x873D; ///
enum GL_MODELVIEW2_ARB = 0x8722; ///
enum GL_MODELVIEW30_ARB = 0x873E; ///
enum GL_MODELVIEW31_ARB = 0x873F; ///
enum GL_MODELVIEW3_ARB = 0x8723; ///
enum GL_MODELVIEW4_ARB = 0x8724; ///
enum GL_MODELVIEW5_ARB = 0x8725; ///
enum GL_MODELVIEW6_ARB = 0x8726; ///
enum GL_MODELVIEW7_ARB = 0x8727; ///
enum GL_MODELVIEW8_ARB = 0x8728; ///
enum GL_MODELVIEW9_ARB = 0x8729; ///
enum GL_MODELVIEW_MATRIX = 0x0BA6; ///
enum GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898D; ///
enum GL_MODELVIEW_PROJECTION_NV = 0x8629; ///
enum GL_MODELVIEW_STACK_DEPTH = 0x0BA3; ///
enum GL_MODULATE = 0x2100; ///
enum GL_MODULATE_ADD_ATI = 0x8744; ///
enum GL_MODULATE_COLOR_IMG = 0x8C04; ///
enum GL_MODULATE_SIGNED_ADD_ATI = 0x8745; ///
enum GL_MODULATE_SUBTRACT_ATI = 0x8746; ///
enum GL_MOVE_TO_CONTINUES_NV = 0x90B6; ///
enum GL_MOVE_TO_NV = 0x02; ///
enum GL_MOVE_TO_RESETS_NV = 0x90B5; ///
enum GL_MOV_ATI = 0x8961; ///
enum GL_MULT = 0x0103; ///
enum GL_MULTIPLY = 0x9294; ///
enum GL_MULTIPLY_KHR = 0x9294; ///
enum GL_MULTIPLY_NV = 0x9294; ///
enum GL_MULTISAMPLE = 0x809D; ///
enum GL_MULTISAMPLES_NV = 0x9371; ///
enum GL_MULTISAMPLE_3DFX = 0x86B2; ///
enum GL_MULTISAMPLE_ARB = 0x809D; ///
enum GL_MULTISAMPLE_BIT = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_3DFX = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_ARB = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_EXT = 0x20000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT0_QCOM = 0x01000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT1_QCOM = 0x02000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT2_QCOM = 0x04000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT3_QCOM = 0x08000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT4_QCOM = 0x10000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT5_QCOM = 0x20000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT6_QCOM = 0x40000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT7_QCOM = 0x80000000; ///
enum GL_MULTISAMPLE_COVERAGE_MODES_NV = 0x8E12; ///
enum GL_MULTISAMPLE_EXT = 0x809D; ///
enum GL_MULTISAMPLE_FILTER_HINT_NV = 0x8534; ///
enum GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY = 0x9382; ///
enum GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB = 0x9382; ///
enum GL_MULTISAMPLE_LINE_WIDTH_RANGE = 0x9381; ///
enum GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB = 0x9381; ///
enum GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT = 0x932B; ///
enum GL_MULTISAMPLE_SGIS = 0x809D; ///
enum GL_MULTIVIEW_EXT = 0x90F1; ///
enum GL_MUL_ATI = 0x8964; ///
enum GL_MVP_MATRIX_EXT = 0x87E3; ///
enum GL_N3F_V3F = 0x2A25; ///
enum GL_NAMED_STRING_LENGTH_ARB = 0x8DE9; ///
enum GL_NAMED_STRING_TYPE_ARB = 0x8DEA; ///
enum GL_NAME_LENGTH = 0x92F9; ///
enum GL_NAME_STACK_DEPTH = 0x0D70; ///
enum GL_NAND = 0x150E; ///
enum GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI = 0x1A203; ///
enum GL_NATIVE_GRAPHICS_END_HINT_PGI = 0x1A204; ///
enum GL_NATIVE_GRAPHICS_HANDLE_PGI = 0x1A202; ///
enum GL_NEAREST = 0x2600; ///
enum GL_NEAREST_CLIPMAP_LINEAR_SGIX = 0x844E; ///
enum GL_NEAREST_CLIPMAP_NEAREST_SGIX = 0x844D; ///
enum GL_NEAREST_MIPMAP_LINEAR = 0x2702; ///
enum GL_NEAREST_MIPMAP_NEAREST = 0x2700; ///
enum GL_NEGATE_BIT_ATI = 0x00000004; ///
enum GL_NEGATIVE_ONE_EXT = 0x87DF; ///
enum GL_NEGATIVE_ONE_TO_ONE = 0x935E; ///
enum GL_NEGATIVE_W_EXT = 0x87DC; ///
enum GL_NEGATIVE_X_EXT = 0x87D9; ///
enum GL_NEGATIVE_Y_EXT = 0x87DA; ///
enum GL_NEGATIVE_Z_EXT = 0x87DB; ///
enum GL_NEVER = 0x0200; ///
enum GL_NEXT_BUFFER_NV = -2; ///
enum GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV = 0x9025; ///
enum GL_NICEST = 0x1102; ///
enum GL_NONE = 0; ///
enum GL_NONE_OES = 0; ///
enum GL_NOOP = 0x1505; ///
enum GL_NOP_COMMAND_NV = 0x0001; ///
enum GL_NOR = 0x1508; ///
enum GL_NORMALIZE = 0x0BA1; ///
enum GL_NORMALIZED_RANGE_EXT = 0x87E0; ///
enum GL_NORMAL_ARRAY = 0x8075; ///
enum GL_NORMAL_ARRAY_ADDRESS_NV = 0x8F22; ///
enum GL_NORMAL_ARRAY_BUFFER_BINDING = 0x8897; ///
enum GL_NORMAL_ARRAY_BUFFER_BINDING_ARB = 0x8897; ///
enum GL_NORMAL_ARRAY_COUNT_EXT = 0x8080; ///
enum GL_NORMAL_ARRAY_EXT = 0x8075; ///
enum GL_NORMAL_ARRAY_LENGTH_NV = 0x8F2C; ///
enum GL_NORMAL_ARRAY_LIST_IBM = 0x103071; ///
enum GL_NORMAL_ARRAY_LIST_STRIDE_IBM = 0x103081; ///
enum GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F6; ///
enum GL_NORMAL_ARRAY_POINTER = 0x808F; ///
enum GL_NORMAL_ARRAY_POINTER_EXT = 0x808F; ///
enum GL_NORMAL_ARRAY_STRIDE = 0x807F; ///
enum GL_NORMAL_ARRAY_STRIDE_EXT = 0x807F; ///
enum GL_NORMAL_ARRAY_TYPE = 0x807E; ///
enum GL_NORMAL_ARRAY_TYPE_EXT = 0x807E; ///
enum GL_NORMAL_BIT_PGI = 0x08000000; ///
enum GL_NORMAL_MAP = 0x8511; ///
enum GL_NORMAL_MAP_ARB = 0x8511; ///
enum GL_NORMAL_MAP_EXT = 0x8511; ///
enum GL_NORMAL_MAP_NV = 0x8511; ///
enum GL_NORMAL_MAP_OES = 0x8511; ///
enum GL_NOTEQUAL = 0x0205; ///
enum GL_NO_ERROR = 0; ///
enum GL_NO_RESET_NOTIFICATION = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_ARB = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_EXT = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_KHR = 0x8261; ///
enum GL_NUM_ACTIVE_VARIABLES = 0x9304; ///
enum GL_NUM_COMPATIBLE_SUBROUTINES = 0x8E4A; ///
enum GL_NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2; ///
enum GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB = 0x86A2; ///
enum GL_NUM_DOWNSAMPLE_SCALES_IMG = 0x913D; ///
enum GL_NUM_EXTENSIONS = 0x821D; ///
enum GL_NUM_FILL_STREAMS_NV = 0x8E29; ///
enum GL_NUM_FRAGMENT_CONSTANTS_ATI = 0x896F; ///
enum GL_NUM_FRAGMENT_REGISTERS_ATI = 0x896E; ///
enum GL_NUM_GENERAL_COMBINERS_NV = 0x854E; ///
enum GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI = 0x8973; ///
enum GL_NUM_INSTRUCTIONS_PER_PASS_ATI = 0x8971; ///
enum GL_NUM_INSTRUCTIONS_TOTAL_ATI = 0x8972; ///
enum GL_NUM_LOOPBACK_COMPONENTS_ATI = 0x8974; ///
enum GL_NUM_PASSES_ATI = 0x8970; ///
enum GL_NUM_PROGRAM_BINARY_FORMATS = 0x87FE; ///
enum GL_NUM_PROGRAM_BINARY_FORMATS_OES = 0x87FE; ///
enum GL_NUM_SAMPLE_COUNTS = 0x9380; ///
enum GL_NUM_SHADER_BINARY_FORMATS = 0x8DF9; ///
enum GL_NUM_SHADING_LANGUAGE_VERSIONS = 0x82E9; ///
enum GL_NUM_SPARSE_LEVELS_ARB = 0x91AA; ///
enum GL_NUM_SPARSE_LEVELS_EXT = 0x91AA; ///
enum GL_NUM_VIDEO_CAPTURE_STREAMS_NV = 0x9024; ///
enum GL_NUM_VIRTUAL_PAGE_SIZES_ARB = 0x91A8; ///
enum GL_NUM_VIRTUAL_PAGE_SIZES_EXT = 0x91A8; ///
enum GL_NUM_WINDOW_RECTANGLES_EXT = 0x8F15; ///
enum GL_OBJECT_ACTIVE_ATTRIBUTES_ARB = 0x8B89; ///
enum GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB = 0x8B8A; ///
enum GL_OBJECT_ACTIVE_UNIFORMS_ARB = 0x8B86; ///
enum GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB = 0x8B87; ///
enum GL_OBJECT_ATTACHED_OBJECTS_ARB = 0x8B85; ///
enum GL_OBJECT_BUFFER_SIZE_ATI = 0x8764; ///
enum GL_OBJECT_BUFFER_USAGE_ATI = 0x8765; ///
enum GL_OBJECT_COMPILE_STATUS_ARB = 0x8B81; ///
enum GL_OBJECT_DELETE_STATUS_ARB = 0x8B80; ///
enum GL_OBJECT_DISTANCE_TO_LINE_SGIS = 0x81F3; ///
enum GL_OBJECT_DISTANCE_TO_POINT_SGIS = 0x81F1; ///
enum GL_OBJECT_INFO_LOG_LENGTH_ARB = 0x8B84; ///
enum GL_OBJECT_LINEAR = 0x2401; ///
enum GL_OBJECT_LINEAR_NV = 0x2401; ///
enum GL_OBJECT_LINE_SGIS = 0x81F7; ///
enum GL_OBJECT_LINK_STATUS_ARB = 0x8B82; ///
enum GL_OBJECT_PLANE = 0x2501; ///
enum GL_OBJECT_POINT_SGIS = 0x81F5; ///
enum GL_OBJECT_SHADER_SOURCE_LENGTH_ARB = 0x8B88; ///
enum GL_OBJECT_SUBTYPE_ARB = 0x8B4F; ///
enum GL_OBJECT_TYPE = 0x9112; ///
enum GL_OBJECT_TYPE_APPLE = 0x9112; ///
enum GL_OBJECT_TYPE_ARB = 0x8B4E; ///
enum GL_OBJECT_VALIDATE_STATUS_ARB = 0x8B83; ///
enum GL_OCCLUSION_QUERY_EVENT_MASK_AMD = 0x874F; ///
enum GL_OCCLUSION_TEST_HP = 0x8165; ///
enum GL_OCCLUSION_TEST_RESULT_HP = 0x8166; ///
enum GL_OFFSET = 0x92FC; ///
enum GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV = 0x8856; ///
enum GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV = 0x8857; ///
enum GL_OFFSET_HILO_TEXTURE_2D_NV = 0x8854; ///
enum GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV = 0x8855; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV = 0x8850; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV = 0x8851; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV = 0x8852; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV = 0x8853; ///
enum GL_OFFSET_TEXTURE_2D_BIAS_NV = 0x86E3; ///
enum GL_OFFSET_TEXTURE_2D_MATRIX_NV = 0x86E1; ///
enum GL_OFFSET_TEXTURE_2D_NV = 0x86E8; ///
enum GL_OFFSET_TEXTURE_2D_SCALE_NV = 0x86E2; ///
enum GL_OFFSET_TEXTURE_BIAS_NV = 0x86E3; ///
enum GL_OFFSET_TEXTURE_MATRIX_NV = 0x86E1; ///
enum GL_OFFSET_TEXTURE_RECTANGLE_NV = 0x864C; ///
enum GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV = 0x864D; ///
enum GL_OFFSET_TEXTURE_SCALE_NV = 0x86E2; ///
enum GL_ONE = 1; ///
enum GL_ONE_EXT = 0x87DE; ///
enum GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004; ///
enum GL_ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004; ///
enum GL_ONE_MINUS_CONSTANT_COLOR = 0x8002; ///
enum GL_ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002; ///
enum GL_ONE_MINUS_DST_ALPHA = 0x0305; ///
enum GL_ONE_MINUS_DST_COLOR = 0x0307; ///
enum GL_ONE_MINUS_SRC1_ALPHA = 0x88FB; ///
enum GL_ONE_MINUS_SRC1_ALPHA_EXT = 0x88FB; ///
enum GL_ONE_MINUS_SRC1_COLOR = 0x88FA; ///
enum GL_ONE_MINUS_SRC1_COLOR_EXT = 0x88FA; ///
enum GL_ONE_MINUS_SRC_ALPHA = 0x0303; ///
enum GL_ONE_MINUS_SRC_COLOR = 0x0301; ///
enum GL_OPERAND0_ALPHA = 0x8598; ///
enum GL_OPERAND0_ALPHA_ARB = 0x8598; ///
enum GL_OPERAND0_ALPHA_EXT = 0x8598; ///
enum GL_OPERAND0_RGB = 0x8590; ///
enum GL_OPERAND0_RGB_ARB = 0x8590; ///
enum GL_OPERAND0_RGB_EXT = 0x8590; ///
enum GL_OPERAND1_ALPHA = 0x8599; ///
enum GL_OPERAND1_ALPHA_ARB = 0x8599; ///
enum GL_OPERAND1_ALPHA_EXT = 0x8599; ///
enum GL_OPERAND1_RGB = 0x8591; ///
enum GL_OPERAND1_RGB_ARB = 0x8591; ///
enum GL_OPERAND1_RGB_EXT = 0x8591; ///
enum GL_OPERAND2_ALPHA = 0x859A; ///
enum GL_OPERAND2_ALPHA_ARB = 0x859A; ///
enum GL_OPERAND2_ALPHA_EXT = 0x859A; ///
enum GL_OPERAND2_RGB = 0x8592; ///
enum GL_OPERAND2_RGB_ARB = 0x8592; ///
enum GL_OPERAND2_RGB_EXT = 0x8592; ///
enum GL_OPERAND3_ALPHA_NV = 0x859B; ///
enum GL_OPERAND3_RGB_NV = 0x8593; ///
enum GL_OP_ADD_EXT = 0x8787; ///
enum GL_OP_CLAMP_EXT = 0x878E; ///
enum GL_OP_CROSS_PRODUCT_EXT = 0x8797; ///
enum GL_OP_DOT3_EXT = 0x8784; ///
enum GL_OP_DOT4_EXT = 0x8785; ///
enum GL_OP_EXP_BASE_2_EXT = 0x8791; ///
enum GL_OP_FLOOR_EXT = 0x878F; ///
enum GL_OP_FRAC_EXT = 0x8789; ///
enum GL_OP_INDEX_EXT = 0x8782; ///
enum GL_OP_LOG_BASE_2_EXT = 0x8792; ///
enum GL_OP_MADD_EXT = 0x8788; ///
enum GL_OP_MAX_EXT = 0x878A; ///
enum GL_OP_MIN_EXT = 0x878B; ///
enum GL_OP_MOV_EXT = 0x8799; ///
enum GL_OP_MULTIPLY_MATRIX_EXT = 0x8798; ///
enum GL_OP_MUL_EXT = 0x8786; ///
enum GL_OP_NEGATE_EXT = 0x8783; ///
enum GL_OP_POWER_EXT = 0x8793; ///
enum GL_OP_RECIP_EXT = 0x8794; ///
enum GL_OP_RECIP_SQRT_EXT = 0x8795; ///
enum GL_OP_ROUND_EXT = 0x8790; ///
enum GL_OP_SET_GE_EXT = 0x878C; ///
enum GL_OP_SET_LT_EXT = 0x878D; ///
enum GL_OP_SUB_EXT = 0x8796; ///
enum GL_OR = 0x1507; ///
enum GL_ORDER = 0x0A01; ///
enum GL_OR_INVERTED = 0x150D; ///
enum GL_OR_REVERSE = 0x150B; ///
enum GL_OUTPUT_COLOR0_EXT = 0x879B; ///
enum GL_OUTPUT_COLOR1_EXT = 0x879C; ///
enum GL_OUTPUT_FOG_EXT = 0x87BD; ///
enum GL_OUTPUT_TEXTURE_COORD0_EXT = 0x879D; ///
enum GL_OUTPUT_TEXTURE_COORD10_EXT = 0x87A7; ///
enum GL_OUTPUT_TEXTURE_COORD11_EXT = 0x87A8; ///
enum GL_OUTPUT_TEXTURE_COORD12_EXT = 0x87A9; ///
enum GL_OUTPUT_TEXTURE_COORD13_EXT = 0x87AA; ///
enum GL_OUTPUT_TEXTURE_COORD14_EXT = 0x87AB; ///
enum GL_OUTPUT_TEXTURE_COORD15_EXT = 0x87AC; ///
enum GL_OUTPUT_TEXTURE_COORD16_EXT = 0x87AD; ///
enum GL_OUTPUT_TEXTURE_COORD17_EXT = 0x87AE; ///
enum GL_OUTPUT_TEXTURE_COORD18_EXT = 0x87AF; ///
enum GL_OUTPUT_TEXTURE_COORD19_EXT = 0x87B0; ///
enum GL_OUTPUT_TEXTURE_COORD1_EXT = 0x879E; ///
enum GL_OUTPUT_TEXTURE_COORD20_EXT = 0x87B1; ///
enum GL_OUTPUT_TEXTURE_COORD21_EXT = 0x87B2; ///
enum GL_OUTPUT_TEXTURE_COORD22_EXT = 0x87B3; ///
enum GL_OUTPUT_TEXTURE_COORD23_EXT = 0x87B4; ///
enum GL_OUTPUT_TEXTURE_COORD24_EXT = 0x87B5; ///
enum GL_OUTPUT_TEXTURE_COORD25_EXT = 0x87B6; ///
enum GL_OUTPUT_TEXTURE_COORD26_EXT = 0x87B7; ///
enum GL_OUTPUT_TEXTURE_COORD27_EXT = 0x87B8; ///
enum GL_OUTPUT_TEXTURE_COORD28_EXT = 0x87B9; ///
enum GL_OUTPUT_TEXTURE_COORD29_EXT = 0x87BA; ///
enum GL_OUTPUT_TEXTURE_COORD2_EXT = 0x879F; ///
enum GL_OUTPUT_TEXTURE_COORD30_EXT = 0x87BB; ///
enum GL_OUTPUT_TEXTURE_COORD31_EXT = 0x87BC; ///
enum GL_OUTPUT_TEXTURE_COORD3_EXT = 0x87A0; ///
enum GL_OUTPUT_TEXTURE_COORD4_EXT = 0x87A1; ///
enum GL_OUTPUT_TEXTURE_COORD5_EXT = 0x87A2; ///
enum GL_OUTPUT_TEXTURE_COORD6_EXT = 0x87A3; ///
enum GL_OUTPUT_TEXTURE_COORD7_EXT = 0x87A4; ///
enum GL_OUTPUT_TEXTURE_COORD8_EXT = 0x87A5; ///
enum GL_OUTPUT_TEXTURE_COORD9_EXT = 0x87A6; ///
enum GL_OUTPUT_VERTEX_EXT = 0x879A; ///
enum GL_OUT_OF_MEMORY = 0x0505; ///
enum GL_OVERLAY = 0x9296; ///
enum GL_OVERLAY_KHR = 0x9296; ///
enum GL_OVERLAY_NV = 0x9296; ///
enum GL_PACK_ALIGNMENT = 0x0D05; ///
enum GL_PACK_CMYK_HINT_EXT = 0x800E; ///
enum GL_PACK_COMPRESSED_BLOCK_DEPTH = 0x912D; ///
enum GL_PACK_COMPRESSED_BLOCK_HEIGHT = 0x912C; ///
enum GL_PACK_COMPRESSED_BLOCK_SIZE = 0x912E; ///
enum GL_PACK_COMPRESSED_BLOCK_WIDTH = 0x912B; ///
enum GL_PACK_COMPRESSED_SIZE_SGIX = 0x831C; ///
enum GL_PACK_IMAGE_DEPTH_SGIS = 0x8131; ///
enum GL_PACK_IMAGE_HEIGHT = 0x806C; ///
enum GL_PACK_IMAGE_HEIGHT_EXT = 0x806C; ///
enum GL_PACK_INVERT_MESA = 0x8758; ///
enum GL_PACK_LSB_FIRST = 0x0D01; ///
enum GL_PACK_MAX_COMPRESSED_SIZE_SGIX = 0x831B; ///
enum GL_PACK_RESAMPLE_OML = 0x8984; ///
enum GL_PACK_RESAMPLE_SGIX = 0x842E; ///
enum GL_PACK_REVERSE_ROW_ORDER_ANGLE = 0x93A4; ///
enum GL_PACK_ROW_BYTES_APPLE = 0x8A15; ///
enum GL_PACK_ROW_LENGTH = 0x0D02; ///
enum GL_PACK_SKIP_IMAGES = 0x806B; ///
enum GL_PACK_SKIP_IMAGES_EXT = 0x806B; ///
enum GL_PACK_SKIP_PIXELS = 0x0D04; ///
enum GL_PACK_SKIP_ROWS = 0x0D03; ///
enum GL_PACK_SKIP_VOLUMES_SGIS = 0x8130; ///
enum GL_PACK_SUBSAMPLE_RATE_SGIX = 0x85A0; ///
enum GL_PACK_SWAP_BYTES = 0x0D00; ///
enum GL_PALETTE4_R5_G6_B5_OES = 0x8B92; ///
enum GL_PALETTE4_RGB5_A1_OES = 0x8B94; ///
enum GL_PALETTE4_RGB8_OES = 0x8B90; ///
enum GL_PALETTE4_RGBA4_OES = 0x8B93; ///
enum GL_PALETTE4_RGBA8_OES = 0x8B91; ///
enum GL_PALETTE8_R5_G6_B5_OES = 0x8B97; ///
enum GL_PALETTE8_RGB5_A1_OES = 0x8B99; ///
enum GL_PALETTE8_RGB8_OES = 0x8B95; ///
enum GL_PALETTE8_RGBA4_OES = 0x8B98; ///
enum GL_PALETTE8_RGBA8_OES = 0x8B96; ///
enum GL_PARALLEL_ARRAYS_INTEL = 0x83F4; ///
enum GL_PARAMETER_BUFFER_ARB = 0x80EE; ///
enum GL_PARAMETER_BUFFER_BINDING_ARB = 0x80EF; ///
enum GL_PARTIAL_SUCCESS_NV = 0x902E; ///
enum GL_PASS_THROUGH_NV = 0x86E6; ///
enum GL_PASS_THROUGH_TOKEN = 0x0700; ///
enum GL_PATCHES = 0x000E; ///
enum GL_PATCHES_EXT = 0x000E; ///
enum GL_PATCHES_OES = 0x000E; ///
enum GL_PATCH_DEFAULT_INNER_LEVEL = 0x8E73; ///
enum GL_PATCH_DEFAULT_INNER_LEVEL_EXT = 0x8E73; ///
enum GL_PATCH_DEFAULT_OUTER_LEVEL = 0x8E74; ///
enum GL_PATCH_DEFAULT_OUTER_LEVEL_EXT = 0x8E74; ///
enum GL_PATCH_VERTICES = 0x8E72; ///
enum GL_PATCH_VERTICES_EXT = 0x8E72; ///
enum GL_PATCH_VERTICES_OES = 0x8E72; ///
enum GL_PATH_CLIENT_LENGTH_NV = 0x907F; ///
enum GL_PATH_COMMAND_COUNT_NV = 0x909D; ///
enum GL_PATH_COMPUTED_LENGTH_NV = 0x90A0; ///
enum GL_PATH_COORD_COUNT_NV = 0x909E; ///
enum GL_PATH_COVER_DEPTH_FUNC_NV = 0x90BF; ///
enum GL_PATH_DASH_ARRAY_COUNT_NV = 0x909F; ///
enum GL_PATH_DASH_CAPS_NV = 0x907B; ///
enum GL_PATH_DASH_OFFSET_NV = 0x907E; ///
enum GL_PATH_DASH_OFFSET_RESET_NV = 0x90B4; ///
enum GL_PATH_END_CAPS_NV = 0x9076; ///
enum GL_PATH_ERROR_POSITION_NV = 0x90AB; ///
enum GL_PATH_FILL_BOUNDING_BOX_NV = 0x90A1; ///
enum GL_PATH_FILL_COVER_MODE_NV = 0x9082; ///
enum GL_PATH_FILL_MASK_NV = 0x9081; ///
enum GL_PATH_FILL_MODE_NV = 0x9080; ///
enum GL_PATH_FOG_GEN_MODE_NV = 0x90AC; ///
enum GL_PATH_FORMAT_PS_NV = 0x9071; ///
enum GL_PATH_FORMAT_SVG_NV = 0x9070; ///
enum GL_PATH_GEN_COEFF_NV = 0x90B1; ///
enum GL_PATH_GEN_COLOR_FORMAT_NV = 0x90B2; ///
enum GL_PATH_GEN_COMPONENTS_NV = 0x90B3; ///
enum GL_PATH_GEN_MODE_NV = 0x90B0; ///
enum GL_PATH_INITIAL_DASH_CAP_NV = 0x907C; ///
enum GL_PATH_INITIAL_END_CAP_NV = 0x9077; ///
enum GL_PATH_JOIN_STYLE_NV = 0x9079; ///
enum GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV = 0x0D36; ///
enum GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV = 0x0D38; ///
enum GL_PATH_MITER_LIMIT_NV = 0x907A; ///
enum GL_PATH_MODELVIEW_MATRIX_NV = 0x0BA6; ///
enum GL_PATH_MODELVIEW_NV = 0x1700; ///
enum GL_PATH_MODELVIEW_STACK_DEPTH_NV = 0x0BA3; ///
enum GL_PATH_OBJECT_BOUNDING_BOX_NV = 0x908A; ///
enum GL_PATH_PROJECTION_MATRIX_NV = 0x0BA7; ///
enum GL_PATH_PROJECTION_NV = 0x1701; ///
enum GL_PATH_PROJECTION_STACK_DEPTH_NV = 0x0BA4; ///
enum GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV = 0x90BD; ///
enum GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV = 0x90BE; ///
enum GL_PATH_STENCIL_FUNC_NV = 0x90B7; ///
enum GL_PATH_STENCIL_REF_NV = 0x90B8; ///
enum GL_PATH_STENCIL_VALUE_MASK_NV = 0x90B9; ///
enum GL_PATH_STROKE_BOUNDING_BOX_NV = 0x90A2; ///
enum GL_PATH_STROKE_COVER_MODE_NV = 0x9083; ///
enum GL_PATH_STROKE_MASK_NV = 0x9084; ///
enum GL_PATH_STROKE_WIDTH_NV = 0x9075; ///
enum GL_PATH_TERMINAL_DASH_CAP_NV = 0x907D; ///
enum GL_PATH_TERMINAL_END_CAP_NV = 0x9078; ///
enum GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV = 0x84E3; ///
enum GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV = 0x84E4; ///
enum GL_PERCENTAGE_AMD = 0x8BC3; ///
enum GL_PERFMON_GLOBAL_MODE_QCOM = 0x8FA0; ///
enum GL_PERFMON_RESULT_AMD = 0x8BC6; ///
enum GL_PERFMON_RESULT_AVAILABLE_AMD = 0x8BC4; ///
enum GL_PERFMON_RESULT_SIZE_AMD = 0x8BC5; ///
enum GL_PERFORMANCE_MONITOR_AMD = 0x9152; ///
enum GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL = 0x94FC; ///
enum GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = 0x94FB; ///
enum GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL = 0x94FA; ///
enum GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL = 0x94F8; ///
enum GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL = 0x94F9; ///
enum GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = 0x94FF; ///
enum GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL = 0x94F1; ///
enum GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL = 0x94F2; ///
enum GL_PERFQUERY_COUNTER_EVENT_INTEL = 0x94F0; ///
enum GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = 0x94FE; ///
enum GL_PERFQUERY_COUNTER_RAW_INTEL = 0x94F4; ///
enum GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL = 0x94F3; ///
enum GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL = 0x94F5; ///
enum GL_PERFQUERY_DONOT_FLUSH_INTEL = 0x83F9; ///
enum GL_PERFQUERY_FLUSH_INTEL = 0x83FA; ///
enum GL_PERFQUERY_GLOBAL_CONTEXT_INTEL = 0x00000001; ///
enum GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = 0x9500; ///
enum GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = 0x94FD; ///
enum GL_PERFQUERY_SINGLE_CONTEXT_INTEL = 0x00000000; ///
enum GL_PERFQUERY_WAIT_INTEL = 0x83FB; ///
enum GL_PERSPECTIVE_CORRECTION_HINT = 0x0C50; ///
enum GL_PERTURB_EXT = 0x85AE; ///
enum GL_PER_STAGE_CONSTANTS_NV = 0x8535; ///
enum GL_PHONG_HINT_WIN = 0x80EB; ///
enum GL_PHONG_WIN = 0x80EA; ///
enum GL_PINLIGHT_NV = 0x92A8; ///
enum GL_PIXEL_BUFFER_BARRIER_BIT = 0x00000080; ///
enum GL_PIXEL_BUFFER_BARRIER_BIT_EXT = 0x00000080; ///
enum GL_PIXEL_COUNTER_BITS_NV = 0x8864; ///
enum GL_PIXEL_COUNT_AVAILABLE_NV = 0x8867; ///
enum GL_PIXEL_COUNT_NV = 0x8866; ///
enum GL_PIXEL_CUBIC_WEIGHT_EXT = 0x8333; ///
enum GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 0x8355; ///
enum GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 0x8354; ///
enum GL_PIXEL_GROUP_COLOR_SGIS = 0x8356; ///
enum GL_PIXEL_MAG_FILTER_EXT = 0x8331; ///
enum GL_PIXEL_MAP_A_TO_A = 0x0C79; ///
enum GL_PIXEL_MAP_A_TO_A_SIZE = 0x0CB9; ///
enum GL_PIXEL_MAP_B_TO_B = 0x0C78; ///
enum GL_PIXEL_MAP_B_TO_B_SIZE = 0x0CB8; ///
enum GL_PIXEL_MAP_G_TO_G = 0x0C77; ///
enum GL_PIXEL_MAP_G_TO_G_SIZE = 0x0CB7; ///
enum GL_PIXEL_MAP_I_TO_A = 0x0C75; ///
enum GL_PIXEL_MAP_I_TO_A_SIZE = 0x0CB5; ///
enum GL_PIXEL_MAP_I_TO_B = 0x0C74; ///
enum GL_PIXEL_MAP_I_TO_B_SIZE = 0x0CB4; ///
enum GL_PIXEL_MAP_I_TO_G = 0x0C73; ///
enum GL_PIXEL_MAP_I_TO_G_SIZE = 0x0CB3; ///
enum GL_PIXEL_MAP_I_TO_I = 0x0C70; ///
enum GL_PIXEL_MAP_I_TO_I_SIZE = 0x0CB0; ///
enum GL_PIXEL_MAP_I_TO_R = 0x0C72; ///
enum GL_PIXEL_MAP_I_TO_R_SIZE = 0x0CB2; ///
enum GL_PIXEL_MAP_R_TO_R = 0x0C76; ///
enum GL_PIXEL_MAP_R_TO_R_SIZE = 0x0CB6; ///
enum GL_PIXEL_MAP_S_TO_S = 0x0C71; ///
enum GL_PIXEL_MAP_S_TO_S_SIZE = 0x0CB1; ///
enum GL_PIXEL_MIN_FILTER_EXT = 0x8332; ///
enum GL_PIXEL_MODE_BIT = 0x00000020; ///
enum GL_PIXEL_PACK_BUFFER = 0x88EB; ///
enum GL_PIXEL_PACK_BUFFER_ARB = 0x88EB; ///
enum GL_PIXEL_PACK_BUFFER_BINDING = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_BINDING_ARB = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_BINDING_EXT = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_EXT = 0x88EB; ///
enum GL_PIXEL_SUBSAMPLE_2424_SGIX = 0x85A3; ///
enum GL_PIXEL_SUBSAMPLE_4242_SGIX = 0x85A4; ///
enum GL_PIXEL_SUBSAMPLE_4444_SGIX = 0x85A2; ///
enum GL_PIXEL_TEXTURE_SGIS = 0x8353; ///
enum GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX = 0x8189; ///
enum GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX = 0x818A; ///
enum GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 0x8188; ///
enum GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 0x8187; ///
enum GL_PIXEL_TEX_GEN_MODE_SGIX = 0x832B; ///
enum GL_PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184; ///
enum GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186; ///
enum GL_PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185; ///
enum GL_PIXEL_TEX_GEN_SGIX = 0x8139; ///
enum GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX = 0x813E; ///
enum GL_PIXEL_TILE_CACHE_INCREMENT_SGIX = 0x813F; ///
enum GL_PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145; ///
enum GL_PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144; ///
enum GL_PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143; ///
enum GL_PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142; ///
enum GL_PIXEL_TILE_HEIGHT_SGIX = 0x8141; ///
enum GL_PIXEL_TILE_WIDTH_SGIX = 0x8140; ///
enum GL_PIXEL_TRANSFORM_2D_EXT = 0x8330; ///
enum GL_PIXEL_TRANSFORM_2D_MATRIX_EXT = 0x8338; ///
enum GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 0x8336; ///
enum GL_PIXEL_UNPACK_BUFFER = 0x88EC; ///
enum GL_PIXEL_UNPACK_BUFFER_ARB = 0x88EC; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING_ARB = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING_EXT = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_EXT = 0x88EC; ///
enum GL_PLUS_CLAMPED_ALPHA_NV = 0x92B2; ///
enum GL_PLUS_CLAMPED_NV = 0x92B1; ///
enum GL_PLUS_DARKER_NV = 0x9292; ///
enum GL_PLUS_NV = 0x9291; ///
enum GL_PN_TRIANGLES_ATI = 0x87F0; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_ATI = 0x87F3; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI = 0x87F7; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI = 0x87F8; ///
enum GL_PN_TRIANGLES_POINT_MODE_ATI = 0x87F2; ///
enum GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI = 0x87F6; ///
enum GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI = 0x87F5; ///
enum GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 0x87F4; ///
enum GL_POINT = 0x1B00; ///
enum GL_POINTS = 0x0000; ///
enum GL_POINT_BIT = 0x00000002; ///
enum GL_POINT_DISTANCE_ATTENUATION = 0x8129; ///
enum GL_POINT_DISTANCE_ATTENUATION_ARB = 0x8129; ///
enum GL_POINT_FADE_THRESHOLD_SIZE = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_ARB = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_EXT = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128; ///
enum GL_POINT_NV = 0x1B00; ///
enum GL_POINT_SIZE = 0x0B11; ///
enum GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES = 0x8B9F; ///
enum GL_POINT_SIZE_ARRAY_OES = 0x8B9C; ///
enum GL_POINT_SIZE_ARRAY_POINTER_OES = 0x898C; ///
enum GL_POINT_SIZE_ARRAY_STRIDE_OES = 0x898B; ///
enum GL_POINT_SIZE_ARRAY_TYPE_OES = 0x898A; ///
enum GL_POINT_SIZE_GRANULARITY = 0x0B13; ///
enum GL_POINT_SIZE_MAX = 0x8127; ///
enum GL_POINT_SIZE_MAX_ARB = 0x8127; ///
enum GL_POINT_SIZE_MAX_EXT = 0x8127; ///
enum GL_POINT_SIZE_MAX_SGIS = 0x8127; ///
enum GL_POINT_SIZE_MIN = 0x8126; ///
enum GL_POINT_SIZE_MIN_ARB = 0x8126; ///
enum GL_POINT_SIZE_MIN_EXT = 0x8126; ///
enum GL_POINT_SIZE_MIN_SGIS = 0x8126; ///
enum GL_POINT_SIZE_RANGE = 0x0B12; ///
enum GL_POINT_SMOOTH = 0x0B10; ///
enum GL_POINT_SMOOTH_HINT = 0x0C51; ///
enum GL_POINT_SPRITE = 0x8861; ///
enum GL_POINT_SPRITE_ARB = 0x8861; ///
enum GL_POINT_SPRITE_COORD_ORIGIN = 0x8CA0; ///
enum GL_POINT_SPRITE_NV = 0x8861; ///
enum GL_POINT_SPRITE_OES = 0x8861; ///
enum GL_POINT_SPRITE_R_MODE_NV = 0x8863; ///
enum GL_POINT_TOKEN = 0x0701; ///
enum GL_POLYGON = 0x0009; ///
enum GL_POLYGON_BIT = 0x00000008; ///
enum GL_POLYGON_MODE = 0x0B40; ///
enum GL_POLYGON_MODE_NV = 0x0B40; ///
enum GL_POLYGON_OFFSET_BIAS_EXT = 0x8039; ///
enum GL_POLYGON_OFFSET_CLAMP_EXT = 0x8E1B; ///
enum GL_POLYGON_OFFSET_COMMAND_NV = 0x000E; ///
enum GL_POLYGON_OFFSET_EXT = 0x8037; ///
enum GL_POLYGON_OFFSET_FACTOR = 0x8038; ///
enum GL_POLYGON_OFFSET_FACTOR_EXT = 0x8038; ///
enum GL_POLYGON_OFFSET_FILL = 0x8037; ///
enum GL_POLYGON_OFFSET_LINE = 0x2A02; ///
enum GL_POLYGON_OFFSET_LINE_NV = 0x2A02; ///
enum GL_POLYGON_OFFSET_POINT = 0x2A01; ///
enum GL_POLYGON_OFFSET_POINT_NV = 0x2A01; ///
enum GL_POLYGON_OFFSET_UNITS = 0x2A00; ///
enum GL_POLYGON_SMOOTH = 0x0B41; ///
enum GL_POLYGON_SMOOTH_HINT = 0x0C53; ///
enum GL_POLYGON_STIPPLE = 0x0B42; ///
enum GL_POLYGON_STIPPLE_BIT = 0x00000010; ///
enum GL_POLYGON_TOKEN = 0x0703; ///
enum GL_POSITION = 0x1203; ///
enum GL_POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB; ///
enum GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB; ///
enum GL_POST_COLOR_MATRIX_ALPHA_SCALE = 0x80B7; ///
enum GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7; ///
enum GL_POST_COLOR_MATRIX_BLUE_BIAS = 0x80BA; ///
enum GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA; ///
enum GL_POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6; ///
enum GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6; ///
enum GL_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D2; ///
enum GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2; ///
enum GL_POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9; ///
enum GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9; ///
enum GL_POST_COLOR_MATRIX_GREEN_SCALE = 0x80B5; ///
enum GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5; ///
enum GL_POST_COLOR_MATRIX_RED_BIAS = 0x80B8; ///
enum GL_POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8; ///
enum GL_POST_COLOR_MATRIX_RED_SCALE = 0x80B4; ///
enum GL_POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4; ///
enum GL_POST_CONVOLUTION_ALPHA_BIAS = 0x8023; ///
enum GL_POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023; ///
enum GL_POST_CONVOLUTION_ALPHA_SCALE = 0x801F; ///
enum GL_POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F; ///
enum GL_POST_CONVOLUTION_BLUE_BIAS = 0x8022; ///
enum GL_POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022; ///
enum GL_POST_CONVOLUTION_BLUE_SCALE = 0x801E; ///
enum GL_POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E; ///
enum GL_POST_CONVOLUTION_COLOR_TABLE = 0x80D1; ///
enum GL_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1; ///
enum GL_POST_CONVOLUTION_GREEN_BIAS = 0x8021; ///
enum GL_POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021; ///
enum GL_POST_CONVOLUTION_GREEN_SCALE = 0x801D; ///
enum GL_POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D; ///
enum GL_POST_CONVOLUTION_RED_BIAS = 0x8020; ///
enum GL_POST_CONVOLUTION_RED_BIAS_EXT = 0x8020; ///
enum GL_POST_CONVOLUTION_RED_SCALE = 0x801C; ///
enum GL_POST_CONVOLUTION_RED_SCALE_EXT = 0x801C; ///
enum GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 0x8162; ///
enum GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 0x817B; ///
enum GL_POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179; ///
enum GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 0x817C; ///
enum GL_POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A; ///
enum GL_PREFER_DOUBLEBUFFER_HINT_PGI = 0x1A1F8; ///
enum GL_PRESENT_DURATION_NV = 0x8E2B; ///
enum GL_PRESENT_TIME_NV = 0x8E2A; ///
enum GL_PRESERVE_ATI = 0x8762; ///
enum GL_PREVIOUS = 0x8578; ///
enum GL_PREVIOUS_ARB = 0x8578; ///
enum GL_PREVIOUS_EXT = 0x8578; ///
enum GL_PREVIOUS_TEXTURE_INPUT_NV = 0x86E4; ///
enum GL_PRIMARY_COLOR = 0x8577; ///
enum GL_PRIMARY_COLOR_ARB = 0x8577; ///
enum GL_PRIMARY_COLOR_EXT = 0x8577; ///
enum GL_PRIMARY_COLOR_NV = 0x852C; ///
enum GL_PRIMITIVES_GENERATED = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_EXT = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_NV = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_OES = 0x8C87; ///
enum GL_PRIMITIVES_SUBMITTED_ARB = 0x82EF; ///
enum GL_PRIMITIVE_BOUNDING_BOX = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_ARB = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_EXT = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_OES = 0x92BE; ///
enum GL_PRIMITIVE_ID_NV = 0x8C7C; ///
enum GL_PRIMITIVE_RESTART = 0x8F9D; ///
enum GL_PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69; ///
enum GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = 0x8221; ///
enum GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES = 0x8221; ///
enum GL_PRIMITIVE_RESTART_INDEX = 0x8F9E; ///
enum GL_PRIMITIVE_RESTART_INDEX_NV = 0x8559; ///
enum GL_PRIMITIVE_RESTART_NV = 0x8558; ///
enum GL_PROGRAM = 0x82E2; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB = 0x9341; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_NV = 0x9341; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB = 0x9340; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV = 0x9340; ///
enum GL_PROGRAM_ADDRESS_REGISTERS_ARB = 0x88B0; ///
enum GL_PROGRAM_ALU_INSTRUCTIONS_ARB = 0x8805; ///
enum GL_PROGRAM_ATTRIBS_ARB = 0x88AC; ///
enum GL_PROGRAM_ATTRIB_COMPONENTS_NV = 0x8906; ///
enum GL_PROGRAM_BINARY_ANGLE = 0x93A6; ///
enum GL_PROGRAM_BINARY_FORMATS = 0x87FF; ///
enum GL_PROGRAM_BINARY_FORMATS_OES = 0x87FF; ///
enum GL_PROGRAM_BINARY_LENGTH = 0x8741; ///
enum GL_PROGRAM_BINARY_LENGTH_OES = 0x8741; ///
enum GL_PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257; ///
enum GL_PROGRAM_BINDING_ARB = 0x8677; ///
enum GL_PROGRAM_ERROR_POSITION_ARB = 0x864B; ///
enum GL_PROGRAM_ERROR_POSITION_NV = 0x864B; ///
enum GL_PROGRAM_ERROR_STRING_ARB = 0x8874; ///
enum GL_PROGRAM_ERROR_STRING_NV = 0x8874; ///
enum GL_PROGRAM_FORMAT_ARB = 0x8876; ///
enum GL_PROGRAM_FORMAT_ASCII_ARB = 0x8875; ///
enum GL_PROGRAM_INPUT = 0x92E3; ///
enum GL_PROGRAM_INSTRUCTIONS_ARB = 0x88A0; ///
enum GL_PROGRAM_KHR = 0x82E2; ///
enum GL_PROGRAM_LENGTH_ARB = 0x8627; ///
enum GL_PROGRAM_LENGTH_NV = 0x8627; ///
enum GL_PROGRAM_MATRIX_EXT = 0x8E2D; ///
enum GL_PROGRAM_MATRIX_STACK_DEPTH_EXT = 0x8E2F; ///
enum GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 0x88B2; ///
enum GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 0x8808; ///
enum GL_PROGRAM_NATIVE_ATTRIBS_ARB = 0x88AE; ///
enum GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 0x88A2; ///
enum GL_PROGRAM_NATIVE_PARAMETERS_ARB = 0x88AA; ///
enum GL_PROGRAM_NATIVE_TEMPORARIES_ARB = 0x88A6; ///
enum GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 0x880A; ///
enum GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 0x8809; ///
enum GL_PROGRAM_OBJECT_ARB = 0x8B40; ///
enum GL_PROGRAM_OBJECT_EXT = 0x8B40; ///
enum GL_PROGRAM_OUTPUT = 0x92E4; ///
enum GL_PROGRAM_PARAMETERS_ARB = 0x88A8; ///
enum GL_PROGRAM_PARAMETER_NV = 0x8644; ///
enum GL_PROGRAM_PIPELINE = 0x82E4; ///
enum GL_PROGRAM_PIPELINE_BINDING = 0x825A; ///
enum GL_PROGRAM_PIPELINE_BINDING_EXT = 0x825A; ///
enum GL_PROGRAM_PIPELINE_KHR = 0x82E4; ///
enum GL_PROGRAM_PIPELINE_OBJECT_EXT = 0x8A4F; ///
enum GL_PROGRAM_POINT_SIZE = 0x8642; ///
enum GL_PROGRAM_POINT_SIZE_ARB = 0x8642; ///
enum GL_PROGRAM_POINT_SIZE_EXT = 0x8642; ///
enum GL_PROGRAM_RESIDENT_NV = 0x8647; ///
enum GL_PROGRAM_RESULT_COMPONENTS_NV = 0x8907; ///
enum GL_PROGRAM_SEPARABLE = 0x8258; ///
enum GL_PROGRAM_SEPARABLE_EXT = 0x8258; ///
enum GL_PROGRAM_STRING_ARB = 0x8628; ///
enum GL_PROGRAM_STRING_NV = 0x8628; ///
enum GL_PROGRAM_TARGET_NV = 0x8646; ///
enum GL_PROGRAM_TEMPORARIES_ARB = 0x88A4; ///
enum GL_PROGRAM_TEX_INDIRECTIONS_ARB = 0x8807; ///
enum GL_PROGRAM_TEX_INSTRUCTIONS_ARB = 0x8806; ///
enum GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB = 0x88B6; ///
enum GL_PROJECTION = 0x1701; ///
enum GL_PROJECTION_MATRIX = 0x0BA7; ///
enum GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898E; ///
enum GL_PROJECTION_STACK_DEPTH = 0x0BA4; ///
enum GL_PROVOKING_VERTEX = 0x8E4F; ///
enum GL_PROVOKING_VERTEX_EXT = 0x8E4F; ///
enum GL_PROXY_COLOR_TABLE = 0x80D3; ///
enum GL_PROXY_COLOR_TABLE_SGI = 0x80D3; ///
enum GL_PROXY_HISTOGRAM = 0x8025; ///
enum GL_PROXY_HISTOGRAM_EXT = 0x8025; ///
enum GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5; ///
enum GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D5; ///
enum GL_PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4; ///
enum GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D4; ///
enum GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 0x8163; ///
enum GL_PROXY_TEXTURE_1D = 0x8063; ///
enum GL_PROXY_TEXTURE_1D_ARRAY = 0x8C19; ///
enum GL_PROXY_TEXTURE_1D_ARRAY_EXT = 0x8C19; ///
enum GL_PROXY_TEXTURE_1D_EXT = 0x8063; ///
enum GL_PROXY_TEXTURE_1D_STACK_MESAX = 0x875B; ///
enum GL_PROXY_TEXTURE_2D = 0x8064; ///
enum GL_PROXY_TEXTURE_2D_ARRAY = 0x8C1B; ///
enum GL_PROXY_TEXTURE_2D_ARRAY_EXT = 0x8C1B; ///
enum GL_PROXY_TEXTURE_2D_EXT = 0x8064; ///
enum GL_PROXY_TEXTURE_2D_MULTISAMPLE = 0x9101; ///
enum GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103; ///
enum GL_PROXY_TEXTURE_2D_STACK_MESAX = 0x875C; ///
enum GL_PROXY_TEXTURE_3D = 0x8070; ///
enum GL_PROXY_TEXTURE_3D_EXT = 0x8070; ///
enum GL_PROXY_TEXTURE_4D_SGIS = 0x8135; ///
enum GL_PROXY_TEXTURE_COLOR_TABLE_SGI = 0x80BD; ///
enum GL_PROXY_TEXTURE_CUBE_MAP = 0x851B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARB = 0x851B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARRAY = 0x900B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x900B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_EXT = 0x851B; ///
enum GL_PROXY_TEXTURE_RECTANGLE = 0x84F7; ///
enum GL_PROXY_TEXTURE_RECTANGLE_ARB = 0x84F7; ///
enum GL_PROXY_TEXTURE_RECTANGLE_NV = 0x84F7; ///
enum GL_PURGEABLE_APPLE = 0x8A1D; ///
enum GL_PURGED_CONTEXT_RESET_NV = 0x92BB; ///
enum GL_Q = 0x2003; ///
enum GL_QUADRATIC_ATTENUATION = 0x1209; ///
enum GL_QUADRATIC_CURVE_TO_NV = 0x0A; ///
enum GL_QUADS = 0x0007; ///
enum GL_QUADS_EXT = 0x0007; ///
enum GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C; ///
enum GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT = 0x8E4C; ///
enum GL_QUADS_OES = 0x0007; ///
enum GL_QUAD_ALPHA4_SGIS = 0x811E; ///
enum GL_QUAD_ALPHA8_SGIS = 0x811F; ///
enum GL_QUAD_INTENSITY4_SGIS = 0x8122; ///
enum GL_QUAD_INTENSITY8_SGIS = 0x8123; ///
enum GL_QUAD_LUMINANCE4_SGIS = 0x8120; ///
enum GL_QUAD_LUMINANCE8_SGIS = 0x8121; ///
enum GL_QUAD_MESH_SUN = 0x8614; ///
enum GL_QUAD_STRIP = 0x0008; ///
enum GL_QUAD_TEXTURE_SELECT_SGIS = 0x8125; ///
enum GL_QUARTER_BIT_ATI = 0x00000010; ///
enum GL_QUERY = 0x82E3; ///
enum GL_QUERY_ALL_EVENT_BITS_AMD = 0xFFFFFFFF; ///
enum GL_QUERY_BUFFER = 0x9192; ///
enum GL_QUERY_BUFFER_AMD = 0x9192; ///
enum GL_QUERY_BUFFER_BARRIER_BIT = 0x00008000; ///
enum GL_QUERY_BUFFER_BINDING = 0x9193; ///
enum GL_QUERY_BUFFER_BINDING_AMD = 0x9193; ///
enum GL_QUERY_BY_REGION_NO_WAIT = 0x8E16; ///
enum GL_QUERY_BY_REGION_NO_WAIT_INVERTED = 0x8E1A; ///
enum GL_QUERY_BY_REGION_NO_WAIT_NV = 0x8E16; ///
enum GL_QUERY_BY_REGION_WAIT = 0x8E15; ///
enum GL_QUERY_BY_REGION_WAIT_INVERTED = 0x8E19; ///
enum GL_QUERY_BY_REGION_WAIT_NV = 0x8E15; ///
enum GL_QUERY_COUNTER_BITS = 0x8864; ///
enum GL_QUERY_COUNTER_BITS_ARB = 0x8864; ///
enum GL_QUERY_COUNTER_BITS_EXT = 0x8864; ///
enum GL_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = 0x00000008; ///
enum GL_QUERY_DEPTH_FAIL_EVENT_BIT_AMD = 0x00000002; ///
enum GL_QUERY_DEPTH_PASS_EVENT_BIT_AMD = 0x00000001; ///
enum GL_QUERY_KHR = 0x82E3; ///
enum GL_QUERY_NO_WAIT = 0x8E14; ///
enum GL_QUERY_NO_WAIT_INVERTED = 0x8E18; ///
enum GL_QUERY_NO_WAIT_NV = 0x8E14; ///
enum GL_QUERY_OBJECT_AMD = 0x9153; ///
enum GL_QUERY_OBJECT_EXT = 0x9153; ///
enum GL_QUERY_RESULT = 0x8866; ///
enum GL_QUERY_RESULT_ARB = 0x8866; ///
enum GL_QUERY_RESULT_AVAILABLE = 0x8867; ///
enum GL_QUERY_RESULT_AVAILABLE_ARB = 0x8867; ///
enum GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867; ///
enum GL_QUERY_RESULT_EXT = 0x8866; ///
enum GL_QUERY_RESULT_NO_WAIT = 0x9194; ///
enum GL_QUERY_RESULT_NO_WAIT_AMD = 0x9194; ///
enum GL_QUERY_STENCIL_FAIL_EVENT_BIT_AMD = 0x00000004; ///
enum GL_QUERY_TARGET = 0x82EA; ///
enum GL_QUERY_WAIT = 0x8E13; ///
enum GL_QUERY_WAIT_INVERTED = 0x8E17; ///
enum GL_QUERY_WAIT_NV = 0x8E13; ///
enum GL_R = 0x2002; ///
enum GL_R11F_G11F_B10F = 0x8C3A; ///
enum GL_R11F_G11F_B10F_APPLE = 0x8C3A; ///
enum GL_R11F_G11F_B10F_EXT = 0x8C3A; ///
enum GL_R16 = 0x822A; ///
enum GL_R16F = 0x822D; ///
enum GL_R16F_EXT = 0x822D; ///
enum GL_R16I = 0x8233; ///
enum GL_R16UI = 0x8234; ///
enum GL_R16_EXT = 0x822A; ///
enum GL_R16_SNORM = 0x8F98; ///
enum GL_R16_SNORM_EXT = 0x8F98; ///
enum GL_R1UI_C3F_V3F_SUN = 0x85C6; ///
enum GL_R1UI_C4F_N3F_V3F_SUN = 0x85C8; ///
enum GL_R1UI_C4UB_V3F_SUN = 0x85C5; ///
enum GL_R1UI_N3F_V3F_SUN = 0x85C7; ///
enum GL_R1UI_T2F_C4F_N3F_V3F_SUN = 0x85CB; ///
enum GL_R1UI_T2F_N3F_V3F_SUN = 0x85CA; ///
enum GL_R1UI_T2F_V3F_SUN = 0x85C9; ///
enum GL_R1UI_V3F_SUN = 0x85C4; ///
enum GL_R32F = 0x822E; ///
enum GL_R32F_EXT = 0x822E; ///
enum GL_R32I = 0x8235; ///
enum GL_R32UI = 0x8236; ///
enum GL_R3_G3_B2 = 0x2A10; ///
enum GL_R8 = 0x8229; ///
enum GL_R8I = 0x8231; ///
enum GL_R8UI = 0x8232; ///
enum GL_R8_EXT = 0x8229; ///
enum GL_R8_SNORM = 0x8F94; ///
enum GL_RASTERIZER_DISCARD = 0x8C89; ///
enum GL_RASTERIZER_DISCARD_EXT = 0x8C89; ///
enum GL_RASTERIZER_DISCARD_NV = 0x8C89; ///
enum GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT = 0x932A; ///
enum GL_RASTER_MULTISAMPLE_EXT = 0x9327; ///
enum GL_RASTER_POSITION_UNCLIPPED_IBM = 0x19262; ///
enum GL_RASTER_SAMPLES_EXT = 0x9328; ///
enum GL_READ_BUFFER = 0x0C02; ///
enum GL_READ_BUFFER_EXT = 0x0C02; ///
enum GL_READ_BUFFER_NV = 0x0C02; ///
enum GL_READ_FRAMEBUFFER = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_ANGLE = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_APPLE = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_BINDING = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_ANGLE = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_APPLE = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_EXT = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_NV = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_EXT = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_NV = 0x8CA8; ///
enum GL_READ_ONLY = 0x88B8; ///
enum GL_READ_ONLY_ARB = 0x88B8; ///
enum GL_READ_PIXELS = 0x828C; ///
enum GL_READ_PIXELS_FORMAT = 0x828D; ///
enum GL_READ_PIXELS_TYPE = 0x828E; ///
enum GL_READ_PIXEL_DATA_RANGE_LENGTH_NV = 0x887B; ///
enum GL_READ_PIXEL_DATA_RANGE_NV = 0x8879; ///
enum GL_READ_PIXEL_DATA_RANGE_POINTER_NV = 0x887D; ///
enum GL_READ_WRITE = 0x88BA; ///
enum GL_READ_WRITE_ARB = 0x88BA; ///
enum GL_RECIP_ADD_SIGNED_ALPHA_IMG = 0x8C05; ///
enum GL_RECLAIM_MEMORY_HINT_PGI = 0x1A1FE; ///
enum GL_RECT_NV = 0xF6; ///
enum GL_RED = 0x1903; ///
enum GL_REDUCE = 0x8016; ///
enum GL_REDUCE_EXT = 0x8016; ///
enum GL_RED_BIAS = 0x0D15; ///
enum GL_RED_BITS = 0x0D52; ///
enum GL_RED_BIT_ATI = 0x00000001; ///
enum GL_RED_EXT = 0x1903; ///
enum GL_RED_INTEGER = 0x8D94; ///
enum GL_RED_INTEGER_EXT = 0x8D94; ///
enum GL_RED_MAX_CLAMP_INGR = 0x8564; ///
enum GL_RED_MIN_CLAMP_INGR = 0x8560; ///
enum GL_RED_NV = 0x1903; ///
enum GL_RED_SCALE = 0x0D14; ///
enum GL_RED_SNORM = 0x8F90; ///
enum GL_REFERENCED_BY_COMPUTE_SHADER = 0x930B; ///
enum GL_REFERENCED_BY_FRAGMENT_SHADER = 0x930A; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER = 0x9309; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER_EXT = 0x9309; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER_OES = 0x9309; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER = 0x9307; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT = 0x9307; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES = 0x9307; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x9308; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT = 0x9308; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES = 0x9308; ///
enum GL_REFERENCED_BY_VERTEX_SHADER = 0x9306; ///
enum GL_REFERENCE_PLANE_EQUATION_SGIX = 0x817E; ///
enum GL_REFERENCE_PLANE_SGIX = 0x817D; ///
enum GL_REFLECTION_MAP = 0x8512; ///
enum GL_REFLECTION_MAP_ARB = 0x8512; ///
enum GL_REFLECTION_MAP_EXT = 0x8512; ///
enum GL_REFLECTION_MAP_NV = 0x8512; ///
enum GL_REFLECTION_MAP_OES = 0x8512; ///
enum GL_REGISTER_COMBINERS_NV = 0x8522; ///
enum GL_REG_0_ATI = 0x8921; ///
enum GL_REG_10_ATI = 0x892B; ///
enum GL_REG_11_ATI = 0x892C; ///
enum GL_REG_12_ATI = 0x892D; ///
enum GL_REG_13_ATI = 0x892E; ///
enum GL_REG_14_ATI = 0x892F; ///
enum GL_REG_15_ATI = 0x8930; ///
enum GL_REG_16_ATI = 0x8931; ///
enum GL_REG_17_ATI = 0x8932; ///
enum GL_REG_18_ATI = 0x8933; ///
enum GL_REG_19_ATI = 0x8934; ///
enum GL_REG_1_ATI = 0x8922; ///
enum GL_REG_20_ATI = 0x8935; ///
enum GL_REG_21_ATI = 0x8936; ///
enum GL_REG_22_ATI = 0x8937; ///
enum GL_REG_23_ATI = 0x8938; ///
enum GL_REG_24_ATI = 0x8939; ///
enum GL_REG_25_ATI = 0x893A; ///
enum GL_REG_26_ATI = 0x893B; ///
enum GL_REG_27_ATI = 0x893C; ///
enum GL_REG_28_ATI = 0x893D; ///
enum GL_REG_29_ATI = 0x893E; ///
enum GL_REG_2_ATI = 0x8923; ///
enum GL_REG_30_ATI = 0x893F; ///
enum GL_REG_31_ATI = 0x8940; ///
enum GL_REG_3_ATI = 0x8924; ///
enum GL_REG_4_ATI = 0x8925; ///
enum GL_REG_5_ATI = 0x8926; ///
enum GL_REG_6_ATI = 0x8927; ///
enum GL_REG_7_ATI = 0x8928; ///
enum GL_REG_8_ATI = 0x8929; ///
enum GL_REG_9_ATI = 0x892A; ///
enum GL_RELATIVE_ARC_TO_NV = 0xFF; ///
enum GL_RELATIVE_CONIC_CURVE_TO_NV = 0x1B; ///
enum GL_RELATIVE_CUBIC_CURVE_TO_NV = 0x0D; ///
enum GL_RELATIVE_HORIZONTAL_LINE_TO_NV = 0x07; ///
enum GL_RELATIVE_LARGE_CCW_ARC_TO_NV = 0x17; ///
enum GL_RELATIVE_LARGE_CW_ARC_TO_NV = 0x19; ///
enum GL_RELATIVE_LINE_TO_NV = 0x05; ///
enum GL_RELATIVE_MOVE_TO_NV = 0x03; ///
enum GL_RELATIVE_QUADRATIC_CURVE_TO_NV = 0x0B; ///
enum GL_RELATIVE_RECT_NV = 0xF7; ///
enum GL_RELATIVE_ROUNDED_RECT2_NV = 0xEB; ///
enum GL_RELATIVE_ROUNDED_RECT4_NV = 0xED; ///
enum GL_RELATIVE_ROUNDED_RECT8_NV = 0xEF; ///
enum GL_RELATIVE_ROUNDED_RECT_NV = 0xE9; ///
enum GL_RELATIVE_SMALL_CCW_ARC_TO_NV = 0x13; ///
enum GL_RELATIVE_SMALL_CW_ARC_TO_NV = 0x15; ///
enum GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV = 0x11; ///
enum GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0F; ///
enum GL_RELATIVE_VERTICAL_LINE_TO_NV = 0x09; ///
enum GL_RELEASED_APPLE = 0x8A19; ///
enum GL_RENDER = 0x1C00; ///
enum GL_RENDERBUFFER = 0x8D41; ///
enum GL_RENDERBUFFER_ALPHA_SIZE = 0x8D53; ///
enum GL_RENDERBUFFER_ALPHA_SIZE_EXT = 0x8D53; ///
enum GL_RENDERBUFFER_ALPHA_SIZE_OES = 0x8D53; ///
enum GL_RENDERBUFFER_BINDING = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_ANGLE = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_EXT = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_OES = 0x8CA7; ///
enum GL_RENDERBUFFER_BLUE_SIZE = 0x8D52; ///
enum GL_RENDERBUFFER_BLUE_SIZE_EXT = 0x8D52; ///
enum GL_RENDERBUFFER_BLUE_SIZE_OES = 0x8D52; ///
enum GL_RENDERBUFFER_COLOR_SAMPLES_NV = 0x8E10; ///
enum GL_RENDERBUFFER_COVERAGE_SAMPLES_NV = 0x8CAB; ///
enum GL_RENDERBUFFER_DEPTH_SIZE = 0x8D54; ///
enum GL_RENDERBUFFER_DEPTH_SIZE_EXT = 0x8D54; ///
enum GL_RENDERBUFFER_DEPTH_SIZE_OES = 0x8D54; ///
enum GL_RENDERBUFFER_EXT = 0x8D41; ///
enum GL_RENDERBUFFER_FREE_MEMORY_ATI = 0x87FD; ///
enum GL_RENDERBUFFER_GREEN_SIZE = 0x8D51; ///
enum GL_RENDERBUFFER_GREEN_SIZE_EXT = 0x8D51; ///
enum GL_RENDERBUFFER_GREEN_SIZE_OES = 0x8D51; ///
enum GL_RENDERBUFFER_HEIGHT = 0x8D43; ///
enum GL_RENDERBUFFER_HEIGHT_EXT = 0x8D43; ///
enum GL_RENDERBUFFER_HEIGHT_OES = 0x8D43; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8D44; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT_EXT = 0x8D44; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT_OES = 0x8D44; ///
enum GL_RENDERBUFFER_OES = 0x8D41; ///
enum GL_RENDERBUFFER_RED_SIZE = 0x8D50; ///
enum GL_RENDERBUFFER_RED_SIZE_EXT = 0x8D50; ///
enum GL_RENDERBUFFER_RED_SIZE_OES = 0x8D50; ///
enum GL_RENDERBUFFER_SAMPLES = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_ANGLE = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_APPLE = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_EXT = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_IMG = 0x9133; ///
enum GL_RENDERBUFFER_SAMPLES_NV = 0x8CAB; ///
enum GL_RENDERBUFFER_STENCIL_SIZE = 0x8D55; ///
enum GL_RENDERBUFFER_STENCIL_SIZE_EXT = 0x8D55; ///
enum GL_RENDERBUFFER_STENCIL_SIZE_OES = 0x8D55; ///
enum GL_RENDERBUFFER_WIDTH = 0x8D42; ///
enum GL_RENDERBUFFER_WIDTH_EXT = 0x8D42; ///
enum GL_RENDERBUFFER_WIDTH_OES = 0x8D42; ///
enum GL_RENDERER = 0x1F01; ///
enum GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM = 0x8FB3; ///
enum GL_RENDER_MODE = 0x0C40; ///
enum GL_REPEAT = 0x2901; ///
enum GL_REPLACE = 0x1E01; ///
enum GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN = 0x85C3; ///
enum GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN = 0x85C2; ///
enum GL_REPLACEMENT_CODE_ARRAY_SUN = 0x85C0; ///
enum GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN = 0x85C1; ///
enum GL_REPLACEMENT_CODE_SUN = 0x81D8; ///
enum GL_REPLACE_EXT = 0x8062; ///
enum GL_REPLACE_MIDDLE_SUN = 0x0002; ///
enum GL_REPLACE_OLDEST_SUN = 0x0003; ///
enum GL_REPLACE_VALUE_AMD = 0x874B; ///
enum GL_REPLICATE_BORDER = 0x8153; ///
enum GL_REPLICATE_BORDER_HP = 0x8153; ///
enum GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES = 0x8D68; ///
enum GL_RESAMPLE_AVERAGE_OML = 0x8988; ///
enum GL_RESAMPLE_DECIMATE_OML = 0x8989; ///
enum GL_RESAMPLE_DECIMATE_SGIX = 0x8430; ///
enum GL_RESAMPLE_REPLICATE_OML = 0x8986; ///
enum GL_RESAMPLE_REPLICATE_SGIX = 0x8433; ///
enum GL_RESAMPLE_ZERO_FILL_OML = 0x8987; ///
enum GL_RESAMPLE_ZERO_FILL_SGIX = 0x8434; ///
enum GL_RESCALE_NORMAL = 0x803A; ///
enum GL_RESCALE_NORMAL_EXT = 0x803A; ///
enum GL_RESET_NOTIFICATION_STRATEGY = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_EXT = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_KHR = 0x8256; ///
enum GL_RESTART_PATH_NV = 0xF0; ///
enum GL_RESTART_SUN = 0x0001; ///
enum GL_RETAINED_APPLE = 0x8A1B; ///
enum GL_RETURN = 0x0102; ///
enum GL_RG = 0x8227; ///
enum GL_RG16 = 0x822C; ///
enum GL_RG16F = 0x822F; ///
enum GL_RG16F_EXT = 0x822F; ///
enum GL_RG16I = 0x8239; ///
enum GL_RG16UI = 0x823A; ///
enum GL_RG16_EXT = 0x822C; ///
enum GL_RG16_SNORM = 0x8F99; ///
enum GL_RG16_SNORM_EXT = 0x8F99; ///
enum GL_RG32F = 0x8230; ///
enum GL_RG32F_EXT = 0x8230; ///
enum GL_RG32I = 0x823B; ///
enum GL_RG32UI = 0x823C; ///
enum GL_RG8 = 0x822B; ///
enum GL_RG8I = 0x8237; ///
enum GL_RG8UI = 0x8238; ///
enum GL_RG8_EXT = 0x822B; ///
enum GL_RG8_SNORM = 0x8F95; ///
enum GL_RGB = 0x1907; ///
enum GL_RGB10 = 0x8052; ///
enum GL_RGB10_A2 = 0x8059; ///
enum GL_RGB10_A2UI = 0x906F; ///
enum GL_RGB10_A2_EXT = 0x8059; ///
enum GL_RGB10_EXT = 0x8052; ///
enum GL_RGB12 = 0x8053; ///
enum GL_RGB12_EXT = 0x8053; ///
enum GL_RGB16 = 0x8054; ///
enum GL_RGB16F = 0x881B; ///
enum GL_RGB16F_ARB = 0x881B; ///
enum GL_RGB16F_EXT = 0x881B; ///
enum GL_RGB16I = 0x8D89; ///
enum GL_RGB16I_EXT = 0x8D89; ///
enum GL_RGB16UI = 0x8D77; ///
enum GL_RGB16UI_EXT = 0x8D77; ///
enum GL_RGB16_EXT = 0x8054; ///
enum GL_RGB16_SNORM = 0x8F9A; ///
enum GL_RGB16_SNORM_EXT = 0x8F9A; ///
enum GL_RGB2_EXT = 0x804E; ///
enum GL_RGB32F = 0x8815; ///
enum GL_RGB32F_ARB = 0x8815; ///
enum GL_RGB32F_EXT = 0x8815; ///
enum GL_RGB32I = 0x8D83; ///
enum GL_RGB32I_EXT = 0x8D83; ///
enum GL_RGB32UI = 0x8D71; ///
enum GL_RGB32UI_EXT = 0x8D71; ///
enum GL_RGB4 = 0x804F; ///
enum GL_RGB4_EXT = 0x804F; ///
enum GL_RGB4_S3TC = 0x83A1; ///
enum GL_RGB5 = 0x8050; ///
enum GL_RGB565 = 0x8D62; ///
enum GL_RGB565_OES = 0x8D62; ///
enum GL_RGB5_A1 = 0x8057; ///
enum GL_RGB5_A1_EXT = 0x8057; ///
enum GL_RGB5_A1_OES = 0x8057; ///
enum GL_RGB5_EXT = 0x8050; ///
enum GL_RGB8 = 0x8051; ///
enum GL_RGB8I = 0x8D8F; ///
enum GL_RGB8I_EXT = 0x8D8F; ///
enum GL_RGB8UI = 0x8D7D; ///
enum GL_RGB8UI_EXT = 0x8D7D; ///
enum GL_RGB8_EXT = 0x8051; ///
enum GL_RGB8_OES = 0x8051; ///
enum GL_RGB8_SNORM = 0x8F96; ///
enum GL_RGB9_E5 = 0x8C3D; ///
enum GL_RGB9_E5_APPLE = 0x8C3D; ///
enum GL_RGB9_E5_EXT = 0x8C3D; ///
enum GL_RGBA = 0x1908; ///
enum GL_RGBA12 = 0x805A; ///
enum GL_RGBA12_EXT = 0x805A; ///
enum GL_RGBA16 = 0x805B; ///
enum GL_RGBA16F = 0x881A; ///
enum GL_RGBA16F_ARB = 0x881A; ///
enum GL_RGBA16F_EXT = 0x881A; ///
enum GL_RGBA16I = 0x8D88; ///
enum GL_RGBA16I_EXT = 0x8D88; ///
enum GL_RGBA16UI = 0x8D76; ///
enum GL_RGBA16UI_EXT = 0x8D76; ///
enum GL_RGBA16_EXT = 0x805B; ///
enum GL_RGBA16_SNORM = 0x8F9B; ///
enum GL_RGBA16_SNORM_EXT = 0x8F9B; ///
enum GL_RGBA2 = 0x8055; ///
enum GL_RGBA2_EXT = 0x8055; ///
enum GL_RGBA32F = 0x8814; ///
enum GL_RGBA32F_ARB = 0x8814; ///
enum GL_RGBA32F_EXT = 0x8814; ///
enum GL_RGBA32I = 0x8D82; ///
enum GL_RGBA32I_EXT = 0x8D82; ///
enum GL_RGBA32UI = 0x8D70; ///
enum GL_RGBA32UI_EXT = 0x8D70; ///
enum GL_RGBA4 = 0x8056; ///
enum GL_RGBA4_DXT5_S3TC = 0x83A5; ///
enum GL_RGBA4_EXT = 0x8056; ///
enum GL_RGBA4_OES = 0x8056; ///
enum GL_RGBA4_S3TC = 0x83A3; ///
enum GL_RGBA8 = 0x8058; ///
enum GL_RGBA8I = 0x8D8E; ///
enum GL_RGBA8I_EXT = 0x8D8E; ///
enum GL_RGBA8UI = 0x8D7C; ///
enum GL_RGBA8UI_EXT = 0x8D7C; ///
enum GL_RGBA8_EXT = 0x8058; ///
enum GL_RGBA8_OES = 0x8058; ///
enum GL_RGBA8_SNORM = 0x8F97; ///
enum GL_RGBA_DXT5_S3TC = 0x83A4; ///
enum GL_RGBA_FLOAT16_APPLE = 0x881A; ///
enum GL_RGBA_FLOAT16_ATI = 0x881A; ///
enum GL_RGBA_FLOAT32_APPLE = 0x8814; ///
enum GL_RGBA_FLOAT32_ATI = 0x8814; ///
enum GL_RGBA_FLOAT_MODE_ARB = 0x8820; ///
enum GL_RGBA_FLOAT_MODE_ATI = 0x8820; ///
enum GL_RGBA_INTEGER = 0x8D99; ///
enum GL_RGBA_INTEGER_EXT = 0x8D99; ///
enum GL_RGBA_INTEGER_MODE_EXT = 0x8D9E; ///
enum GL_RGBA_MODE = 0x0C31; ///
enum GL_RGBA_S3TC = 0x83A2; ///
enum GL_RGBA_SIGNED_COMPONENTS_EXT = 0x8C3C; ///
enum GL_RGBA_SNORM = 0x8F93; ///
enum GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV = 0x86D9; ///
enum GL_RGB_422_APPLE = 0x8A1F; ///
enum GL_RGB_FLOAT16_APPLE = 0x881B; ///
enum GL_RGB_FLOAT16_ATI = 0x881B; ///
enum GL_RGB_FLOAT32_APPLE = 0x8815; ///
enum GL_RGB_FLOAT32_ATI = 0x8815; ///
enum GL_RGB_INTEGER = 0x8D98; ///
enum GL_RGB_INTEGER_EXT = 0x8D98; ///
enum GL_RGB_RAW_422_APPLE = 0x8A51; ///
enum GL_RGB_S3TC = 0x83A0; ///
enum GL_RGB_SCALE = 0x8573; ///
enum GL_RGB_SCALE_ARB = 0x8573; ///
enum GL_RGB_SCALE_EXT = 0x8573; ///
enum GL_RGB_SNORM = 0x8F92; ///
enum GL_RG_EXT = 0x8227; ///
enum GL_RG_INTEGER = 0x8228; ///
enum GL_RG_SNORM = 0x8F91; ///
enum GL_RIGHT = 0x0407; ///
enum GL_ROUNDED_RECT2_NV = 0xEA; ///
enum GL_ROUNDED_RECT4_NV = 0xEC; ///
enum GL_ROUNDED_RECT8_NV = 0xEE; ///
enum GL_ROUNDED_RECT_NV = 0xE8; ///
enum GL_ROUND_NV = 0x90A4; ///
enum GL_S = 0x2000; ///
enum GL_SAMPLER = 0x82E6; ///
enum GL_SAMPLER_1D = 0x8B5D; ///
enum GL_SAMPLER_1D_ARB = 0x8B5D; ///
enum GL_SAMPLER_1D_ARRAY = 0x8DC0; ///
enum GL_SAMPLER_1D_ARRAY_EXT = 0x8DC0; ///
enum GL_SAMPLER_1D_ARRAY_SHADOW = 0x8DC3; ///
enum GL_SAMPLER_1D_ARRAY_SHADOW_EXT = 0x8DC3; ///
enum GL_SAMPLER_1D_SHADOW = 0x8B61; ///
enum GL_SAMPLER_1D_SHADOW_ARB = 0x8B61; ///
enum GL_SAMPLER_2D = 0x8B5E; ///
enum GL_SAMPLER_2D_ARB = 0x8B5E; ///
enum GL_SAMPLER_2D_ARRAY = 0x8DC1; ///
enum GL_SAMPLER_2D_ARRAY_EXT = 0x8DC1; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW_EXT = 0x8DC4; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW_NV = 0x8DC4; ///
enum GL_SAMPLER_2D_MULTISAMPLE = 0x9108; ///
enum GL_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910B; ///
enum GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910B; ///
enum GL_SAMPLER_2D_RECT = 0x8B63; ///
enum GL_SAMPLER_2D_RECT_ARB = 0x8B63; ///
enum GL_SAMPLER_2D_RECT_SHADOW = 0x8B64; ///
enum GL_SAMPLER_2D_RECT_SHADOW_ARB = 0x8B64; ///
enum GL_SAMPLER_2D_SHADOW = 0x8B62; ///
enum GL_SAMPLER_2D_SHADOW_ARB = 0x8B62; ///
enum GL_SAMPLER_2D_SHADOW_EXT = 0x8B62; ///
enum GL_SAMPLER_3D = 0x8B5F; ///
enum GL_SAMPLER_3D_ARB = 0x8B5F; ///
enum GL_SAMPLER_3D_OES = 0x8B5F; ///
enum GL_SAMPLER_BINDING = 0x8919; ///
enum GL_SAMPLER_BUFFER = 0x8DC2; ///
enum GL_SAMPLER_BUFFER_AMD = 0x9001; ///
enum GL_SAMPLER_BUFFER_EXT = 0x8DC2; ///
enum GL_SAMPLER_BUFFER_OES = 0x8DC2; ///
enum GL_SAMPLER_CUBE = 0x8B60; ///
enum GL_SAMPLER_CUBE_ARB = 0x8B60; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES = 0x900D; ///
enum GL_SAMPLER_CUBE_SHADOW = 0x8DC5; ///
enum GL_SAMPLER_CUBE_SHADOW_EXT = 0x8DC5; ///
enum GL_SAMPLER_CUBE_SHADOW_NV = 0x8DC5; ///
enum GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT = 0x8BE7; ///
enum GL_SAMPLER_EXTERNAL_OES = 0x8D66; ///
enum GL_SAMPLER_KHR = 0x82E6; ///
enum GL_SAMPLER_OBJECT_AMD = 0x9155; ///
enum GL_SAMPLER_RENDERBUFFER_NV = 0x8E56; ///
enum GL_SAMPLES = 0x80A9; ///
enum GL_SAMPLES_3DFX = 0x86B4; ///
enum GL_SAMPLES_ARB = 0x80A9; ///
enum GL_SAMPLES_EXT = 0x80A9; ///
enum GL_SAMPLES_PASSED = 0x8914; ///
enum GL_SAMPLES_PASSED_ARB = 0x8914; ///
enum GL_SAMPLES_SGIS = 0x80A9; ///
enum GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_COVERAGE_ARB = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_MASK_EXT = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_ONE = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_ARB = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_EXT = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F; ///
enum GL_SAMPLE_BUFFERS = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_3DFX = 0x86B3; ///
enum GL_SAMPLE_BUFFERS_ARB = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_EXT = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_SGIS = 0x80A8; ///
enum GL_SAMPLE_COVERAGE = 0x80A0; ///
enum GL_SAMPLE_COVERAGE_ARB = 0x80A0; ///
enum GL_SAMPLE_COVERAGE_INVERT = 0x80AB; ///
enum GL_SAMPLE_COVERAGE_INVERT_ARB = 0x80AB; ///
enum GL_SAMPLE_COVERAGE_VALUE = 0x80AA; ///
enum GL_SAMPLE_COVERAGE_VALUE_ARB = 0x80AA; ///
enum GL_SAMPLE_LOCATION_ARB = 0x8E50; ///
enum GL_SAMPLE_LOCATION_NV = 0x8E50; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB = 0x933F; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV = 0x933F; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB = 0x933E; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV = 0x933E; ///
enum GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB = 0x933D; ///
enum GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV = 0x933D; ///
enum GL_SAMPLE_MASK = 0x8E51; ///
enum GL_SAMPLE_MASK_EXT = 0x80A0; ///
enum GL_SAMPLE_MASK_INVERT_EXT = 0x80AB; ///
enum GL_SAMPLE_MASK_INVERT_SGIS = 0x80AB; ///
enum GL_SAMPLE_MASK_NV = 0x8E51; ///
enum GL_SAMPLE_MASK_SGIS = 0x80A0; ///
enum GL_SAMPLE_MASK_VALUE = 0x8E52; ///
enum GL_SAMPLE_MASK_VALUE_EXT = 0x80AA; ///
enum GL_SAMPLE_MASK_VALUE_NV = 0x8E52; ///
enum GL_SAMPLE_MASK_VALUE_SGIS = 0x80AA; ///
enum GL_SAMPLE_PATTERN_EXT = 0x80AC; ///
enum GL_SAMPLE_PATTERN_SGIS = 0x80AC; ///
enum GL_SAMPLE_POSITION = 0x8E50; ///
enum GL_SAMPLE_POSITION_NV = 0x8E50; ///
enum GL_SAMPLE_SHADING = 0x8C36; ///
enum GL_SAMPLE_SHADING_ARB = 0x8C36; ///
enum GL_SAMPLE_SHADING_OES = 0x8C36; ///
enum GL_SATURATE_BIT_ATI = 0x00000040; ///
enum GL_SCALAR_EXT = 0x87BE; ///
enum GL_SCALEBIAS_HINT_SGIX = 0x8322; ///
enum GL_SCALED_RESOLVE_FASTEST_EXT = 0x90BA; ///
enum GL_SCALED_RESOLVE_NICEST_EXT = 0x90BB; ///
enum GL_SCALE_BY_FOUR_NV = 0x853F; ///
enum GL_SCALE_BY_ONE_HALF_NV = 0x8540; ///
enum GL_SCALE_BY_TWO_NV = 0x853E; ///
enum GL_SCISSOR_BIT = 0x00080000; ///
enum GL_SCISSOR_BOX = 0x0C10; ///
enum GL_SCISSOR_COMMAND_NV = 0x0011; ///
enum GL_SCISSOR_TEST = 0x0C11; ///
enum GL_SCREEN = 0x9295; ///
enum GL_SCREEN_COORDINATES_REND = 0x8490; ///
enum GL_SCREEN_KHR = 0x9295; ///
enum GL_SCREEN_NV = 0x9295; ///
enum GL_SECONDARY_COLOR_ARRAY = 0x845E; ///
enum GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV = 0x8F27; ///
enum GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = 0x889C; ///
enum GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB = 0x889C; ///
enum GL_SECONDARY_COLOR_ARRAY_EXT = 0x845E; ///
enum GL_SECONDARY_COLOR_ARRAY_LENGTH_NV = 0x8F31; ///
enum GL_SECONDARY_COLOR_ARRAY_LIST_IBM = 0x103077; ///
enum GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM = 0x103087; ///
enum GL_SECONDARY_COLOR_ARRAY_POINTER = 0x845D; ///
enum GL_SECONDARY_COLOR_ARRAY_POINTER_EXT = 0x845D; ///
enum GL_SECONDARY_COLOR_ARRAY_SIZE = 0x845A; ///
enum GL_SECONDARY_COLOR_ARRAY_SIZE_EXT = 0x845A; ///
enum GL_SECONDARY_COLOR_ARRAY_STRIDE = 0x845C; ///
enum GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT = 0x845C; ///
enum GL_SECONDARY_COLOR_ARRAY_TYPE = 0x845B; ///
enum GL_SECONDARY_COLOR_ARRAY_TYPE_EXT = 0x845B; ///
enum GL_SECONDARY_COLOR_NV = 0x852D; ///
enum GL_SECONDARY_INTERPOLATOR_ATI = 0x896D; ///
enum GL_SELECT = 0x1C02; ///
enum GL_SELECTION_BUFFER_POINTER = 0x0DF3; ///
enum GL_SELECTION_BUFFER_SIZE = 0x0DF4; ///
enum GL_SEPARABLE_2D = 0x8012; ///
enum GL_SEPARABLE_2D_EXT = 0x8012; ///
enum GL_SEPARATE_ATTRIBS = 0x8C8D; ///
enum GL_SEPARATE_ATTRIBS_EXT = 0x8C8D; ///
enum GL_SEPARATE_ATTRIBS_NV = 0x8C8D; ///
enum GL_SEPARATE_SPECULAR_COLOR = 0x81FA; ///
enum GL_SEPARATE_SPECULAR_COLOR_EXT = 0x81FA; ///
enum GL_SET = 0x150F; ///
enum GL_SET_AMD = 0x874A; ///
enum GL_SGX_BINARY_IMG = 0x8C0A; ///
enum GL_SGX_PROGRAM_BINARY_IMG = 0x9130; ///
enum GL_SHADER = 0x82E1; ///
enum GL_SHADER_BINARY_DMP = 0x9250; ///
enum GL_SHADER_BINARY_FORMATS = 0x8DF8; ///
enum GL_SHADER_BINARY_VIV = 0x8FC4; ///
enum GL_SHADER_COMPILER = 0x8DFA; ///
enum GL_SHADER_CONSISTENT_NV = 0x86DD; ///
enum GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = 0x00000010; ///
enum GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020; ///
enum GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = 0x00000020; ///
enum GL_SHADER_IMAGE_ATOMIC = 0x82A6; ///
enum GL_SHADER_IMAGE_LOAD = 0x82A4; ///
enum GL_SHADER_IMAGE_STORE = 0x82A5; ///
enum GL_SHADER_INCLUDE_ARB = 0x8DAE; ///
enum GL_SHADER_KHR = 0x82E1; ///
enum GL_SHADER_OBJECT_ARB = 0x8B48; ///
enum GL_SHADER_OBJECT_EXT = 0x8B48; ///
enum GL_SHADER_OPERATION_NV = 0x86DF; ///
enum GL_SHADER_PIXEL_LOCAL_STORAGE_EXT = 0x8F64; ///
enum GL_SHADER_SOURCE_LENGTH = 0x8B88; ///
enum GL_SHADER_STORAGE_BARRIER_BIT = 0x00002000; ///
enum GL_SHADER_STORAGE_BLOCK = 0x92E6; ///
enum GL_SHADER_STORAGE_BUFFER = 0x90D2; ///
enum GL_SHADER_STORAGE_BUFFER_BINDING = 0x90D3; ///
enum GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF; ///
enum GL_SHADER_STORAGE_BUFFER_SIZE = 0x90D5; ///
enum GL_SHADER_STORAGE_BUFFER_START = 0x90D4; ///
enum GL_SHADER_TYPE = 0x8B4F; ///
enum GL_SHADE_MODEL = 0x0B54; ///
enum GL_SHADING_LANGUAGE_VERSION = 0x8B8C; ///
enum GL_SHADING_LANGUAGE_VERSION_ARB = 0x8B8C; ///
enum GL_SHADOW_AMBIENT_SGIX = 0x80BF; ///
enum GL_SHADOW_ATTENUATION_EXT = 0x834E; ///
enum GL_SHARED_EDGE_NV = 0xC0; ///
enum GL_SHARED_TEXTURE_PALETTE_EXT = 0x81FB; ///
enum GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 0x80B0; ///
enum GL_SHININESS = 0x1601; ///
enum GL_SHORT = 0x1402; ///
enum GL_SIGNALED = 0x9119; ///
enum GL_SIGNALED_APPLE = 0x9119; ///
enum GL_SIGNED_ALPHA8_NV = 0x8706; ///
enum GL_SIGNED_ALPHA_NV = 0x8705; ///
enum GL_SIGNED_HILO16_NV = 0x86FA; ///
enum GL_SIGNED_HILO8_NV = 0x885F; ///
enum GL_SIGNED_HILO_NV = 0x86F9; ///
enum GL_SIGNED_IDENTITY_NV = 0x853C; ///
enum GL_SIGNED_INTENSITY8_NV = 0x8708; ///
enum GL_SIGNED_INTENSITY_NV = 0x8707; ///
enum GL_SIGNED_LUMINANCE8_ALPHA8_NV = 0x8704; ///
enum GL_SIGNED_LUMINANCE8_NV = 0x8702; ///
enum GL_SIGNED_LUMINANCE_ALPHA_NV = 0x8703; ///
enum GL_SIGNED_LUMINANCE_NV = 0x8701; ///
enum GL_SIGNED_NEGATE_NV = 0x853D; ///
enum GL_SIGNED_NORMALIZED = 0x8F9C; ///
enum GL_SIGNED_RGB8_NV = 0x86FF; ///
enum GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV = 0x870D; ///
enum GL_SIGNED_RGBA8_NV = 0x86FC; ///
enum GL_SIGNED_RGBA_NV = 0x86FB; ///
enum GL_SIGNED_RGB_NV = 0x86FE; ///
enum GL_SIGNED_RGB_UNSIGNED_ALPHA_NV = 0x870C; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = 0x82AC; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = 0x82AE; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = 0x82AD; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = 0x82AF; ///
enum GL_SINGLE_COLOR = 0x81F9; ///
enum GL_SINGLE_COLOR_EXT = 0x81F9; ///
enum GL_SKIP_COMPONENTS1_NV = -6; ///
enum GL_SKIP_COMPONENTS2_NV = -5; ///
enum GL_SKIP_COMPONENTS3_NV = -4; ///
enum GL_SKIP_COMPONENTS4_NV = -3; ///
enum GL_SKIP_DECODE_EXT = 0x8A4A; ///
enum GL_SKIP_MISSING_GLYPH_NV = 0x90A9; ///
enum GL_SLICE_ACCUM_SUN = 0x85CC; ///
enum GL_SLIM10U_SGIX = 0x831E; ///
enum GL_SLIM12S_SGIX = 0x831F; ///
enum GL_SLIM8U_SGIX = 0x831D; ///
enum GL_SLUMINANCE = 0x8C46; ///
enum GL_SLUMINANCE8 = 0x8C47; ///
enum GL_SLUMINANCE8_ALPHA8 = 0x8C45; ///
enum GL_SLUMINANCE8_ALPHA8_EXT = 0x8C45; ///
enum GL_SLUMINANCE8_ALPHA8_NV = 0x8C45; ///
enum GL_SLUMINANCE8_EXT = 0x8C47; ///
enum GL_SLUMINANCE8_NV = 0x8C47; ///
enum GL_SLUMINANCE_ALPHA = 0x8C44; ///
enum GL_SLUMINANCE_ALPHA_EXT = 0x8C44; ///
enum GL_SLUMINANCE_ALPHA_NV = 0x8C44; ///
enum GL_SLUMINANCE_EXT = 0x8C46; ///
enum GL_SLUMINANCE_NV = 0x8C46; ///
enum GL_SMALL_CCW_ARC_TO_NV = 0x12; ///
enum GL_SMALL_CW_ARC_TO_NV = 0x14; ///
enum GL_SMAPHS30_PROGRAM_BINARY_DMP = 0x9251; ///
enum GL_SMAPHS_PROGRAM_BINARY_DMP = 0x9252; ///
enum GL_SMOOTH = 0x1D01; ///
enum GL_SMOOTH_CUBIC_CURVE_TO_NV = 0x10; ///
enum GL_SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23; ///
enum GL_SMOOTH_LINE_WIDTH_RANGE = 0x0B22; ///
enum GL_SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13; ///
enum GL_SMOOTH_POINT_SIZE_RANGE = 0x0B12; ///
enum GL_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0E; ///
enum GL_SM_COUNT_NV = 0x933B; ///
enum GL_SOFTLIGHT = 0x929C; ///
enum GL_SOFTLIGHT_KHR = 0x929C; ///
enum GL_SOFTLIGHT_NV = 0x929C; ///
enum GL_SOURCE0_ALPHA = 0x8588; ///
enum GL_SOURCE0_ALPHA_ARB = 0x8588; ///
enum GL_SOURCE0_ALPHA_EXT = 0x8588; ///
enum GL_SOURCE0_RGB = 0x8580; ///
enum GL_SOURCE0_RGB_ARB = 0x8580; ///
enum GL_SOURCE0_RGB_EXT = 0x8580; ///
enum GL_SOURCE1_ALPHA = 0x8589; ///
enum GL_SOURCE1_ALPHA_ARB = 0x8589; ///
enum GL_SOURCE1_ALPHA_EXT = 0x8589; ///
enum GL_SOURCE1_RGB = 0x8581; ///
enum GL_SOURCE1_RGB_ARB = 0x8581; ///
enum GL_SOURCE1_RGB_EXT = 0x8581; ///
enum GL_SOURCE2_ALPHA = 0x858A; ///
enum GL_SOURCE2_ALPHA_ARB = 0x858A; ///
enum GL_SOURCE2_ALPHA_EXT = 0x858A; ///
enum GL_SOURCE2_RGB = 0x8582; ///
enum GL_SOURCE2_RGB_ARB = 0x8582; ///
enum GL_SOURCE2_RGB_EXT = 0x8582; ///
enum GL_SOURCE3_ALPHA_NV = 0x858B; ///
enum GL_SOURCE3_RGB_NV = 0x8583; ///
enum GL_SPARE0_NV = 0x852E; ///
enum GL_SPARE0_PLUS_SECONDARY_COLOR_NV = 0x8532; ///
enum GL_SPARE1_NV = 0x852F; ///
enum GL_SPARSE_BUFFER_PAGE_SIZE_ARB = 0x82F8; ///
enum GL_SPARSE_STORAGE_BIT_ARB = 0x0400; ///
enum GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB = 0x91A9; ///
enum GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT = 0x91A9; ///
enum GL_SPECULAR = 0x1202; ///
enum GL_SPHERE_MAP = 0x2402; ///
enum GL_SPOT_CUTOFF = 0x1206; ///
enum GL_SPOT_DIRECTION = 0x1204; ///
enum GL_SPOT_EXPONENT = 0x1205; ///
enum GL_SPRITE_AXIAL_SGIX = 0x814C; ///
enum GL_SPRITE_AXIS_SGIX = 0x814A; ///
enum GL_SPRITE_EYE_ALIGNED_SGIX = 0x814E; ///
enum GL_SPRITE_MODE_SGIX = 0x8149; ///
enum GL_SPRITE_OBJECT_ALIGNED_SGIX = 0x814D; ///
enum GL_SPRITE_SGIX = 0x8148; ///
enum GL_SPRITE_TRANSLATION_SGIX = 0x814B; ///
enum GL_SQUARE_NV = 0x90A3; ///
enum GL_SR8_EXT = 0x8FBD; ///
enum GL_SRC0_ALPHA = 0x8588; ///
enum GL_SRC0_RGB = 0x8580; ///
enum GL_SRC1_ALPHA = 0x8589; ///
enum GL_SRC1_ALPHA_EXT = 0x8589; ///
enum GL_SRC1_COLOR = 0x88F9; ///
enum GL_SRC1_COLOR_EXT = 0x88F9; ///
enum GL_SRC1_RGB = 0x8581; ///
enum GL_SRC2_ALPHA = 0x858A; ///
enum GL_SRC2_RGB = 0x8582; ///
enum GL_SRC_ALPHA = 0x0302; ///
enum GL_SRC_ALPHA_SATURATE = 0x0308; ///
enum GL_SRC_ALPHA_SATURATE_EXT = 0x0308; ///
enum GL_SRC_ATOP_NV = 0x928E; ///
enum GL_SRC_COLOR = 0x0300; ///
enum GL_SRC_IN_NV = 0x928A; ///
enum GL_SRC_NV = 0x9286; ///
enum GL_SRC_OUT_NV = 0x928C; ///
enum GL_SRC_OVER_NV = 0x9288; ///
enum GL_SRG8_EXT = 0x8FBE; ///
enum GL_SRGB = 0x8C40; ///
enum GL_SRGB8 = 0x8C41; ///
enum GL_SRGB8_ALPHA8 = 0x8C43; ///
enum GL_SRGB8_ALPHA8_EXT = 0x8C43; ///
enum GL_SRGB8_EXT = 0x8C41; ///
enum GL_SRGB8_NV = 0x8C41; ///
enum GL_SRGB_ALPHA = 0x8C42; ///
enum GL_SRGB_ALPHA_EXT = 0x8C42; ///
enum GL_SRGB_DECODE_ARB = 0x8299; ///
enum GL_SRGB_EXT = 0x8C40; ///
enum GL_SRGB_READ = 0x8297; ///
enum GL_SRGB_WRITE = 0x8298; ///
enum GL_STACK_OVERFLOW = 0x0503; ///
enum GL_STACK_OVERFLOW_KHR = 0x0503; ///
enum GL_STACK_UNDERFLOW = 0x0504; ///
enum GL_STACK_UNDERFLOW_KHR = 0x0504; ///
enum GL_STANDARD_FONT_FORMAT_NV = 0x936C; ///
enum GL_STANDARD_FONT_NAME_NV = 0x9072; ///
enum GL_STATE_RESTORE = 0x8BDC; ///
enum GL_STATIC_ATI = 0x8760; ///
enum GL_STATIC_COPY = 0x88E6; ///
enum GL_STATIC_COPY_ARB = 0x88E6; ///
enum GL_STATIC_DRAW = 0x88E4; ///
enum GL_STATIC_DRAW_ARB = 0x88E4; ///
enum GL_STATIC_READ = 0x88E5; ///
enum GL_STATIC_READ_ARB = 0x88E5; ///
enum GL_STATIC_VERTEX_ARRAY_IBM = 0x103061; ///
enum GL_STENCIL = 0x1802; ///
enum GL_STENCIL_ATTACHMENT = 0x8D20; ///
enum GL_STENCIL_ATTACHMENT_EXT = 0x8D20; ///
enum GL_STENCIL_ATTACHMENT_OES = 0x8D20; ///
enum GL_STENCIL_BACK_FAIL = 0x8801; ///
enum GL_STENCIL_BACK_FAIL_ATI = 0x8801; ///
enum GL_STENCIL_BACK_FUNC = 0x8800; ///
enum GL_STENCIL_BACK_FUNC_ATI = 0x8800; ///
enum GL_STENCIL_BACK_OP_VALUE_AMD = 0x874D; ///
enum GL_STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802; ///
enum GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI = 0x8802; ///
enum GL_STENCIL_BACK_PASS_DEPTH_PASS = 0x8803; ///
enum GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI = 0x8803; ///
enum GL_STENCIL_BACK_REF = 0x8CA3; ///
enum GL_STENCIL_BACK_VALUE_MASK = 0x8CA4; ///
enum GL_STENCIL_BACK_WRITEMASK = 0x8CA5; ///
enum GL_STENCIL_BITS = 0x0D57; ///
enum GL_STENCIL_BUFFER_BIT = 0x00000400; ///
enum GL_STENCIL_BUFFER_BIT0_QCOM = 0x00010000; ///
enum GL_STENCIL_BUFFER_BIT1_QCOM = 0x00020000; ///
enum GL_STENCIL_BUFFER_BIT2_QCOM = 0x00040000; ///
enum GL_STENCIL_BUFFER_BIT3_QCOM = 0x00080000; ///
enum GL_STENCIL_BUFFER_BIT4_QCOM = 0x00100000; ///
enum GL_STENCIL_BUFFER_BIT5_QCOM = 0x00200000; ///
enum GL_STENCIL_BUFFER_BIT6_QCOM = 0x00400000; ///
enum GL_STENCIL_BUFFER_BIT7_QCOM = 0x00800000; ///
enum GL_STENCIL_CLEAR_TAG_VALUE_EXT = 0x88F3; ///
enum GL_STENCIL_CLEAR_VALUE = 0x0B91; ///
enum GL_STENCIL_COMPONENTS = 0x8285; ///
enum GL_STENCIL_EXT = 0x1802; ///
enum GL_STENCIL_FAIL = 0x0B94; ///
enum GL_STENCIL_FUNC = 0x0B92; ///
enum GL_STENCIL_INDEX = 0x1901; ///
enum GL_STENCIL_INDEX1 = 0x8D46; ///
enum GL_STENCIL_INDEX16 = 0x8D49; ///
enum GL_STENCIL_INDEX16_EXT = 0x8D49; ///
enum GL_STENCIL_INDEX1_EXT = 0x8D46; ///
enum GL_STENCIL_INDEX1_OES = 0x8D46; ///
enum GL_STENCIL_INDEX4 = 0x8D47; ///
enum GL_STENCIL_INDEX4_EXT = 0x8D47; ///
enum GL_STENCIL_INDEX4_OES = 0x8D47; ///
enum GL_STENCIL_INDEX8 = 0x8D48; ///
enum GL_STENCIL_INDEX8_EXT = 0x8D48; ///
enum GL_STENCIL_INDEX8_OES = 0x8D48; ///
enum GL_STENCIL_INDEX_OES = 0x1901; ///
enum GL_STENCIL_OP_VALUE_AMD = 0x874C; ///
enum GL_STENCIL_PASS_DEPTH_FAIL = 0x0B95; ///
enum GL_STENCIL_PASS_DEPTH_PASS = 0x0B96; ///
enum GL_STENCIL_REF = 0x0B97; ///
enum GL_STENCIL_REF_COMMAND_NV = 0x000C; ///
enum GL_STENCIL_RENDERABLE = 0x8288; ///
enum GL_STENCIL_SAMPLES_NV = 0x932E; ///
enum GL_STENCIL_TAG_BITS_EXT = 0x88F2; ///
enum GL_STENCIL_TEST = 0x0B90; ///
enum GL_STENCIL_TEST_TWO_SIDE_EXT = 0x8910; ///
enum GL_STENCIL_VALUE_MASK = 0x0B93; ///
enum GL_STENCIL_WRITEMASK = 0x0B98; ///
enum GL_STEREO = 0x0C33; ///
enum GL_STORAGE_CACHED_APPLE = 0x85BE; ///
enum GL_STORAGE_CLIENT_APPLE = 0x85B4; ///
enum GL_STORAGE_PRIVATE_APPLE = 0x85BD; ///
enum GL_STORAGE_SHARED_APPLE = 0x85BF; ///
enum GL_STREAM_COPY = 0x88E2; ///
enum GL_STREAM_COPY_ARB = 0x88E2; ///
enum GL_STREAM_DRAW = 0x88E0; ///
enum GL_STREAM_DRAW_ARB = 0x88E0; ///
enum GL_STREAM_RASTERIZATION_AMD = 0x91A0; ///
enum GL_STREAM_READ = 0x88E1; ///
enum GL_STREAM_READ_ARB = 0x88E1; ///
enum GL_STRICT_DEPTHFUNC_HINT_PGI = 0x1A216; ///
enum GL_STRICT_LIGHTING_HINT_PGI = 0x1A217; ///
enum GL_STRICT_SCISSOR_HINT_PGI = 0x1A218; ///
enum GL_SUBPIXEL_BITS = 0x0D50; ///
enum GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV = 0x9347; ///
enum GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV = 0x9348; ///
enum GL_SUBSAMPLE_DISTANCE_AMD = 0x883F; ///
enum GL_SUBTRACT = 0x84E7; ///
enum GL_SUBTRACT_ARB = 0x84E7; ///
enum GL_SUB_ATI = 0x8965; ///
enum GL_SUCCESS_NV = 0x902F; ///
enum GL_SUPERSAMPLE_SCALE_X_NV = 0x9372; ///
enum GL_SUPERSAMPLE_SCALE_Y_NV = 0x9373; ///
enum GL_SURFACE_MAPPED_NV = 0x8700; ///
enum GL_SURFACE_REGISTERED_NV = 0x86FD; ///
enum GL_SURFACE_STATE_NV = 0x86EB; ///
enum GL_SWIZZLE_STQ_ATI = 0x8977; ///
enum GL_SWIZZLE_STQ_DQ_ATI = 0x8979; ///
enum GL_SWIZZLE_STRQ_ATI = 0x897A; ///
enum GL_SWIZZLE_STRQ_DQ_ATI = 0x897B; ///
enum GL_SWIZZLE_STR_ATI = 0x8976; ///
enum GL_SWIZZLE_STR_DR_ATI = 0x8978; ///
enum GL_SYNC_CL_EVENT_ARB = 0x8240; ///
enum GL_SYNC_CL_EVENT_COMPLETE_ARB = 0x8241; ///
enum GL_SYNC_CONDITION = 0x9113; ///
enum GL_SYNC_CONDITION_APPLE = 0x9113; ///
enum GL_SYNC_FENCE = 0x9116; ///
enum GL_SYNC_FENCE_APPLE = 0x9116; ///
enum GL_SYNC_FLAGS = 0x9115; ///
enum GL_SYNC_FLAGS_APPLE = 0x9115; ///
enum GL_SYNC_FLUSH_COMMANDS_BIT = 0x00000001; ///
enum GL_SYNC_FLUSH_COMMANDS_BIT_APPLE = 0x00000001; ///
enum GL_SYNC_GPU_COMMANDS_COMPLETE = 0x9117; ///
enum GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE = 0x9117; ///
enum GL_SYNC_OBJECT_APPLE = 0x8A53; ///
enum GL_SYNC_STATUS = 0x9114; ///
enum GL_SYNC_STATUS_APPLE = 0x9114; ///
enum GL_SYNC_X11_FENCE_EXT = 0x90E1; ///
enum GL_SYSTEM_FONT_NAME_NV = 0x9073; ///
enum GL_T = 0x2001; ///
enum GL_T2F_C3F_V3F = 0x2A2A; ///
enum GL_T2F_C4F_N3F_V3F = 0x2A2C; ///
enum GL_T2F_C4UB_V3F = 0x2A29; ///
enum GL_T2F_IUI_N3F_V2F_EXT = 0x81B3; ///
enum GL_T2F_IUI_N3F_V3F_EXT = 0x81B4; ///
enum GL_T2F_IUI_V2F_EXT = 0x81B1; ///
enum GL_T2F_IUI_V3F_EXT = 0x81B2; ///
enum GL_T2F_N3F_V3F = 0x2A2B; ///
enum GL_T2F_V3F = 0x2A27; ///
enum GL_T4F_C4F_N3F_V4F = 0x2A2D; ///
enum GL_T4F_V4F = 0x2A28; ///
enum GL_TABLE_TOO_LARGE = 0x8031; ///
enum GL_TABLE_TOO_LARGE_EXT = 0x8031; ///
enum GL_TANGENT_ARRAY_EXT = 0x8439; ///
enum GL_TANGENT_ARRAY_POINTER_EXT = 0x8442; ///
enum GL_TANGENT_ARRAY_STRIDE_EXT = 0x843F; ///
enum GL_TANGENT_ARRAY_TYPE_EXT = 0x843E; ///
enum GL_TERMINATE_SEQUENCE_COMMAND_NV = 0x0000; ///
enum GL_TESSELLATION_FACTOR_AMD = 0x9005; ///
enum GL_TESSELLATION_MODE_AMD = 0x9004; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES = 0x8E75; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES_EXT = 0x8E75; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES_OES = 0x8E75; ///
enum GL_TESS_CONTROL_PROGRAM_NV = 0x891E; ///
enum GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV = 0x8C74; ///
enum GL_TESS_CONTROL_SHADER = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_BIT = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_BIT_EXT = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_BIT_OES = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_EXT = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_OES = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_PATCHES_ARB = 0x82F1; ///
enum GL_TESS_CONTROL_SUBROUTINE = 0x92E9; ///
enum GL_TESS_CONTROL_SUBROUTINE_UNIFORM = 0x92EF; ///
enum GL_TESS_CONTROL_TEXTURE = 0x829C; ///
enum GL_TESS_EVALUATION_PROGRAM_NV = 0x891F; ///
enum GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV = 0x8C75; ///
enum GL_TESS_EVALUATION_SHADER = 0x8E87; ///
enum GL_TESS_EVALUATION_SHADER_BIT = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_BIT_EXT = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_BIT_OES = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_EXT = 0x8E87; ///
enum GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB = 0x82F2; ///
enum GL_TESS_EVALUATION_SHADER_OES = 0x8E87; ///
enum GL_TESS_EVALUATION_SUBROUTINE = 0x92EA; ///
enum GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = 0x92F0; ///
enum GL_TESS_EVALUATION_TEXTURE = 0x829D; ///
enum GL_TESS_GEN_MODE = 0x8E76; ///
enum GL_TESS_GEN_MODE_EXT = 0x8E76; ///
enum GL_TESS_GEN_MODE_OES = 0x8E76; ///
enum GL_TESS_GEN_POINT_MODE = 0x8E79; ///
enum GL_TESS_GEN_POINT_MODE_EXT = 0x8E79; ///
enum GL_TESS_GEN_POINT_MODE_OES = 0x8E79; ///
enum GL_TESS_GEN_SPACING = 0x8E77; ///
enum GL_TESS_GEN_SPACING_EXT = 0x8E77; ///
enum GL_TESS_GEN_SPACING_OES = 0x8E77; ///
enum GL_TESS_GEN_VERTEX_ORDER = 0x8E78; ///
enum GL_TESS_GEN_VERTEX_ORDER_EXT = 0x8E78; ///
enum GL_TESS_GEN_VERTEX_ORDER_OES = 0x8E78; ///
enum GL_TEXCOORD1_BIT_PGI = 0x10000000; ///
enum GL_TEXCOORD2_BIT_PGI = 0x20000000; ///
enum GL_TEXCOORD3_BIT_PGI = 0x40000000; ///
enum GL_TEXCOORD4_BIT_PGI = 0x80000000; ///
enum GL_TEXTURE = 0x1702; ///
enum GL_TEXTURE0 = 0x84C0; ///
enum GL_TEXTURE0_ARB = 0x84C0; ///
enum GL_TEXTURE1 = 0x84C1; ///
enum GL_TEXTURE10 = 0x84CA; ///
enum GL_TEXTURE10_ARB = 0x84CA; ///
enum GL_TEXTURE11 = 0x84CB; ///
enum GL_TEXTURE11_ARB = 0x84CB; ///
enum GL_TEXTURE12 = 0x84CC; ///
enum GL_TEXTURE12_ARB = 0x84CC; ///
enum GL_TEXTURE13 = 0x84CD; ///
enum GL_TEXTURE13_ARB = 0x84CD; ///
enum GL_TEXTURE14 = 0x84CE; ///
enum GL_TEXTURE14_ARB = 0x84CE; ///
enum GL_TEXTURE15 = 0x84CF; ///
enum GL_TEXTURE15_ARB = 0x84CF; ///
enum GL_TEXTURE16 = 0x84D0; ///
enum GL_TEXTURE16_ARB = 0x84D0; ///
enum GL_TEXTURE17 = 0x84D1; ///
enum GL_TEXTURE17_ARB = 0x84D1; ///
enum GL_TEXTURE18 = 0x84D2; ///
enum GL_TEXTURE18_ARB = 0x84D2; ///
enum GL_TEXTURE19 = 0x84D3; ///
enum GL_TEXTURE19_ARB = 0x84D3; ///
enum GL_TEXTURE1_ARB = 0x84C1; ///
enum GL_TEXTURE2 = 0x84C2; ///
enum GL_TEXTURE20 = 0x84D4; ///
enum GL_TEXTURE20_ARB = 0x84D4; ///
enum GL_TEXTURE21 = 0x84D5; ///
enum GL_TEXTURE21_ARB = 0x84D5; ///
enum GL_TEXTURE22 = 0x84D6; ///
enum GL_TEXTURE22_ARB = 0x84D6; ///
enum GL_TEXTURE23 = 0x84D7; ///
enum GL_TEXTURE23_ARB = 0x84D7; ///
enum GL_TEXTURE24 = 0x84D8; ///
enum GL_TEXTURE24_ARB = 0x84D8; ///
enum GL_TEXTURE25 = 0x84D9; ///
enum GL_TEXTURE25_ARB = 0x84D9; ///
enum GL_TEXTURE26 = 0x84DA; ///
enum GL_TEXTURE26_ARB = 0x84DA; ///
enum GL_TEXTURE27 = 0x84DB; ///
enum GL_TEXTURE27_ARB = 0x84DB; ///
enum GL_TEXTURE28 = 0x84DC; ///
enum GL_TEXTURE28_ARB = 0x84DC; ///
enum GL_TEXTURE29 = 0x84DD; ///
enum GL_TEXTURE29_ARB = 0x84DD; ///
enum GL_TEXTURE2_ARB = 0x84C2; ///
enum GL_TEXTURE3 = 0x84C3; ///
enum GL_TEXTURE30 = 0x84DE; ///
enum GL_TEXTURE30_ARB = 0x84DE; ///
enum GL_TEXTURE31 = 0x84DF; ///
enum GL_TEXTURE31_ARB = 0x84DF; ///
enum GL_TEXTURE3_ARB = 0x84C3; ///
enum GL_TEXTURE4 = 0x84C4; ///
enum GL_TEXTURE4_ARB = 0x84C4; ///
enum GL_TEXTURE5 = 0x84C5; ///
enum GL_TEXTURE5_ARB = 0x84C5; ///
enum GL_TEXTURE6 = 0x84C6; ///
enum GL_TEXTURE6_ARB = 0x84C6; ///
enum GL_TEXTURE7 = 0x84C7; ///
enum GL_TEXTURE7_ARB = 0x84C7; ///
enum GL_TEXTURE8 = 0x84C8; ///
enum GL_TEXTURE8_ARB = 0x84C8; ///
enum GL_TEXTURE9 = 0x84C9; ///
enum GL_TEXTURE9_ARB = 0x84C9; ///
enum GL_TEXTURE_1D = 0x0DE0; ///
enum GL_TEXTURE_1D_ARRAY = 0x8C18; ///
enum GL_TEXTURE_1D_ARRAY_EXT = 0x8C18; ///
enum GL_TEXTURE_1D_BINDING_EXT = 0x8068; ///
enum GL_TEXTURE_1D_STACK_BINDING_MESAX = 0x875D; ///
enum GL_TEXTURE_1D_STACK_MESAX = 0x8759; ///
enum GL_TEXTURE_2D = 0x0DE1; ///
enum GL_TEXTURE_2D_ARRAY = 0x8C1A; ///
enum GL_TEXTURE_2D_ARRAY_EXT = 0x8C1A; ///
enum GL_TEXTURE_2D_BINDING_EXT = 0x8069; ///
enum GL_TEXTURE_2D_MULTISAMPLE = 0x9100; ///
enum GL_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9102; ///
enum GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES = 0x9102; ///
enum GL_TEXTURE_2D_STACK_BINDING_MESAX = 0x875E; ///
enum GL_TEXTURE_2D_STACK_MESAX = 0x875A; ///
enum GL_TEXTURE_3D = 0x806F; ///
enum GL_TEXTURE_3D_BINDING_EXT = 0x806A; ///
enum GL_TEXTURE_3D_BINDING_OES = 0x806A; ///
enum GL_TEXTURE_3D_EXT = 0x806F; ///
enum GL_TEXTURE_3D_OES = 0x806F; ///
enum GL_TEXTURE_4DSIZE_SGIS = 0x8136; ///
enum GL_TEXTURE_4D_BINDING_SGIS = 0x814F; ///
enum GL_TEXTURE_4D_SGIS = 0x8134; ///
enum GL_TEXTURE_ALPHA_MODULATE_IMG = 0x8C06; ///
enum GL_TEXTURE_ALPHA_SIZE = 0x805F; ///
enum GL_TEXTURE_ALPHA_SIZE_EXT = 0x805F; ///
enum GL_TEXTURE_ALPHA_TYPE = 0x8C13; ///
enum GL_TEXTURE_ALPHA_TYPE_ARB = 0x8C13; ///
enum GL_TEXTURE_APPLICATION_MODE_EXT = 0x834F; ///
enum GL_TEXTURE_BASE_LEVEL = 0x813C; ///
enum GL_TEXTURE_BASE_LEVEL_SGIS = 0x813C; ///
enum GL_TEXTURE_BINDING_1D = 0x8068; ///
enum GL_TEXTURE_BINDING_1D_ARRAY = 0x8C1C; ///
enum GL_TEXTURE_BINDING_1D_ARRAY_EXT = 0x8C1C; ///
enum GL_TEXTURE_BINDING_2D = 0x8069; ///
enum GL_TEXTURE_BINDING_2D_ARRAY = 0x8C1D; ///
enum GL_TEXTURE_BINDING_2D_ARRAY_EXT = 0x8C1D; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES = 0x9105; ///
enum GL_TEXTURE_BINDING_3D = 0x806A; ///
enum GL_TEXTURE_BINDING_3D_OES = 0x806A; ///
enum GL_TEXTURE_BINDING_BUFFER = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_ARB = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_EXT = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_OES = 0x8C2C; ///
enum GL_TEXTURE_BINDING_CUBE_MAP = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARB = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_EXT = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_OES = 0x8514; ///
enum GL_TEXTURE_BINDING_EXTERNAL_OES = 0x8D67; ///
enum GL_TEXTURE_BINDING_RECTANGLE = 0x84F6; ///
enum GL_TEXTURE_BINDING_RECTANGLE_ARB = 0x84F6; ///
enum GL_TEXTURE_BINDING_RECTANGLE_NV = 0x84F6; ///
enum GL_TEXTURE_BINDING_RENDERBUFFER_NV = 0x8E53; ///
enum GL_TEXTURE_BIT = 0x00040000; ///
enum GL_TEXTURE_BLUE_SIZE = 0x805E; ///
enum GL_TEXTURE_BLUE_SIZE_EXT = 0x805E; ///
enum GL_TEXTURE_BLUE_TYPE = 0x8C12; ///
enum GL_TEXTURE_BLUE_TYPE_ARB = 0x8C12; ///
enum GL_TEXTURE_BORDER = 0x1005; ///
enum GL_TEXTURE_BORDER_COLOR = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_EXT = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_NV = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_OES = 0x1004; ///
enum GL_TEXTURE_BORDER_VALUES_NV = 0x871A; ///
enum GL_TEXTURE_BUFFER = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_ARB = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING_EXT = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING_OES = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_EXT = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_FORMAT_ARB = 0x8C2E; ///
enum GL_TEXTURE_BUFFER_FORMAT_EXT = 0x8C2E; ///
enum GL_TEXTURE_BUFFER_OES = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_OFFSET = 0x919D; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_EXT = 0x919D; ///
enum GL_TEXTURE_BUFFER_OFFSET_OES = 0x919D; ///
enum GL_TEXTURE_BUFFER_SIZE = 0x919E; ///
enum GL_TEXTURE_BUFFER_SIZE_EXT = 0x919E; ///
enum GL_TEXTURE_BUFFER_SIZE_OES = 0x919E; ///
enum GL_TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171; ///
enum GL_TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176; ///
enum GL_TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172; ///
enum GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175; ///
enum GL_TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173; ///
enum GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174; ///
enum GL_TEXTURE_COLOR_SAMPLES_NV = 0x9046; ///
enum GL_TEXTURE_COLOR_TABLE_SGI = 0x80BC; ///
enum GL_TEXTURE_COLOR_WRITEMASK_SGIS = 0x81EF; ///
enum GL_TEXTURE_COMPARE_FAIL_VALUE_ARB = 0x80BF; ///
enum GL_TEXTURE_COMPARE_FUNC = 0x884D; ///
enum GL_TEXTURE_COMPARE_FUNC_ARB = 0x884D; ///
enum GL_TEXTURE_COMPARE_FUNC_EXT = 0x884D; ///
enum GL_TEXTURE_COMPARE_MODE = 0x884C; ///
enum GL_TEXTURE_COMPARE_MODE_ARB = 0x884C; ///
enum GL_TEXTURE_COMPARE_MODE_EXT = 0x884C; ///
enum GL_TEXTURE_COMPARE_OPERATOR_SGIX = 0x819B; ///
enum GL_TEXTURE_COMPARE_SGIX = 0x819A; ///
enum GL_TEXTURE_COMPONENTS = 0x1003; ///
enum GL_TEXTURE_COMPRESSED = 0x86A1; ///
enum GL_TEXTURE_COMPRESSED_ARB = 0x86A1; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = 0x82B2; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_SIZE = 0x82B3; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = 0x82B1; ///
enum GL_TEXTURE_COMPRESSED_IMAGE_SIZE = 0x86A0; ///
enum GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB = 0x86A0; ///
enum GL_TEXTURE_COMPRESSION_HINT = 0x84EF; ///
enum GL_TEXTURE_COMPRESSION_HINT_ARB = 0x84EF; ///
enum GL_TEXTURE_CONSTANT_DATA_SUNX = 0x81D6; ///
enum GL_TEXTURE_COORD_ARRAY = 0x8078; ///
enum GL_TEXTURE_COORD_ARRAY_ADDRESS_NV = 0x8F25; ///
enum GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING = 0x889A; ///
enum GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB = 0x889A; ///
enum GL_TEXTURE_COORD_ARRAY_COUNT_EXT = 0x808B; ///
enum GL_TEXTURE_COORD_ARRAY_EXT = 0x8078; ///
enum GL_TEXTURE_COORD_ARRAY_LENGTH_NV = 0x8F2F; ///
enum GL_TEXTURE_COORD_ARRAY_LIST_IBM = 0x103074; ///
enum GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM = 0x103084; ///
enum GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F8; ///
enum GL_TEXTURE_COORD_ARRAY_POINTER = 0x8092; ///
enum GL_TEXTURE_COORD_ARRAY_POINTER_EXT = 0x8092; ///
enum GL_TEXTURE_COORD_ARRAY_SIZE = 0x8088; ///
enum GL_TEXTURE_COORD_ARRAY_SIZE_EXT = 0x8088; ///
enum GL_TEXTURE_COORD_ARRAY_STRIDE = 0x808A; ///
enum GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = 0x808A; ///
enum GL_TEXTURE_COORD_ARRAY_TYPE = 0x8089; ///
enum GL_TEXTURE_COORD_ARRAY_TYPE_EXT = 0x8089; ///
enum GL_TEXTURE_COORD_NV = 0x8C79; ///
enum GL_TEXTURE_COVERAGE_SAMPLES_NV = 0x9045; ///
enum GL_TEXTURE_CROP_RECT_OES = 0x8B9D; ///
enum GL_TEXTURE_CUBE_MAP = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_ARB = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_EXT = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_OES = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_EXT = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_OES = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_SEAMLESS = 0x884F; ///
enum GL_TEXTURE_DEFORMATION_BIT_SGIX = 0x00000001; ///
enum GL_TEXTURE_DEFORMATION_SGIX = 0x8195; ///
enum GL_TEXTURE_DEPTH = 0x8071; ///
enum GL_TEXTURE_DEPTH_EXT = 0x8071; ///
enum GL_TEXTURE_DEPTH_QCOM = 0x8BD4; ///
enum GL_TEXTURE_DEPTH_SIZE = 0x884A; ///
enum GL_TEXTURE_DEPTH_SIZE_ARB = 0x884A; ///
enum GL_TEXTURE_DEPTH_TYPE = 0x8C16; ///
enum GL_TEXTURE_DEPTH_TYPE_ARB = 0x8C16; ///
enum GL_TEXTURE_DS_SIZE_NV = 0x871D; ///
enum GL_TEXTURE_DT_SIZE_NV = 0x871E; ///
enum GL_TEXTURE_ENV = 0x2300; ///
enum GL_TEXTURE_ENV_BIAS_SGIX = 0x80BE; ///
enum GL_TEXTURE_ENV_COLOR = 0x2201; ///
enum GL_TEXTURE_ENV_MODE = 0x2200; ///
enum GL_TEXTURE_EXTERNAL_OES = 0x8D65; ///
enum GL_TEXTURE_FETCH_BARRIER_BIT = 0x00000008; ///
enum GL_TEXTURE_FETCH_BARRIER_BIT_EXT = 0x00000008; ///
enum GL_TEXTURE_FILTER4_SIZE_SGIS = 0x8147; ///
enum GL_TEXTURE_FILTER_CONTROL = 0x8500; ///
enum GL_TEXTURE_FILTER_CONTROL_EXT = 0x8500; ///
enum GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107; ///
enum GL_TEXTURE_FLOAT_COMPONENTS_NV = 0x888C; ///
enum GL_TEXTURE_FORMAT_QCOM = 0x8BD6; ///
enum GL_TEXTURE_FREE_MEMORY_ATI = 0x87FC; ///
enum GL_TEXTURE_GATHER = 0x82A2; ///
enum GL_TEXTURE_GATHER_SHADOW = 0x82A3; ///
enum GL_TEXTURE_GEN_MODE = 0x2500; ///
enum GL_TEXTURE_GEN_MODE_OES = 0x2500; ///
enum GL_TEXTURE_GEN_Q = 0x0C63; ///
enum GL_TEXTURE_GEN_R = 0x0C62; ///
enum GL_TEXTURE_GEN_S = 0x0C60; ///
enum GL_TEXTURE_GEN_STR_OES = 0x8D60; ///
enum GL_TEXTURE_GEN_T = 0x0C61; ///
enum GL_TEXTURE_GEQUAL_R_SGIX = 0x819D; ///
enum GL_TEXTURE_GREEN_SIZE = 0x805D; ///
enum GL_TEXTURE_GREEN_SIZE_EXT = 0x805D; ///
enum GL_TEXTURE_GREEN_TYPE = 0x8C11; ///
enum GL_TEXTURE_GREEN_TYPE_ARB = 0x8C11; ///
enum GL_TEXTURE_HEIGHT = 0x1001; ///
enum GL_TEXTURE_HEIGHT_QCOM = 0x8BD3; ///
enum GL_TEXTURE_HI_SIZE_NV = 0x871B; ///
enum GL_TEXTURE_IMAGE_FORMAT = 0x828F; ///
enum GL_TEXTURE_IMAGE_TYPE = 0x8290; ///
enum GL_TEXTURE_IMAGE_VALID_QCOM = 0x8BD8; ///
enum GL_TEXTURE_IMMUTABLE_FORMAT = 0x912F; ///
enum GL_TEXTURE_IMMUTABLE_FORMAT_EXT = 0x912F; ///
enum GL_TEXTURE_IMMUTABLE_LEVELS = 0x82DF; ///
enum GL_TEXTURE_INDEX_SIZE_EXT = 0x80ED; ///
enum GL_TEXTURE_INTENSITY_SIZE = 0x8061; ///
enum GL_TEXTURE_INTENSITY_SIZE_EXT = 0x8061; ///
enum GL_TEXTURE_INTENSITY_TYPE = 0x8C15; ///
enum GL_TEXTURE_INTENSITY_TYPE_ARB = 0x8C15; ///
enum GL_TEXTURE_INTERNAL_FORMAT = 0x1003; ///
enum GL_TEXTURE_INTERNAL_FORMAT_QCOM = 0x8BD5; ///
enum GL_TEXTURE_LEQUAL_R_SGIX = 0x819C; ///
enum GL_TEXTURE_LIGHTING_MODE_HP = 0x8167; ///
enum GL_TEXTURE_LIGHT_EXT = 0x8350; ///
enum GL_TEXTURE_LOD_BIAS = 0x8501; ///
enum GL_TEXTURE_LOD_BIAS_EXT = 0x8501; ///
enum GL_TEXTURE_LOD_BIAS_R_SGIX = 0x8190; ///
enum GL_TEXTURE_LOD_BIAS_S_SGIX = 0x818E; ///
enum GL_TEXTURE_LOD_BIAS_T_SGIX = 0x818F; ///
enum GL_TEXTURE_LO_SIZE_NV = 0x871C; ///
enum GL_TEXTURE_LUMINANCE_SIZE = 0x8060; ///
enum GL_TEXTURE_LUMINANCE_SIZE_EXT = 0x8060; ///
enum GL_TEXTURE_LUMINANCE_TYPE = 0x8C14; ///
enum GL_TEXTURE_LUMINANCE_TYPE_ARB = 0x8C14; ///
enum GL_TEXTURE_MAG_FILTER = 0x2800; ///
enum GL_TEXTURE_MAG_SIZE_NV = 0x871F; ///
enum GL_TEXTURE_MATERIAL_FACE_EXT = 0x8351; ///
enum GL_TEXTURE_MATERIAL_PARAMETER_EXT = 0x8352; ///
enum GL_TEXTURE_MATRIX = 0x0BA8; ///
enum GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898F; ///
enum GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE; ///
enum GL_TEXTURE_MAX_CLAMP_R_SGIX = 0x836B; ///
enum GL_TEXTURE_MAX_CLAMP_S_SGIX = 0x8369; ///
enum GL_TEXTURE_MAX_CLAMP_T_SGIX = 0x836A; ///
enum GL_TEXTURE_MAX_LEVEL = 0x813D; ///
enum GL_TEXTURE_MAX_LEVEL_APPLE = 0x813D; ///
enum GL_TEXTURE_MAX_LEVEL_SGIS = 0x813D; ///
enum GL_TEXTURE_MAX_LOD = 0x813B; ///
enum GL_TEXTURE_MAX_LOD_SGIS = 0x813B; ///
enum GL_TEXTURE_MEMORY_LAYOUT_INTEL = 0x83FF; ///
enum GL_TEXTURE_MIN_FILTER = 0x2801; ///
enum GL_TEXTURE_MIN_LOD = 0x813A; ///
enum GL_TEXTURE_MIN_LOD_SGIS = 0x813A; ///
enum GL_TEXTURE_MULTI_BUFFER_HINT_SGIX = 0x812E; ///
enum GL_TEXTURE_NORMAL_EXT = 0x85AF; ///
enum GL_TEXTURE_NUM_LEVELS_QCOM = 0x8BD9; ///
enum GL_TEXTURE_OBJECT_VALID_QCOM = 0x8BDB; ///
enum GL_TEXTURE_POST_SPECULAR_HP = 0x8168; ///
enum GL_TEXTURE_PRE_SPECULAR_HP = 0x8169; ///
enum GL_TEXTURE_PRIORITY = 0x8066; ///
enum GL_TEXTURE_PRIORITY_EXT = 0x8066; ///
enum GL_TEXTURE_PROTECTED_EXT = 0x8BFA; ///
enum GL_TEXTURE_RANGE_LENGTH_APPLE = 0x85B7; ///
enum GL_TEXTURE_RANGE_POINTER_APPLE = 0x85B8; ///
enum GL_TEXTURE_RECTANGLE = 0x84F5; ///
enum GL_TEXTURE_RECTANGLE_ARB = 0x84F5; ///
enum GL_TEXTURE_RECTANGLE_NV = 0x84F5; ///
enum GL_TEXTURE_REDUCTION_MODE_ARB = 0x9366; ///
enum GL_TEXTURE_RED_SIZE = 0x805C; ///
enum GL_TEXTURE_RED_SIZE_EXT = 0x805C; ///
enum GL_TEXTURE_RED_TYPE = 0x8C10; ///
enum GL_TEXTURE_RED_TYPE_ARB = 0x8C10; ///
enum GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV = 0x8E54; ///
enum GL_TEXTURE_RENDERBUFFER_NV = 0x8E55; ///
enum GL_TEXTURE_RESIDENT = 0x8067; ///
enum GL_TEXTURE_RESIDENT_EXT = 0x8067; ///
enum GL_TEXTURE_SAMPLES = 0x9106; ///
enum GL_TEXTURE_SAMPLES_IMG = 0x9136; ///
enum GL_TEXTURE_SHADER_NV = 0x86DE; ///
enum GL_TEXTURE_SHADOW = 0x82A1; ///
enum GL_TEXTURE_SHARED_SIZE = 0x8C3F; ///
enum GL_TEXTURE_SHARED_SIZE_EXT = 0x8C3F; ///
enum GL_TEXTURE_SPARSE_ARB = 0x91A6; ///
enum GL_TEXTURE_SPARSE_EXT = 0x91A6; ///
enum GL_TEXTURE_SRGB_DECODE_EXT = 0x8A48; ///
enum GL_TEXTURE_STACK_DEPTH = 0x0BA5; ///
enum GL_TEXTURE_STENCIL_SIZE = 0x88F1; ///
enum GL_TEXTURE_STENCIL_SIZE_EXT = 0x88F1; ///
enum GL_TEXTURE_STORAGE_HINT_APPLE = 0x85BC; ///
enum GL_TEXTURE_STORAGE_SPARSE_BIT_AMD = 0x00000001; ///
enum GL_TEXTURE_SWIZZLE_A = 0x8E45; ///
enum GL_TEXTURE_SWIZZLE_A_EXT = 0x8E45; ///
enum GL_TEXTURE_SWIZZLE_B = 0x8E44; ///
enum GL_TEXTURE_SWIZZLE_B_EXT = 0x8E44; ///
enum GL_TEXTURE_SWIZZLE_G = 0x8E43; ///
enum GL_TEXTURE_SWIZZLE_G_EXT = 0x8E43; ///
enum GL_TEXTURE_SWIZZLE_R = 0x8E42; ///
enum GL_TEXTURE_SWIZZLE_RGBA = 0x8E46; ///
enum GL_TEXTURE_SWIZZLE_RGBA_EXT = 0x8E46; ///
enum GL_TEXTURE_SWIZZLE_R_EXT = 0x8E42; ///
enum GL_TEXTURE_TARGET = 0x1006; ///
enum GL_TEXTURE_TARGET_QCOM = 0x8BDA; ///
enum GL_TEXTURE_TOO_LARGE_EXT = 0x8065; ///
enum GL_TEXTURE_TYPE_QCOM = 0x8BD7; ///
enum GL_TEXTURE_UNSIGNED_REMAP_MODE_NV = 0x888F; ///
enum GL_TEXTURE_UPDATE_BARRIER_BIT = 0x00000100; ///
enum GL_TEXTURE_UPDATE_BARRIER_BIT_EXT = 0x00000100; ///
enum GL_TEXTURE_USAGE_ANGLE = 0x93A2; ///
enum GL_TEXTURE_VIEW = 0x82B5; ///
enum GL_TEXTURE_VIEW_MIN_LAYER = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LAYER_EXT = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LAYER_OES = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL = 0x82DB; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL_EXT = 0x82DB; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL_OES = 0x82DB; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS_EXT = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS_OES = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS = 0x82DC; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS_EXT = 0x82DC; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS_OES = 0x82DC; ///
enum GL_TEXTURE_WIDTH = 0x1000; ///
enum GL_TEXTURE_WIDTH_QCOM = 0x8BD2; ///
enum GL_TEXTURE_WRAP_Q_SGIS = 0x8137; ///
enum GL_TEXTURE_WRAP_R = 0x8072; ///
enum GL_TEXTURE_WRAP_R_EXT = 0x8072; ///
enum GL_TEXTURE_WRAP_R_OES = 0x8072; ///
enum GL_TEXTURE_WRAP_S = 0x2802; ///
enum GL_TEXTURE_WRAP_T = 0x2803; ///
enum GL_TEXT_FRAGMENT_SHADER_ATI = 0x8200; ///
enum GL_TIMEOUT_EXPIRED = 0x911B; ///
enum GL_TIMEOUT_EXPIRED_APPLE = 0x911B; ///
enum GL_TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF; ///
enum GL_TIMEOUT_IGNORED_APPLE = 0xFFFFFFFFFFFFFFFF; ///
enum GL_TIMESTAMP = 0x8E28; ///
enum GL_TIMESTAMP_EXT = 0x8E28; ///
enum GL_TIME_ELAPSED = 0x88BF; ///
enum GL_TIME_ELAPSED_EXT = 0x88BF; ///
enum GL_TOP_LEVEL_ARRAY_SIZE = 0x930C; ///
enum GL_TOP_LEVEL_ARRAY_STRIDE = 0x930D; ///
enum GL_TRACE_ALL_BITS_MESA = 0xFFFF; ///
enum GL_TRACE_ARRAYS_BIT_MESA = 0x0004; ///
enum GL_TRACE_ERRORS_BIT_MESA = 0x0020; ///
enum GL_TRACE_MASK_MESA = 0x8755; ///
enum GL_TRACE_NAME_MESA = 0x8756; ///
enum GL_TRACE_OPERATIONS_BIT_MESA = 0x0001; ///
enum GL_TRACE_PIXELS_BIT_MESA = 0x0010; ///
enum GL_TRACE_PRIMITIVES_BIT_MESA = 0x0002; ///
enum GL_TRACE_TEXTURES_BIT_MESA = 0x0008; ///
enum GL_TRACK_MATRIX_NV = 0x8648; ///
enum GL_TRACK_MATRIX_TRANSFORM_NV = 0x8649; ///
enum GL_TRANSFORM_BIT = 0x00001000; ///
enum GL_TRANSFORM_FEEDBACK = 0x8E22; ///
enum GL_TRANSFORM_FEEDBACK_ACTIVE = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_ATTRIBS_NV = 0x8C7E; ///
enum GL_TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800; ///
enum GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = 0x00000800; ///
enum GL_TRANSFORM_FEEDBACK_BINDING = 0x8E25; ///
enum GL_TRANSFORM_FEEDBACK_BINDING_NV = 0x8E25; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_EXT = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = 0x934B; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_NV = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START_NV = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = 0x934C; ///
enum GL_TRANSFORM_FEEDBACK_NV = 0x8E22; ///
enum GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB = 0x82EC; ///
enum GL_TRANSFORM_FEEDBACK_PAUSED = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_RECORD_NV = 0x8C86; ///
enum GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB = 0x82ED; ///
enum GL_TRANSFORM_FEEDBACK_VARYING = 0x92F4; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS_EXT = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS_NV = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76; ///
enum GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT = 0x8C76; ///
enum GL_TRANSFORM_HINT_APPLE = 0x85B1; ///
enum GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = 0x93A0; ///
enum GL_TRANSLATE_2D_NV = 0x9090; ///
enum GL_TRANSLATE_3D_NV = 0x9091; ///
enum GL_TRANSLATE_X_NV = 0x908E; ///
enum GL_TRANSLATE_Y_NV = 0x908F; ///
enum GL_TRANSPOSE_AFFINE_2D_NV = 0x9096; ///
enum GL_TRANSPOSE_AFFINE_3D_NV = 0x9098; ///
enum GL_TRANSPOSE_COLOR_MATRIX = 0x84E6; ///
enum GL_TRANSPOSE_COLOR_MATRIX_ARB = 0x84E6; ///
enum GL_TRANSPOSE_CURRENT_MATRIX_ARB = 0x88B7; ///
enum GL_TRANSPOSE_MODELVIEW_MATRIX = 0x84E3; ///
enum GL_TRANSPOSE_MODELVIEW_MATRIX_ARB = 0x84E3; ///
enum GL_TRANSPOSE_NV = 0x862C; ///
enum GL_TRANSPOSE_PROGRAM_MATRIX_EXT = 0x8E2E; ///
enum GL_TRANSPOSE_PROJECTION_MATRIX = 0x84E4; ///
enum GL_TRANSPOSE_PROJECTION_MATRIX_ARB = 0x84E4; ///
enum GL_TRANSPOSE_TEXTURE_MATRIX = 0x84E5; ///
enum GL_TRANSPOSE_TEXTURE_MATRIX_ARB = 0x84E5; ///
enum GL_TRIANGLES = 0x0004; ///
enum GL_TRIANGLES_ADJACENCY = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_ARB = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_EXT = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_OES = 0x000C; ///
enum GL_TRIANGLE_FAN = 0x0006; ///
enum GL_TRIANGLE_LIST_SUN = 0x81D7; ///
enum GL_TRIANGLE_MESH_SUN = 0x8615; ///
enum GL_TRIANGLE_STRIP = 0x0005; ///
enum GL_TRIANGLE_STRIP_ADJACENCY = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_ARB = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_EXT = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_OES = 0x000D; ///
enum GL_TRIANGULAR_NV = 0x90A5; ///
enum GL_TRUE = 1; ///
enum GL_TYPE = 0x92FA; ///
enum GL_UNCORRELATED_NV = 0x9282; ///
enum GL_UNDEFINED_APPLE = 0x8A1C; ///
enum GL_UNDEFINED_VERTEX = 0x8260; ///
enum GL_UNDEFINED_VERTEX_EXT = 0x8260; ///
enum GL_UNDEFINED_VERTEX_OES = 0x8260; ///
enum GL_UNIFORM = 0x92E1; ///
enum GL_UNIFORM_ADDRESS_COMMAND_NV = 0x000A; ///
enum GL_UNIFORM_ARRAY_STRIDE = 0x8A3C; ///
enum GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA; ///
enum GL_UNIFORM_BARRIER_BIT = 0x00000004; ///
enum GL_UNIFORM_BARRIER_BIT_EXT = 0x00000004; ///
enum GL_UNIFORM_BLOCK = 0x92E2; ///
enum GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42; ///
enum GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43; ///
enum GL_UNIFORM_BLOCK_BINDING = 0x8A3F; ///
enum GL_UNIFORM_BLOCK_DATA_SIZE = 0x8A40; ///
enum GL_UNIFORM_BLOCK_INDEX = 0x8A3A; ///
enum GL_UNIFORM_BLOCK_NAME_LENGTH = 0x8A41; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = 0x90EC; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44; ///
enum GL_UNIFORM_BUFFER = 0x8A11; ///
enum GL_UNIFORM_BUFFER_ADDRESS_NV = 0x936F; ///
enum GL_UNIFORM_BUFFER_BINDING = 0x8A28; ///
enum GL_UNIFORM_BUFFER_BINDING_EXT = 0x8DEF; ///
enum GL_UNIFORM_BUFFER_EXT = 0x8DEE; ///
enum GL_UNIFORM_BUFFER_LENGTH_NV = 0x9370; ///
enum GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34; ///
enum GL_UNIFORM_BUFFER_SIZE = 0x8A2A; ///
enum GL_UNIFORM_BUFFER_START = 0x8A29; ///
enum GL_UNIFORM_BUFFER_UNIFIED_NV = 0x936E; ///
enum GL_UNIFORM_IS_ROW_MAJOR = 0x8A3E; ///
enum GL_UNIFORM_MATRIX_STRIDE = 0x8A3D; ///
enum GL_UNIFORM_NAME_LENGTH = 0x8A39; ///
enum GL_UNIFORM_OFFSET = 0x8A3B; ///
enum GL_UNIFORM_SIZE = 0x8A38; ///
enum GL_UNIFORM_TYPE = 0x8A37; ///
enum GL_UNKNOWN_CONTEXT_RESET = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_ARB = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_EXT = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_KHR = 0x8255; ///
enum GL_UNPACK_ALIGNMENT = 0x0CF5; ///
enum GL_UNPACK_CLIENT_STORAGE_APPLE = 0x85B2; ///
enum GL_UNPACK_CMYK_HINT_EXT = 0x800F; ///
enum GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243; ///
enum GL_UNPACK_COMPRESSED_BLOCK_DEPTH = 0x9129; ///
enum GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128; ///
enum GL_UNPACK_COMPRESSED_BLOCK_SIZE = 0x912A; ///
enum GL_UNPACK_COMPRESSED_BLOCK_WIDTH = 0x9127; ///
enum GL_UNPACK_COMPRESSED_SIZE_SGIX = 0x831A; ///
enum GL_UNPACK_CONSTANT_DATA_SUNX = 0x81D5; ///
enum GL_UNPACK_FLIP_Y_WEBGL = 0x9240; ///
enum GL_UNPACK_IMAGE_DEPTH_SGIS = 0x8133; ///
enum GL_UNPACK_IMAGE_HEIGHT = 0x806E; ///
enum GL_UNPACK_IMAGE_HEIGHT_EXT = 0x806E; ///
enum GL_UNPACK_LSB_FIRST = 0x0CF1; ///
enum GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241; ///
enum GL_UNPACK_RESAMPLE_OML = 0x8985; ///
enum GL_UNPACK_RESAMPLE_SGIX = 0x842F; ///
enum GL_UNPACK_ROW_BYTES_APPLE = 0x8A16; ///
enum GL_UNPACK_ROW_LENGTH = 0x0CF2; ///
enum GL_UNPACK_ROW_LENGTH_EXT = 0x0CF2; ///
enum GL_UNPACK_SKIP_IMAGES = 0x806D; ///
enum GL_UNPACK_SKIP_IMAGES_EXT = 0x806D; ///
enum GL_UNPACK_SKIP_PIXELS = 0x0CF4; ///
enum GL_UNPACK_SKIP_PIXELS_EXT = 0x0CF4; ///
enum GL_UNPACK_SKIP_ROWS = 0x0CF3; ///
enum GL_UNPACK_SKIP_ROWS_EXT = 0x0CF3; ///
enum GL_UNPACK_SKIP_VOLUMES_SGIS = 0x8132; ///
enum GL_UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1; ///
enum GL_UNPACK_SWAP_BYTES = 0x0CF0; ///
enum GL_UNSIGNALED = 0x9118; ///
enum GL_UNSIGNALED_APPLE = 0x9118; ///
enum GL_UNSIGNED_BYTE = 0x1401; ///
enum GL_UNSIGNED_BYTE_2_3_3_REV = 0x8362; ///
enum GL_UNSIGNED_BYTE_2_3_3_REV_EXT = 0x8362; ///
enum GL_UNSIGNED_BYTE_3_3_2 = 0x8032; ///
enum GL_UNSIGNED_BYTE_3_3_2_EXT = 0x8032; ///
enum GL_UNSIGNED_IDENTITY_NV = 0x8536; ///
enum GL_UNSIGNED_INT = 0x1405; ///
enum GL_UNSIGNED_INT16_NV = 0x8FF0; ///
enum GL_UNSIGNED_INT16_VEC2_NV = 0x8FF1; ///
enum GL_UNSIGNED_INT16_VEC3_NV = 0x8FF2; ///
enum GL_UNSIGNED_INT16_VEC4_NV = 0x8FF3; ///
enum GL_UNSIGNED_INT64_AMD = 0x8BC2; ///
enum GL_UNSIGNED_INT64_ARB = 0x140F; ///
enum GL_UNSIGNED_INT64_NV = 0x140F; ///
enum GL_UNSIGNED_INT64_VEC2_ARB = 0x8FF5; ///
enum GL_UNSIGNED_INT64_VEC2_NV = 0x8FF5; ///
enum GL_UNSIGNED_INT64_VEC3_ARB = 0x8FF6; ///
enum GL_UNSIGNED_INT64_VEC3_NV = 0x8FF6; ///
enum GL_UNSIGNED_INT64_VEC4_ARB = 0x8FF7; ///
enum GL_UNSIGNED_INT64_VEC4_NV = 0x8FF7; ///
enum GL_UNSIGNED_INT8_NV = 0x8FEC; ///
enum GL_UNSIGNED_INT8_VEC2_NV = 0x8FED; ///
enum GL_UNSIGNED_INT8_VEC3_NV = 0x8FEE; ///
enum GL_UNSIGNED_INT8_VEC4_NV = 0x8FEF; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE = 0x8C3B; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV_EXT = 0x8C3B; ///
enum GL_UNSIGNED_INT_10_10_10_2 = 0x8036; ///
enum GL_UNSIGNED_INT_10_10_10_2_EXT = 0x8036; ///
enum GL_UNSIGNED_INT_10_10_10_2_OES = 0x8DF6; ///
enum GL_UNSIGNED_INT_24_8 = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_EXT = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_MESA = 0x8751; ///
enum GL_UNSIGNED_INT_24_8_NV = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_OES = 0x84FA; ///
enum GL_UNSIGNED_INT_2_10_10_10_REV = 0x8368; ///
enum GL_UNSIGNED_INT_2_10_10_10_REV_EXT = 0x8368; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV = 0x8C3E; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV_APPLE = 0x8C3E; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV_EXT = 0x8C3E; ///
enum GL_UNSIGNED_INT_8_24_REV_MESA = 0x8752; ///
enum GL_UNSIGNED_INT_8_8_8_8 = 0x8035; ///
enum GL_UNSIGNED_INT_8_8_8_8_EXT = 0x8035; ///
enum GL_UNSIGNED_INT_8_8_8_8_REV = 0x8367; ///
enum GL_UNSIGNED_INT_8_8_8_8_REV_EXT = 0x8367; ///
enum GL_UNSIGNED_INT_8_8_S8_S8_REV_NV = 0x86DB; ///
enum GL_UNSIGNED_INT_ATOMIC_COUNTER = 0x92DB; ///
enum GL_UNSIGNED_INT_IMAGE_1D = 0x9062; ///
enum GL_UNSIGNED_INT_IMAGE_1D_ARRAY = 0x9068; ///
enum GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT = 0x9068; ///
enum GL_UNSIGNED_INT_IMAGE_1D_EXT = 0x9062; ///
enum GL_UNSIGNED_INT_IMAGE_2D = 0x9063; ///
enum GL_UNSIGNED_INT_IMAGE_2D_ARRAY = 0x9069; ///
enum GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT = 0x9069; ///
enum GL_UNSIGNED_INT_IMAGE_2D_EXT = 0x9063; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x906C; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT = 0x906B; ///
enum GL_UNSIGNED_INT_IMAGE_2D_RECT = 0x9065; ///
enum GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT = 0x9065; ///
enum GL_UNSIGNED_INT_IMAGE_3D = 0x9064; ///
enum GL_UNSIGNED_INT_IMAGE_3D_EXT = 0x9064; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER_EXT = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER_OES = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE = 0x9066; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_EXT = 0x9066; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x906A; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x906A; ///
enum GL_UNSIGNED_INT_S8_S8_8_8_NV = 0x86DA; ///
enum GL_UNSIGNED_INT_SAMPLER_1D = 0x8DD1; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_ARRAY = 0x8DD6; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT = 0x8DD6; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_EXT = 0x8DD1; ///
enum GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT = 0x8DD7; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_EXT = 0x8DD2; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910D; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_RECT = 0x8DD5; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT = 0x8DD5; ///
enum GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3; ///
enum GL_UNSIGNED_INT_SAMPLER_3D_EXT = 0x8DD3; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD = 0x9003; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_OES = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_EXT = 0x8DD4; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV = 0x8E58; ///
enum GL_UNSIGNED_INT_VEC2 = 0x8DC6; ///
enum GL_UNSIGNED_INT_VEC2_EXT = 0x8DC6; ///
enum GL_UNSIGNED_INT_VEC3 = 0x8DC7; ///
enum GL_UNSIGNED_INT_VEC3_EXT = 0x8DC7; ///
enum GL_UNSIGNED_INT_VEC4 = 0x8DC8; ///
enum GL_UNSIGNED_INT_VEC4_EXT = 0x8DC8; ///
enum GL_UNSIGNED_INVERT_NV = 0x8537; ///
enum GL_UNSIGNED_NORMALIZED = 0x8C17; ///
enum GL_UNSIGNED_NORMALIZED_ARB = 0x8C17; ///
enum GL_UNSIGNED_NORMALIZED_EXT = 0x8C17; ///
enum GL_UNSIGNED_SHORT = 0x1403; ///
enum GL_UNSIGNED_SHORT_15_1_MESA = 0x8753; ///
enum GL_UNSIGNED_SHORT_1_15_REV_MESA = 0x8754; ///
enum GL_UNSIGNED_SHORT_1_5_5_5_REV = 0x8366; ///
enum GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT = 0x8366; ///
enum GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_EXT = 0x8033; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV = 0x8365; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT = 0x8365; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG = 0x8365; ///
enum GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034; ///
enum GL_UNSIGNED_SHORT_5_5_5_1_EXT = 0x8034; ///
enum GL_UNSIGNED_SHORT_5_6_5 = 0x8363; ///
enum GL_UNSIGNED_SHORT_5_6_5_EXT = 0x8363; ///
enum GL_UNSIGNED_SHORT_5_6_5_REV = 0x8364; ///
enum GL_UNSIGNED_SHORT_5_6_5_REV_EXT = 0x8364; ///
enum GL_UNSIGNED_SHORT_8_8_APPLE = 0x85BA; ///
enum GL_UNSIGNED_SHORT_8_8_MESA = 0x85BA; ///
enum GL_UNSIGNED_SHORT_8_8_REV_APPLE = 0x85BB; ///
enum GL_UNSIGNED_SHORT_8_8_REV_MESA = 0x85BB; ///
enum GL_UPPER_LEFT = 0x8CA2; ///
enum GL_USE_MISSING_GLYPH_NV = 0x90AA; ///
enum GL_UTF16_NV = 0x909B; ///
enum GL_UTF8_NV = 0x909A; ///
enum GL_V2F = 0x2A20; ///
enum GL_V3F = 0x2A21; ///
enum GL_VALIDATE_STATUS = 0x8B83; ///
enum GL_VARIABLE_A_NV = 0x8523; ///
enum GL_VARIABLE_B_NV = 0x8524; ///
enum GL_VARIABLE_C_NV = 0x8525; ///
enum GL_VARIABLE_D_NV = 0x8526; ///
enum GL_VARIABLE_E_NV = 0x8527; ///
enum GL_VARIABLE_F_NV = 0x8528; ///
enum GL_VARIABLE_G_NV = 0x8529; ///
enum GL_VARIANT_ARRAY_EXT = 0x87E8; ///
enum GL_VARIANT_ARRAY_POINTER_EXT = 0x87E9; ///
enum GL_VARIANT_ARRAY_STRIDE_EXT = 0x87E6; ///
enum GL_VARIANT_ARRAY_TYPE_EXT = 0x87E7; ///
enum GL_VARIANT_DATATYPE_EXT = 0x87E5; ///
enum GL_VARIANT_EXT = 0x87C1; ///
enum GL_VARIANT_VALUE_EXT = 0x87E4; ///
enum GL_VBO_FREE_MEMORY_ATI = 0x87FB; ///
enum GL_VECTOR_EXT = 0x87BF; ///
enum GL_VENDOR = 0x1F00; ///
enum GL_VERSION = 0x1F02; ///
enum GL_VERSION_ES_CL_1_0 = 1; ///
enum GL_VERSION_ES_CL_1_1 = 1; ///
enum GL_VERSION_ES_CM_1_1 = 1; ///
enum GL_VERTEX23_BIT_PGI = 0x00000004; ///
enum GL_VERTEX4_BIT_PGI = 0x00000008; ///
enum GL_VERTEX_ARRAY = 0x8074; ///
enum GL_VERTEX_ARRAY_ADDRESS_NV = 0x8F21; ///
enum GL_VERTEX_ARRAY_BINDING = 0x85B5; ///
enum GL_VERTEX_ARRAY_BINDING_APPLE = 0x85B5; ///
enum GL_VERTEX_ARRAY_BINDING_OES = 0x85B5; ///
enum GL_VERTEX_ARRAY_BUFFER_BINDING = 0x8896; ///
enum GL_VERTEX_ARRAY_BUFFER_BINDING_ARB = 0x8896; ///
enum GL_VERTEX_ARRAY_COUNT_EXT = 0x807D; ///
enum GL_VERTEX_ARRAY_EXT = 0x8074; ///
enum GL_VERTEX_ARRAY_KHR = 0x8074; ///
enum GL_VERTEX_ARRAY_LENGTH_NV = 0x8F2B; ///
enum GL_VERTEX_ARRAY_LIST_IBM = 0x103070; ///
enum GL_VERTEX_ARRAY_LIST_STRIDE_IBM = 0x103080; ///
enum GL_VERTEX_ARRAY_OBJECT_AMD = 0x9154; ///
enum GL_VERTEX_ARRAY_OBJECT_EXT = 0x9154; ///
enum GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F5; ///
enum GL_VERTEX_ARRAY_POINTER = 0x808E; ///
enum GL_VERTEX_ARRAY_POINTER_EXT = 0x808E; ///
enum GL_VERTEX_ARRAY_RANGE_APPLE = 0x851D; ///
enum GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE = 0x851E; ///
enum GL_VERTEX_ARRAY_RANGE_LENGTH_NV = 0x851E; ///
enum GL_VERTEX_ARRAY_RANGE_NV = 0x851D; ///
enum GL_VERTEX_ARRAY_RANGE_POINTER_APPLE = 0x8521; ///
enum GL_VERTEX_ARRAY_RANGE_POINTER_NV = 0x8521; ///
enum GL_VERTEX_ARRAY_RANGE_VALID_NV = 0x851F; ///
enum GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV = 0x8533; ///
enum GL_VERTEX_ARRAY_SIZE = 0x807A; ///
enum GL_VERTEX_ARRAY_SIZE_EXT = 0x807A; ///
enum GL_VERTEX_ARRAY_STORAGE_HINT_APPLE = 0x851F; ///
enum GL_VERTEX_ARRAY_STRIDE = 0x807C; ///
enum GL_VERTEX_ARRAY_STRIDE_EXT = 0x807C; ///
enum GL_VERTEX_ARRAY_TYPE = 0x807B; ///
enum GL_VERTEX_ARRAY_TYPE_EXT = 0x807B; ///
enum GL_VERTEX_ATTRIB_ARRAY0_NV = 0x8650; ///
enum GL_VERTEX_ATTRIB_ARRAY10_NV = 0x865A; ///
enum GL_VERTEX_ATTRIB_ARRAY11_NV = 0x865B; ///
enum GL_VERTEX_ATTRIB_ARRAY12_NV = 0x865C; ///
enum GL_VERTEX_ATTRIB_ARRAY13_NV = 0x865D; ///
enum GL_VERTEX_ATTRIB_ARRAY14_NV = 0x865E; ///
enum GL_VERTEX_ATTRIB_ARRAY15_NV = 0x865F; ///
enum GL_VERTEX_ATTRIB_ARRAY1_NV = 0x8651; ///
enum GL_VERTEX_ATTRIB_ARRAY2_NV = 0x8652; ///
enum GL_VERTEX_ATTRIB_ARRAY3_NV = 0x8653; ///
enum GL_VERTEX_ATTRIB_ARRAY4_NV = 0x8654; ///
enum GL_VERTEX_ATTRIB_ARRAY5_NV = 0x8655; ///
enum GL_VERTEX_ATTRIB_ARRAY6_NV = 0x8656; ///
enum GL_VERTEX_ATTRIB_ARRAY7_NV = 0x8657; ///
enum GL_VERTEX_ATTRIB_ARRAY8_NV = 0x8658; ///
enum GL_VERTEX_ATTRIB_ARRAY9_NV = 0x8659; ///
enum GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV = 0x8F20; ///
enum GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001; ///
enum GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = 0x00000001; ///
enum GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F; ///
enum GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB = 0x889F; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622; ///
enum GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB = 0x8622; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV = 0x8F2A; ///
enum GL_VERTEX_ATTRIB_ARRAY_LONG = 0x874E; ///
enum GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A; ///
enum GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB = 0x886A; ///
enum GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645; ///
enum GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB = 0x8645; ///
enum GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623; ///
enum GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB = 0x8623; ///
enum GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624; ///
enum GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB = 0x8624; ///
enum GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625; ///
enum GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB = 0x8625; ///
enum GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV = 0x8F1E; ///
enum GL_VERTEX_ATTRIB_BINDING = 0x82D4; ///
enum GL_VERTEX_ATTRIB_MAP1_APPLE = 0x8A00; ///
enum GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE = 0x8A03; ///
enum GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE = 0x8A05; ///
enum GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE = 0x8A04; ///
enum GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE = 0x8A02; ///
enum GL_VERTEX_ATTRIB_MAP2_APPLE = 0x8A01; ///
enum GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE = 0x8A07; ///
enum GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE = 0x8A09; ///
enum GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE = 0x8A08; ///
enum GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE = 0x8A06; ///
enum GL_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D5; ///
enum GL_VERTEX_BINDING_BUFFER = 0x8F4F; ///
enum GL_VERTEX_BINDING_DIVISOR = 0x82D6; ///
enum GL_VERTEX_BINDING_OFFSET = 0x82D7; ///
enum GL_VERTEX_BINDING_STRIDE = 0x82D8; ///
enum GL_VERTEX_BLEND_ARB = 0x86A7; ///
enum GL_VERTEX_CONSISTENT_HINT_PGI = 0x1A22B; ///
enum GL_VERTEX_DATA_HINT_PGI = 0x1A22A; ///
enum GL_VERTEX_ELEMENT_SWIZZLE_AMD = 0x91A4; ///
enum GL_VERTEX_ID_NV = 0x8C7B; ///
enum GL_VERTEX_ID_SWIZZLE_AMD = 0x91A5; ///
enum GL_VERTEX_PRECLIP_HINT_SGIX = 0x83EF; ///
enum GL_VERTEX_PRECLIP_SGIX = 0x83EE; ///
enum GL_VERTEX_PROGRAM_ARB = 0x8620; ///
enum GL_VERTEX_PROGRAM_BINDING_NV = 0x864A; ///
enum GL_VERTEX_PROGRAM_CALLBACK_DATA_MESA = 0x8BB7; ///
enum GL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA = 0x8BB6; ///
enum GL_VERTEX_PROGRAM_CALLBACK_MESA = 0x8BB5; ///
enum GL_VERTEX_PROGRAM_NV = 0x8620; ///
enum GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA2; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE = 0x8642; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE_ARB = 0x8642; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE_NV = 0x8642; ///
enum GL_VERTEX_PROGRAM_POSITION_MESA = 0x8BB4; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE = 0x8643; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE_ARB = 0x8643; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE_NV = 0x8643; ///
enum GL_VERTEX_SHADER = 0x8B31; ///
enum GL_VERTEX_SHADER_ARB = 0x8B31; ///
enum GL_VERTEX_SHADER_BINDING_EXT = 0x8781; ///
enum GL_VERTEX_SHADER_BIT = 0x00000001; ///
enum GL_VERTEX_SHADER_BIT_EXT = 0x00000001; ///
enum GL_VERTEX_SHADER_EXT = 0x8780; ///
enum GL_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87CF; ///
enum GL_VERTEX_SHADER_INVARIANTS_EXT = 0x87D1; ///
enum GL_VERTEX_SHADER_INVOCATIONS_ARB = 0x82F0; ///
enum GL_VERTEX_SHADER_LOCALS_EXT = 0x87D3; ///
enum GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87D2; ///
enum GL_VERTEX_SHADER_OPTIMIZED_EXT = 0x87D4; ///
enum GL_VERTEX_SHADER_VARIANTS_EXT = 0x87D0; ///
enum GL_VERTEX_SOURCE_ATI = 0x8774; ///
enum GL_VERTEX_STATE_PROGRAM_NV = 0x8621; ///
enum GL_VERTEX_STREAM0_ATI = 0x876C; ///
enum GL_VERTEX_STREAM1_ATI = 0x876D; ///
enum GL_VERTEX_STREAM2_ATI = 0x876E; ///
enum GL_VERTEX_STREAM3_ATI = 0x876F; ///
enum GL_VERTEX_STREAM4_ATI = 0x8770; ///
enum GL_VERTEX_STREAM5_ATI = 0x8771; ///
enum GL_VERTEX_STREAM6_ATI = 0x8772; ///
enum GL_VERTEX_STREAM7_ATI = 0x8773; ///
enum GL_VERTEX_SUBROUTINE = 0x92E8; ///
enum GL_VERTEX_SUBROUTINE_UNIFORM = 0x92EE; ///
enum GL_VERTEX_TEXTURE = 0x829B; ///
enum GL_VERTEX_WEIGHTING_EXT = 0x8509; ///
enum GL_VERTEX_WEIGHT_ARRAY_EXT = 0x850C; ///
enum GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT = 0x8510; ///
enum GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT = 0x850D; ///
enum GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT = 0x850F; ///
enum GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT = 0x850E; ///
enum GL_VERTICAL_LINE_TO_NV = 0x08; ///
enum GL_VERTICES_SUBMITTED_ARB = 0x82EE; ///
enum GL_VIBRANCE_BIAS_NV = 0x8719; ///
enum GL_VIBRANCE_SCALE_NV = 0x8713; ///
enum GL_VIDEO_BUFFER_BINDING_NV = 0x9021; ///
enum GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV = 0x902D; ///
enum GL_VIDEO_BUFFER_NV = 0x9020; ///
enum GL_VIDEO_BUFFER_PITCH_NV = 0x9028; ///
enum GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV = 0x903B; ///
enum GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV = 0x903A; ///
enum GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV = 0x9039; ///
enum GL_VIDEO_CAPTURE_FRAME_WIDTH_NV = 0x9038; ///
enum GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV = 0x903C; ///
enum GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV = 0x9026; ///
enum GL_VIDEO_COLOR_CONVERSION_MATRIX_NV = 0x9029; ///
enum GL_VIDEO_COLOR_CONVERSION_MAX_NV = 0x902A; ///
enum GL_VIDEO_COLOR_CONVERSION_MIN_NV = 0x902B; ///
enum GL_VIDEO_COLOR_CONVERSION_OFFSET_NV = 0x902C; ///
enum GL_VIEWPORT = 0x0BA2; ///
enum GL_VIEWPORT_BIT = 0x00000800; ///
enum GL_VIEWPORT_BOUNDS_RANGE = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_EXT = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_NV = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_OES = 0x825D; ///
enum GL_VIEWPORT_COMMAND_NV = 0x0010; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_EXT = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_OES = 0x825F; ///
enum GL_VIEWPORT_POSITION_W_SCALE_NV = 0x937C; ///
enum GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV = 0x937D; ///
enum GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV = 0x937E; ///
enum GL_VIEWPORT_SUBPIXEL_BITS = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_EXT = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_NV = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_OES = 0x825C; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV = 0x9357; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV = 0x9351; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV = 0x9353; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV = 0x9355; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV = 0x9356; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV = 0x9350; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV = 0x9352; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV = 0x9354; ///
enum GL_VIEWPORT_SWIZZLE_W_NV = 0x935B; ///
enum GL_VIEWPORT_SWIZZLE_X_NV = 0x9358; ///
enum GL_VIEWPORT_SWIZZLE_Y_NV = 0x9359; ///
enum GL_VIEWPORT_SWIZZLE_Z_NV = 0x935A; ///
enum GL_VIEW_CLASS_128_BITS = 0x82C4; ///
enum GL_VIEW_CLASS_16_BITS = 0x82CA; ///
enum GL_VIEW_CLASS_24_BITS = 0x82C9; ///
enum GL_VIEW_CLASS_32_BITS = 0x82C8; ///
enum GL_VIEW_CLASS_48_BITS = 0x82C7; ///
enum GL_VIEW_CLASS_64_BITS = 0x82C6; ///
enum GL_VIEW_CLASS_8_BITS = 0x82CB; ///
enum GL_VIEW_CLASS_96_BITS = 0x82C5; ///
enum GL_VIEW_CLASS_BPTC_FLOAT = 0x82D3; ///
enum GL_VIEW_CLASS_BPTC_UNORM = 0x82D2; ///
enum GL_VIEW_CLASS_RGTC1_RED = 0x82D0; ///
enum GL_VIEW_CLASS_RGTC2_RG = 0x82D1; ///
enum GL_VIEW_CLASS_S3TC_DXT1_RGB = 0x82CC; ///
enum GL_VIEW_CLASS_S3TC_DXT1_RGBA = 0x82CD; ///
enum GL_VIEW_CLASS_S3TC_DXT3_RGBA = 0x82CE; ///
enum GL_VIEW_CLASS_S3TC_DXT5_RGBA = 0x82CF; ///
enum GL_VIEW_COMPATIBILITY_CLASS = 0x82B6; ///
enum GL_VIRTUAL_PAGE_SIZE_INDEX_ARB = 0x91A7; ///
enum GL_VIRTUAL_PAGE_SIZE_INDEX_EXT = 0x91A7; ///
enum GL_VIRTUAL_PAGE_SIZE_X_AMD = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_X_ARB = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_X_EXT = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_AMD = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_ARB = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_EXT = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_AMD = 0x9197; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_ARB = 0x9197; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_EXT = 0x9197; ///
enum GL_VIVIDLIGHT_NV = 0x92A6; ///
enum GL_VOLATILE_APPLE = 0x8A1A; ///
enum GL_WAIT_FAILED = 0x911D; ///
enum GL_WAIT_FAILED_APPLE = 0x911D; ///
enum GL_WARPS_PER_SM_NV = 0x933A; ///
enum GL_WARP_SIZE_NV = 0x9339; ///
enum GL_WEIGHTED_AVERAGE_ARB = 0x9367; ///
enum GL_WEIGHT_ARRAY_ARB = 0x86AD; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING = 0x889E; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB = 0x889E; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING_OES = 0x889E; ///
enum GL_WEIGHT_ARRAY_OES = 0x86AD; ///
enum GL_WEIGHT_ARRAY_POINTER_ARB = 0x86AC; ///
enum GL_WEIGHT_ARRAY_POINTER_OES = 0x86AC; ///
enum GL_WEIGHT_ARRAY_SIZE_ARB = 0x86AB; ///
enum GL_WEIGHT_ARRAY_SIZE_OES = 0x86AB; ///
enum GL_WEIGHT_ARRAY_STRIDE_ARB = 0x86AA; ///
enum GL_WEIGHT_ARRAY_STRIDE_OES = 0x86AA; ///
enum GL_WEIGHT_ARRAY_TYPE_ARB = 0x86A9; ///
enum GL_WEIGHT_ARRAY_TYPE_OES = 0x86A9; ///
enum GL_WEIGHT_SUM_UNITY_ARB = 0x86A6; ///
enum GL_WIDE_LINE_HINT_PGI = 0x1A222; ///
enum GL_WINDOW_RECTANGLE_EXT = 0x8F12; ///
enum GL_WINDOW_RECTANGLE_MODE_EXT = 0x8F13; ///
enum GL_WRAP_BORDER_SUN = 0x81D4; ///
enum GL_WRITEONLY_RENDERING_QCOM = 0x8823; ///
enum GL_WRITE_DISCARD_NV = 0x88BE; ///
enum GL_WRITE_ONLY = 0x88B9; ///
enum GL_WRITE_ONLY_ARB = 0x88B9; ///
enum GL_WRITE_ONLY_OES = 0x88B9; ///
enum GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV = 0x887A; ///
enum GL_WRITE_PIXEL_DATA_RANGE_NV = 0x8878; ///
enum GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV = 0x887C; ///
enum GL_W_EXT = 0x87D8; ///
enum GL_XOR = 0x1506; ///
enum GL_XOR_NV = 0x1506; ///
enum GL_X_EXT = 0x87D5; ///
enum GL_YCBAYCR8A_4224_NV = 0x9032; ///
enum GL_YCBCR_422_APPLE = 0x85B9; ///
enum GL_YCBCR_MESA = 0x8757; ///
enum GL_YCBYCR8_422_NV = 0x9031; ///
enum GL_YCRCBA_SGIX = 0x8319; ///
enum GL_YCRCB_422_SGIX = 0x81BB; ///
enum GL_YCRCB_444_SGIX = 0x81BC; ///
enum GL_YCRCB_SGIX = 0x8318; ///
enum GL_Y_EXT = 0x87D6; ///
enum GL_Z400_BINARY_AMD = 0x8740; ///
enum GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV = 0x9036; ///
enum GL_Z4Y12Z4CB12Z4CR12_444_NV = 0x9037; ///
enum GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV = 0x9035; ///
enum GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV = 0x9034; ///
enum GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV = 0x9033; ///
enum GL_ZERO = 0; ///
enum GL_ZERO_EXT = 0x87DD; ///
enum GL_ZERO_TO_ONE = 0x935F; ///
enum GL_ZOOM_X = 0x0D16; ///
enum GL_ZOOM_Y = 0x0D17; ///
enum GL_Z_EXT = 0x87D7; ///

	///
	enum AccumOp {
    	///
	    ACCUM = 0x0100,
    	///
	    LOAD = 0x0101,
    	///
	    RETURN = 0x0102,
    	///
	    MULT = 0x0103,
    	///
	    ADD = 0x0104
	}

	///
	@Bitmaskable
	enum AttribMask {
    	///
	    ACCUM_BUFFER_BIT = 0x00000200,
    	///
	    ALL_ATTRIB_BITS = 0xFFFFFFFF,
    	///
	    COLOR_BUFFER_BIT = 0x00004000,
    	///
	    CURRENT_BIT = 0x00000001,
    	///
	    DEPTH_BUFFER_BIT = 0x00000100,
    	///
	    ENABLE_BIT = 0x00002000,
    	///
	    EVAL_BIT = 0x00010000,
    	///
	    FOG_BIT = 0x00000080,
    	///
	    HINT_BIT = 0x00008000,
    	///
	    LIGHTING_BIT = 0x00000040,
    	///
	    LINE_BIT = 0x00000004,
    	///
	    LIST_BIT = 0x00020000,
    	///
	    MULTISAMPLE_BIT = 0x20000000,
    	///
	    MULTISAMPLE_BIT_3DFX = 0x20000000,
    	///
	    MULTISAMPLE_BIT_ARB = 0x20000000,
    	///
	    MULTISAMPLE_BIT_EXT = 0x20000000,
    	///
	    PIXEL_MODE_BIT = 0x00000020,
    	///
	    POINT_BIT = 0x00000002,
    	///
	    POLYGON_BIT = 0x00000008,
    	///
	    POLYGON_STIPPLE_BIT = 0x00000010,
    	///
	    SCISSOR_BIT = 0x00080000,
    	///
	    STENCIL_BUFFER_BIT = 0x00000400,
    	///
	    TEXTURE_BIT = 0x00040000,
    	///
	    TRANSFORM_BIT = 0x00001000,
    	///
	    VIEWPORT_BIT = 0x00000800
	}

	///
	enum AlphaFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum BlendEquationModeEXT {
    	///
	    ALPHA_MAX_SGIX = 0x8321,
    	///
	    ALPHA_MIN_SGIX = 0x8320,
    	///
	    FUNC_ADD_EXT = 0x8006,
    	///
	    FUNC_REVERSE_SUBTRACT_EXT = 0x800B,
    	///
	    FUNC_SUBTRACT_EXT = 0x800A,
    	///
	    LOGIC_OP = 0x0BF1,
    	///
	    MAX_EXT = 0x8008,
    	///
	    MIN_EXT = 0x8007
	}

	///
	enum BlendingFactorDest {
    	///
	    CONSTANT_ALPHA_EXT = 0x8003,
    	///
	    CONSTANT_COLOR_EXT = 0x8001,
    	///
	    DST_ALPHA = 0x0304,
    	///
	    ONE = 1,
    	///
	    ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004,
    	///
	    ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002,
    	///
	    ONE_MINUS_DST_ALPHA = 0x0305,
    	///
	    ONE_MINUS_SRC_ALPHA = 0x0303,
    	///
	    ONE_MINUS_SRC_COLOR = 0x0301,
    	///
	    SRC_ALPHA = 0x0302,
    	///
	    SRC_COLOR = 0x0300,
    	///
	    ZERO = 0
	}

	///
	enum BlendingFactorSrc {
    	///
	    CONSTANT_ALPHA_EXT = 0x8003,
    	///
	    CONSTANT_COLOR_EXT = 0x8001,
    	///
	    DST_ALPHA = 0x0304,
    	///
	    DST_COLOR = 0x0306,
    	///
	    ONE = 1,
    	///
	    ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004,
    	///
	    ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002,
    	///
	    ONE_MINUS_DST_ALPHA = 0x0305,
    	///
	    ONE_MINUS_DST_COLOR = 0x0307,
    	///
	    ONE_MINUS_SRC_ALPHA = 0x0303,
    	///
	    SRC_ALPHA = 0x0302,
    	///
	    SRC_ALPHA_SATURATE = 0x0308,
    	///
	    ZERO = 0
	}

	///
	enum Boolean {
    	///
	    FALSE = 0,
    	///
	    TRUE = 1
	}

	///
	@Bitmaskable
	enum ClearBufferMask {
    	///
	    ACCUM_BUFFER_BIT = 0x00000200,
    	///
	    COLOR_BUFFER_BIT = 0x00004000,
    	///
	    COVERAGE_BUFFER_BIT_NV = 0x00008000,
    	///
	    DEPTH_BUFFER_BIT = 0x00000100,
    	///
	    STENCIL_BUFFER_BIT = 0x00000400
	}

	///
	@Bitmaskable
	enum ClientAttribMask {
    	///
	    CLIENT_ALL_ATTRIB_BITS = 0xFFFFFFFF,
    	///
	    CLIENT_PIXEL_STORE_BIT = 0x00000001,
    	///
	    CLIENT_VERTEX_ARRAY_BIT = 0x00000002
	}

	///
	enum ClipPlaneName {
    	///
	    CLIP_DISTANCE0 = 0x3000,
    	///
	    CLIP_DISTANCE1 = 0x3001,
    	///
	    CLIP_DISTANCE2 = 0x3002,
    	///
	    CLIP_DISTANCE3 = 0x3003,
    	///
	    CLIP_DISTANCE4 = 0x3004,
    	///
	    CLIP_DISTANCE5 = 0x3005,
    	///
	    CLIP_DISTANCE6 = 0x3006,
    	///
	    CLIP_DISTANCE7 = 0x3007,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005
	}

	///
	enum ColorMaterialFace {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum ColorMaterialParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    AMBIENT_AND_DIFFUSE = 0x1602,
    	///
	    DIFFUSE = 0x1201,
    	///
	    EMISSION = 0x1600,
    	///
	    SPECULAR = 0x1202
	}

	///
	enum ColorPointerType {
    	///
	    BYTE = 0x1400,
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403
	}

	///
	enum ColorTableParameterPNameSGI {
    	///
	    COLOR_TABLE_BIAS = 0x80D7,
    	///
	    COLOR_TABLE_BIAS_SGI = 0x80D7,
    	///
	    COLOR_TABLE_SCALE = 0x80D6,
    	///
	    COLOR_TABLE_SCALE_SGI = 0x80D6
	}

	///
	enum ColorTableTargetSGI {
    	///
	    COLOR_TABLE = 0x80D0,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE = 0x80D2,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_CONVOLUTION_COLOR_TABLE = 0x80D1,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    PROXY_COLOR_TABLE = 0x80D3,
    	///
	    PROXY_COLOR_TABLE_SGI = 0x80D3,
    	///
	    PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5,
    	///
	    PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D5,
    	///
	    PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4,
    	///
	    PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D4,
    	///
	    PROXY_TEXTURE_COLOR_TABLE_SGI = 0x80BD,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC
	}

	///
	@Bitmaskable
	enum ContextFlagMask {
    	///
	    CONTEXT_FLAG_DEBUG_BIT = 0x00000002,
    	///
	    CONTEXT_FLAG_DEBUG_BIT_KHR = 0x00000002,
    	///
	    CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001,
    	///
	    CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004,
    	///
	    CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = 0x00000010
	}

	///
	@Bitmaskable
	enum ContextProfileMask {
    	///
	    CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002,
    	///
	    CONTEXT_CORE_PROFILE_BIT = 0x00000001
	}

	///
	enum ConvolutionBorderModeEXT {
    	///
	    REDUCE = 0x8016,
    	///
	    REDUCE_EXT = 0x8016
	}

	///
	enum ConvolutionParameterEXT {
    	///
	    CONVOLUTION_BORDER_MODE = 0x8013,
    	///
	    CONVOLUTION_BORDER_MODE_EXT = 0x8013,
    	///
	    CONVOLUTION_FILTER_BIAS = 0x8015,
    	///
	    CONVOLUTION_FILTER_BIAS_EXT = 0x8015,
    	///
	    CONVOLUTION_FILTER_SCALE = 0x8014,
    	///
	    CONVOLUTION_FILTER_SCALE_EXT = 0x8014
	}

	///
	enum ConvolutionTargetEXT {
    	///
	    CONVOLUTION_1D = 0x8010,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D = 0x8011,
    	///
	    CONVOLUTION_2D_EXT = 0x8011
	}

	///
	enum CullFaceMode {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum DepthFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum DrawBufferMode {
    	///
	    AUX0 = 0x0409,
    	///
	    AUX1 = 0x040A,
    	///
	    AUX2 = 0x040B,
    	///
	    AUX3 = 0x040C,
    	///
	    BACK = 0x0405,
    	///
	    BACK_LEFT = 0x0402,
    	///
	    BACK_RIGHT = 0x0403,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408,
    	///
	    FRONT_LEFT = 0x0400,
    	///
	    FRONT_RIGHT = 0x0401,
    	///
	    LEFT = 0x0406,
    	///
	    NONE = 0,
    	///
	    NONE_OES = 0,
    	///
	    RIGHT = 0x0407
	}

	///
	enum EnableCap {
    	///
	    ALPHA_TEST = 0x0BC0,
    	///
	    ASYNC_DRAW_PIXELS_SGIX = 0x835D,
    	///
	    ASYNC_HISTOGRAM_SGIX = 0x832C,
    	///
	    ASYNC_READ_PIXELS_SGIX = 0x835E,
    	///
	    ASYNC_TEX_IMAGE_SGIX = 0x835C,
    	///
	    AUTO_NORMAL = 0x0D80,
    	///
	    BLEND = 0x0BE2,
    	///
	    CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005,
    	///
	    COLOR_ARRAY = 0x8076,
    	///
	    COLOR_LOGIC_OP = 0x0BF2,
    	///
	    COLOR_MATERIAL = 0x0B57,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D_EXT = 0x8011,
    	///
	    CULL_FACE = 0x0B44,
    	///
	    DEPTH_TEST = 0x0B71,
    	///
	    DITHER = 0x0BD0,
    	///
	    EDGE_FLAG_ARRAY = 0x8079,
    	///
	    FOG = 0x0B60,
    	///
	    FOG_OFFSET_SGIX = 0x8198,
    	///
	    FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401,
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHT1_SGIX = 0x840D,
    	///
	    FRAGMENT_LIGHT2_SGIX = 0x840E,
    	///
	    FRAGMENT_LIGHT3_SGIX = 0x840F,
    	///
	    FRAGMENT_LIGHT4_SGIX = 0x8410,
    	///
	    FRAGMENT_LIGHT5_SGIX = 0x8411,
    	///
	    FRAGMENT_LIGHT6_SGIX = 0x8412,
    	///
	    FRAGMENT_LIGHT7_SGIX = 0x8413,
    	///
	    FRAGMENT_LIGHTING_SGIX = 0x8400,
    	///
	    FRAMEZOOM_SGIX = 0x818B,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    INDEX_ARRAY = 0x8077,
    	///
	    INDEX_LOGIC_OP = 0x0BF1,
    	///
	    INTERLACE_SGIX = 0x8094,
    	///
	    IR_INSTRUMENT1_SGIX = 0x817F,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007,
    	///
	    LIGHTING = 0x0B50,
    	///
	    LINE_SMOOTH = 0x0B20,
    	///
	    LINE_STIPPLE = 0x0B24,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    MINMAX_EXT = 0x802E,
    	///
	    MULTISAMPLE_SGIS = 0x809D,
    	///
	    NORMALIZE = 0x0BA1,
    	///
	    NORMAL_ARRAY = 0x8075,
    	///
	    PIXEL_TEXTURE_SGIS = 0x8353,
    	///
	    PIXEL_TEX_GEN_SGIX = 0x8139,
    	///
	    POINT_SMOOTH = 0x0B10,
    	///
	    POLYGON_OFFSET_FILL = 0x8037,
    	///
	    POLYGON_OFFSET_LINE = 0x2A02,
    	///
	    POLYGON_OFFSET_POINT = 0x2A01,
    	///
	    POLYGON_SMOOTH = 0x0B41,
    	///
	    POLYGON_STIPPLE = 0x0B42,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    REFERENCE_PLANE_SGIX = 0x817D,
    	///
	    RESCALE_NORMAL_EXT = 0x803A,
    	///
	    SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E,
    	///
	    SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F,
    	///
	    SAMPLE_MASK_SGIS = 0x80A0,
    	///
	    SCISSOR_TEST = 0x0C11,
    	///
	    SEPARABLE_2D_EXT = 0x8012,
    	///
	    SHARED_TEXTURE_PALETTE_EXT = 0x81FB,
    	///
	    SPRITE_SGIX = 0x8148,
    	///
	    STENCIL_TEST = 0x0B90,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC,
    	///
	    TEXTURE_COORD_ARRAY = 0x8078,
    	///
	    TEXTURE_GEN_Q = 0x0C63,
    	///
	    TEXTURE_GEN_R = 0x0C62,
    	///
	    TEXTURE_GEN_S = 0x0C60,
    	///
	    TEXTURE_GEN_T = 0x0C61,
    	///
	    VERTEX_ARRAY = 0x8074
	}

	///
	enum ErrorCode {
    	///
	    INVALID_ENUM = 0x0500,
    	///
	    INVALID_FRAMEBUFFER_OPERATION = 0x0506,
    	///
	    INVALID_FRAMEBUFFER_OPERATION_EXT = 0x0506,
    	///
	    INVALID_FRAMEBUFFER_OPERATION_OES = 0x0506,
    	///
	    INVALID_OPERATION = 0x0502,
    	///
	    INVALID_VALUE = 0x0501,
    	///
	    NO_ERROR = 0,
    	///
	    OUT_OF_MEMORY = 0x0505,
    	///
	    STACK_OVERFLOW = 0x0503,
    	///
	    STACK_UNDERFLOW = 0x0504,
    	///
	    TABLE_TOO_LARGE = 0x8031,
    	///
	    TABLE_TOO_LARGE_EXT = 0x8031,
    	///
	    TEXTURE_TOO_LARGE_EXT = 0x8065
	}

	///
	enum FeedbackType {
    	///
	    _2D = 0x0600,
    	///
	    _3D = 0x0601,
    	///
	    COLOR_3D = 0x0602,
    	///
	    COLOR_TEXTURE_3D = 0x0603,
    	///
	    COLOR_TEXTURE_4D = 0x0604
	}

	///
	enum FeedBackToken {
    	///
	    BITMAP_TOKEN = 0x0704,
    	///
	    COPY_PIXEL_TOKEN = 0x0706,
    	///
	    DRAW_PIXEL_TOKEN = 0x0705,
    	///
	    LINE_RESET_TOKEN = 0x0707,
    	///
	    LINE_TOKEN = 0x0702,
    	///
	    PASS_THROUGH_TOKEN = 0x0700,
    	///
	    POINT_TOKEN = 0x0701,
    	///
	    POLYGON_TOKEN = 0x0703
	}

	///
	enum FfdTargetSGIX {
    	///
	    GEOMETRY_DEFORMATION_SGIX = 0x8194,
    	///
	    TEXTURE_DEFORMATION_SGIX = 0x8195
	}

	///
	enum FogCoordinatePointerType {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FogMode {
    	///
	    EXP = 0x0800,
    	///
	    EXP2 = 0x0801,
    	///
	    FOG_FUNC_SGIS = 0x812A,
    	///
	    LINEAR = 0x2601
	}

	///
	enum FogParameter {
    	///
	    FOG_COLOR = 0x0B66,
    	///
	    FOG_DENSITY = 0x0B62,
    	///
	    FOG_END = 0x0B64,
    	///
	    FOG_INDEX = 0x0B61,
    	///
	    FOG_MODE = 0x0B65,
    	///
	    FOG_OFFSET_VALUE_SGIX = 0x8199,
    	///
	    FOG_START = 0x0B63
	}

	///
	enum FogPointerTypeEXT {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FogPointerTypeIBM {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FragmentLightModelParameterSGIX {
    	///
	    FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A,
    	///
	    FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408,
    	///
	    FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B,
    	///
	    FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409
	}

	///
	enum FrontFaceDirection {
    	///
	    CCW = 0x0901,
    	///
	    CW = 0x0900
	}

	///
	enum GetColorTableParameterPNameSGI {
    	///
	    COLOR_TABLE_ALPHA_SIZE_SGI = 0x80DD,
    	///
	    COLOR_TABLE_BIAS_SGI = 0x80D7,
    	///
	    COLOR_TABLE_BLUE_SIZE_SGI = 0x80DC,
    	///
	    COLOR_TABLE_FORMAT_SGI = 0x80D8,
    	///
	    COLOR_TABLE_GREEN_SIZE_SGI = 0x80DB,
    	///
	    COLOR_TABLE_INTENSITY_SIZE_SGI = 0x80DF,
    	///
	    COLOR_TABLE_LUMINANCE_SIZE_SGI = 0x80DE,
    	///
	    COLOR_TABLE_RED_SIZE_SGI = 0x80DA,
    	///
	    COLOR_TABLE_SCALE_SGI = 0x80D6,
    	///
	    COLOR_TABLE_WIDTH_SGI = 0x80D9
	}

	///
	enum GetConvolutionParameter {
    	///
	    CONVOLUTION_BORDER_MODE_EXT = 0x8013,
    	///
	    CONVOLUTION_FILTER_BIAS_EXT = 0x8015,
    	///
	    CONVOLUTION_FILTER_SCALE_EXT = 0x8014,
    	///
	    CONVOLUTION_FORMAT_EXT = 0x8017,
    	///
	    CONVOLUTION_HEIGHT_EXT = 0x8019,
    	///
	    CONVOLUTION_WIDTH_EXT = 0x8018,
    	///
	    MAX_CONVOLUTION_HEIGHT_EXT = 0x801B,
    	///
	    MAX_CONVOLUTION_WIDTH_EXT = 0x801A
	}

	///
	enum GetHistogramParameterPNameEXT {
    	///
	    HISTOGRAM_ALPHA_SIZE_EXT = 0x802B,
    	///
	    HISTOGRAM_BLUE_SIZE_EXT = 0x802A,
    	///
	    HISTOGRAM_FORMAT_EXT = 0x8027,
    	///
	    HISTOGRAM_GREEN_SIZE_EXT = 0x8029,
    	///
	    HISTOGRAM_LUMINANCE_SIZE_EXT = 0x802C,
    	///
	    HISTOGRAM_RED_SIZE_EXT = 0x8028,
    	///
	    HISTOGRAM_SINK_EXT = 0x802D,
    	///
	    HISTOGRAM_WIDTH_EXT = 0x8026
	}

	///
	enum GetMapQuery {
    	///
	    COEFF = 0x0A00,
    	///
	    DOMAIN = 0x0A02,
    	///
	    ORDER = 0x0A01
	}

	///
	enum GetMinmaxParameterPNameEXT {
    	///
	    MINMAX_FORMAT = 0x802F,
    	///
	    MINMAX_FORMAT_EXT = 0x802F,
    	///
	    MINMAX_SINK = 0x8030,
    	///
	    MINMAX_SINK_EXT = 0x8030
	}

	///
	enum GetPixelMap {
    	///
	    PIXEL_MAP_A_TO_A = 0x0C79,
    	///
	    PIXEL_MAP_B_TO_B = 0x0C78,
    	///
	    PIXEL_MAP_G_TO_G = 0x0C77,
    	///
	    PIXEL_MAP_I_TO_A = 0x0C75,
    	///
	    PIXEL_MAP_I_TO_B = 0x0C74,
    	///
	    PIXEL_MAP_I_TO_G = 0x0C73,
    	///
	    PIXEL_MAP_I_TO_I = 0x0C70,
    	///
	    PIXEL_MAP_I_TO_R = 0x0C72,
    	///
	    PIXEL_MAP_R_TO_R = 0x0C76,
    	///
	    PIXEL_MAP_S_TO_S = 0x0C71
	}

	///
	enum GetPName {
    	///
	    ACCUM_ALPHA_BITS = 0x0D5B,
    	///
	    ACCUM_BLUE_BITS = 0x0D5A,
    	///
	    ACCUM_CLEAR_VALUE = 0x0B80,
    	///
	    ACCUM_GREEN_BITS = 0x0D59,
    	///
	    ACCUM_RED_BITS = 0x0D58,
    	///
	    ALIASED_LINE_WIDTH_RANGE = 0x846E,
    	///
	    ALIASED_POINT_SIZE_RANGE = 0x846D,
    	///
	    ALPHA_BIAS = 0x0D1D,
    	///
	    ALPHA_BITS = 0x0D55,
    	///
	    ALPHA_SCALE = 0x0D1C,
    	///
	    ALPHA_TEST = 0x0BC0,
    	///
	    ALPHA_TEST_FUNC = 0x0BC1,
    	///
	    ALPHA_TEST_FUNC_QCOM = 0x0BC1,
    	///
	    ALPHA_TEST_QCOM = 0x0BC0,
    	///
	    ALPHA_TEST_REF = 0x0BC2,
    	///
	    ALPHA_TEST_REF_QCOM = 0x0BC2,
    	///
	    ASYNC_DRAW_PIXELS_SGIX = 0x835D,
    	///
	    ASYNC_HISTOGRAM_SGIX = 0x832C,
    	///
	    ASYNC_MARKER_SGIX = 0x8329,
    	///
	    ASYNC_READ_PIXELS_SGIX = 0x835E,
    	///
	    ASYNC_TEX_IMAGE_SGIX = 0x835C,
    	///
	    ATTRIB_STACK_DEPTH = 0x0BB0,
    	///
	    AUTO_NORMAL = 0x0D80,
    	///
	    AUX_BUFFERS = 0x0C00,
    	///
	    BLEND = 0x0BE2,
    	///
	    BLEND_COLOR_EXT = 0x8005,
    	///
	    BLEND_DST = 0x0BE0,
    	///
	    BLEND_EQUATION_EXT = 0x8009,
    	///
	    BLEND_SRC = 0x0BE1,
    	///
	    BLUE_BIAS = 0x0D1B,
    	///
	    BLUE_BITS = 0x0D54,
    	///
	    BLUE_SCALE = 0x0D1A,
    	///
	    CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183,
    	///
	    CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005,
    	///
	    COLOR_ARRAY = 0x8076,
    	///
	    COLOR_ARRAY_COUNT_EXT = 0x8084,
    	///
	    COLOR_ARRAY_SIZE = 0x8081,
    	///
	    COLOR_ARRAY_STRIDE = 0x8083,
    	///
	    COLOR_ARRAY_TYPE = 0x8082,
    	///
	    COLOR_CLEAR_VALUE = 0x0C22,
    	///
	    COLOR_LOGIC_OP = 0x0BF2,
    	///
	    COLOR_MATERIAL = 0x0B57,
    	///
	    COLOR_MATERIAL_FACE = 0x0B55,
    	///
	    COLOR_MATERIAL_PARAMETER = 0x0B56,
    	///
	    COLOR_MATRIX_SGI = 0x80B1,
    	///
	    COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B2,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    COLOR_WRITEMASK = 0x0C23,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D_EXT = 0x8011,
    	///
	    CONVOLUTION_HINT_SGIX = 0x8316,
    	///
	    CULL_FACE = 0x0B44,
    	///
	    CULL_FACE_MODE = 0x0B45,
    	///
	    CURRENT_COLOR = 0x0B00,
    	///
	    CURRENT_INDEX = 0x0B01,
    	///
	    CURRENT_NORMAL = 0x0B02,
    	///
	    CURRENT_RASTER_COLOR = 0x0B04,
    	///
	    CURRENT_RASTER_DISTANCE = 0x0B09,
    	///
	    CURRENT_RASTER_INDEX = 0x0B05,
    	///
	    CURRENT_RASTER_POSITION = 0x0B07,
    	///
	    CURRENT_RASTER_POSITION_VALID = 0x0B08,
    	///
	    CURRENT_RASTER_TEXTURE_COORDS = 0x0B06,
    	///
	    CURRENT_TEXTURE_COORDS = 0x0B03,
    	///
	    DEFORMATIONS_MASK_SGIX = 0x8196,
    	///
	    DEPTH_BIAS = 0x0D1F,
    	///
	    DEPTH_BITS = 0x0D56,
    	///
	    DEPTH_CLEAR_VALUE = 0x0B73,
    	///
	    DEPTH_FUNC = 0x0B74,
    	///
	    DEPTH_RANGE = 0x0B70,
    	///
	    DEPTH_SCALE = 0x0D1E,
    	///
	    DEPTH_TEST = 0x0B71,
    	///
	    DEPTH_WRITEMASK = 0x0B72,
    	///
	    DETAIL_TEXTURE_2D_BINDING_SGIS = 0x8096,
    	///
	    DISTANCE_ATTENUATION_SGIS = 0x8129,
    	///
	    DITHER = 0x0BD0,
    	///
	    DOUBLEBUFFER = 0x0C32,
    	///
	    DRAW_BUFFER = 0x0C01,
    	///
	    DRAW_BUFFER_EXT = 0x0C01,
    	///
	    EDGE_FLAG = 0x0B43,
    	///
	    EDGE_FLAG_ARRAY = 0x8079,
    	///
	    EDGE_FLAG_ARRAY_COUNT_EXT = 0x808D,
    	///
	    EDGE_FLAG_ARRAY_STRIDE = 0x808C,
    	///
	    FEEDBACK_BUFFER_SIZE = 0x0DF1,
    	///
	    FEEDBACK_BUFFER_TYPE = 0x0DF2,
    	///
	    FOG = 0x0B60,
    	///
	    FOG_COLOR = 0x0B66,
    	///
	    FOG_DENSITY = 0x0B62,
    	///
	    FOG_END = 0x0B64,
    	///
	    FOG_FUNC_POINTS_SGIS = 0x812B,
    	///
	    FOG_HINT = 0x0C54,
    	///
	    FOG_INDEX = 0x0B61,
    	///
	    FOG_MODE = 0x0B65,
    	///
	    FOG_OFFSET_SGIX = 0x8198,
    	///
	    FOG_OFFSET_VALUE_SGIX = 0x8199,
    	///
	    FOG_START = 0x0B63,
    	///
	    FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 0x8402,
    	///
	    FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 0x8403,
    	///
	    FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401,
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHTING_SGIX = 0x8400,
    	///
	    FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A,
    	///
	    FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408,
    	///
	    FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B,
    	///
	    FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409,
    	///
	    FRAMEZOOM_FACTOR_SGIX = 0x818C,
    	///
	    FRAMEZOOM_SGIX = 0x818B,
    	///
	    FRONT_FACE = 0x0B46,
    	///
	    GENERATE_MIPMAP_HINT_SGIS = 0x8192,
    	///
	    GREEN_BIAS = 0x0D19,
    	///
	    GREEN_BITS = 0x0D53,
    	///
	    GREEN_SCALE = 0x0D18,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    INDEX_ARRAY = 0x8077,
    	///
	    INDEX_ARRAY_COUNT_EXT = 0x8087,
    	///
	    INDEX_ARRAY_STRIDE = 0x8086,
    	///
	    INDEX_ARRAY_TYPE = 0x8085,
    	///
	    INDEX_BITS = 0x0D51,
    	///
	    INDEX_CLEAR_VALUE = 0x0C20,
    	///
	    INDEX_LOGIC_OP = 0x0BF1,
    	///
	    INDEX_MODE = 0x0C30,
    	///
	    INDEX_OFFSET = 0x0D13,
    	///
	    INDEX_SHIFT = 0x0D12,
    	///
	    INDEX_WRITEMASK = 0x0C21,
    	///
	    INSTRUMENT_MEASUREMENTS_SGIX = 0x8181,
    	///
	    INTERLACE_SGIX = 0x8094,
    	///
	    IR_INSTRUMENT1_SGIX = 0x817F,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007,
    	///
	    LIGHTING = 0x0B50,
    	///
	    LIGHT_ENV_MODE_SGIX = 0x8407,
    	///
	    LIGHT_MODEL_AMBIENT = 0x0B53,
    	///
	    LIGHT_MODEL_COLOR_CONTROL = 0x81F8,
    	///
	    LIGHT_MODEL_LOCAL_VIEWER = 0x0B51,
    	///
	    LIGHT_MODEL_TWO_SIDE = 0x0B52,
    	///
	    LINE_SMOOTH = 0x0B20,
    	///
	    LINE_SMOOTH_HINT = 0x0C52,
    	///
	    LINE_STIPPLE = 0x0B24,
    	///
	    LINE_STIPPLE_PATTERN = 0x0B25,
    	///
	    LINE_STIPPLE_REPEAT = 0x0B26,
    	///
	    LINE_WIDTH = 0x0B21,
    	///
	    LINE_WIDTH_GRANULARITY = 0x0B23,
    	///
	    LINE_WIDTH_RANGE = 0x0B22,
    	///
	    LIST_BASE = 0x0B32,
    	///
	    LIST_INDEX = 0x0B33,
    	///
	    LIST_MODE = 0x0B30,
    	///
	    LOGIC_OP = 0x0BF1,
    	///
	    LOGIC_OP_MODE = 0x0BF0,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_GRID_DOMAIN = 0x0DD0,
    	///
	    MAP1_GRID_SEGMENTS = 0x0DD1,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_GRID_DOMAIN = 0x0DD2,
    	///
	    MAP2_GRID_SEGMENTS = 0x0DD3,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    MAP_COLOR = 0x0D10,
    	///
	    MAP_STENCIL = 0x0D11,
    	///
	    MATRIX_MODE = 0x0BA0,
    	///
	    MAX_3D_TEXTURE_SIZE_EXT = 0x8073,
    	///
	    MAX_4D_TEXTURE_SIZE_SGIS = 0x8138,
    	///
	    MAX_ACTIVE_LIGHTS_SGIX = 0x8405,
    	///
	    MAX_ASYNC_DRAW_PIXELS_SGIX = 0x8360,
    	///
	    MAX_ASYNC_HISTOGRAM_SGIX = 0x832D,
    	///
	    MAX_ASYNC_READ_PIXELS_SGIX = 0x8361,
    	///
	    MAX_ASYNC_TEX_IMAGE_SGIX = 0x835F,
    	///
	    MAX_ATTRIB_STACK_DEPTH = 0x0D35,
    	///
	    MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B,
    	///
	    MAX_CLIPMAP_DEPTH_SGIX = 0x8177,
    	///
	    MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8178,
    	///
	    MAX_CLIP_DISTANCES = 0x0D32,
    	///
	    MAX_CLIP_PLANES = 0x0D32,
    	///
	    MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B3,
    	///
	    MAX_EVAL_ORDER = 0x0D30,
    	///
	    MAX_FOG_FUNC_POINTS_SGIS = 0x812C,
    	///
	    MAX_FRAGMENT_LIGHTS_SGIX = 0x8404,
    	///
	    MAX_FRAMEZOOM_FACTOR_SGIX = 0x818D,
    	///
	    MAX_LIGHTS = 0x0D31,
    	///
	    MAX_LIST_NESTING = 0x0B31,
    	///
	    MAX_MODELVIEW_STACK_DEPTH = 0x0D36,
    	///
	    MAX_NAME_STACK_DEPTH = 0x0D37,
    	///
	    MAX_PIXEL_MAP_TABLE = 0x0D34,
    	///
	    MAX_PROJECTION_STACK_DEPTH = 0x0D38,
    	///
	    MAX_TEXTURE_SIZE = 0x0D33,
    	///
	    MAX_TEXTURE_STACK_DEPTH = 0x0D39,
    	///
	    MAX_VIEWPORT_DIMS = 0x0D3A,
    	///
	    MINMAX_EXT = 0x802E,
    	///
	    MODELVIEW0_MATRIX_EXT = 0x0BA6,
    	///
	    MODELVIEW0_STACK_DEPTH_EXT = 0x0BA3,
    	///
	    MODELVIEW_MATRIX = 0x0BA6,
    	///
	    MODELVIEW_STACK_DEPTH = 0x0BA3,
    	///
	    MULTISAMPLE_SGIS = 0x809D,
    	///
	    NAME_STACK_DEPTH = 0x0D70,
    	///
	    NORMALIZE = 0x0BA1,
    	///
	    NORMAL_ARRAY = 0x8075,
    	///
	    NORMAL_ARRAY_COUNT_EXT = 0x8080,
    	///
	    NORMAL_ARRAY_STRIDE = 0x807F,
    	///
	    NORMAL_ARRAY_TYPE = 0x807E,
    	///
	    PACK_ALIGNMENT = 0x0D05,
    	///
	    PACK_CMYK_HINT_EXT = 0x800E,
    	///
	    PACK_IMAGE_DEPTH_SGIS = 0x8131,
    	///
	    PACK_IMAGE_HEIGHT_EXT = 0x806C,
    	///
	    PACK_LSB_FIRST = 0x0D01,
    	///
	    PACK_RESAMPLE_SGIX = 0x842E,
    	///
	    PACK_ROW_LENGTH = 0x0D02,
    	///
	    PACK_SKIP_IMAGES_EXT = 0x806B,
    	///
	    PACK_SKIP_PIXELS = 0x0D04,
    	///
	    PACK_SKIP_ROWS = 0x0D03,
    	///
	    PACK_SKIP_VOLUMES_SGIS = 0x8130,
    	///
	    PACK_SUBSAMPLE_RATE_SGIX = 0x85A0,
    	///
	    PACK_SWAP_BYTES = 0x0D00,
    	///
	    PERSPECTIVE_CORRECTION_HINT = 0x0C50,
    	///
	    PIXEL_MAP_A_TO_A_SIZE = 0x0CB9,
    	///
	    PIXEL_MAP_B_TO_B_SIZE = 0x0CB8,
    	///
	    PIXEL_MAP_G_TO_G_SIZE = 0x0CB7,
    	///
	    PIXEL_MAP_I_TO_A_SIZE = 0x0CB5,
    	///
	    PIXEL_MAP_I_TO_B_SIZE = 0x0CB4,
    	///
	    PIXEL_MAP_I_TO_G_SIZE = 0x0CB3,
    	///
	    PIXEL_MAP_I_TO_I_SIZE = 0x0CB0,
    	///
	    PIXEL_MAP_I_TO_R_SIZE = 0x0CB2,
    	///
	    PIXEL_MAP_R_TO_R_SIZE = 0x0CB6,
    	///
	    PIXEL_MAP_S_TO_S_SIZE = 0x0CB1,
    	///
	    PIXEL_TEXTURE_SGIS = 0x8353,
    	///
	    PIXEL_TEX_GEN_MODE_SGIX = 0x832B,
    	///
	    PIXEL_TEX_GEN_SGIX = 0x8139,
    	///
	    PIXEL_TILE_BEST_ALIGNMENT_SGIX = 0x813E,
    	///
	    PIXEL_TILE_CACHE_INCREMENT_SGIX = 0x813F,
    	///
	    PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145,
    	///
	    PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144,
    	///
	    PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143,
    	///
	    PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142,
    	///
	    PIXEL_TILE_HEIGHT_SGIX = 0x8141,
    	///
	    PIXEL_TILE_WIDTH_SGIX = 0x8140,
    	///
	    POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128,
    	///
	    POINT_SIZE = 0x0B11,
    	///
	    POINT_SIZE_GRANULARITY = 0x0B13,
    	///
	    POINT_SIZE_MAX_SGIS = 0x8127,
    	///
	    POINT_SIZE_MIN_SGIS = 0x8126,
    	///
	    POINT_SIZE_RANGE = 0x0B12,
    	///
	    POINT_SMOOTH = 0x0B10,
    	///
	    POINT_SMOOTH_HINT = 0x0C51,
    	///
	    POLYGON_MODE = 0x0B40,
    	///
	    POLYGON_OFFSET_BIAS_EXT = 0x8039,
    	///
	    POLYGON_OFFSET_FACTOR = 0x8038,
    	///
	    POLYGON_OFFSET_FILL = 0x8037,
    	///
	    POLYGON_OFFSET_LINE = 0x2A02,
    	///
	    POLYGON_OFFSET_POINT = 0x2A01,
    	///
	    POLYGON_OFFSET_UNITS = 0x2A00,
    	///
	    POLYGON_SMOOTH = 0x0B41,
    	///
	    POLYGON_SMOOTH_HINT = 0x0C53,
    	///
	    POLYGON_STIPPLE = 0x0B42,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5,
    	///
	    POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F,
    	///
	    POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D,
    	///
	    POST_CONVOLUTION_RED_BIAS_EXT = 0x8020,
    	///
	    POST_CONVOLUTION_RED_SCALE_EXT = 0x801C,
    	///
	    POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 0x817B,
    	///
	    POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 0x817C,
    	///
	    PROJECTION_MATRIX = 0x0BA7,
    	///
	    PROJECTION_STACK_DEPTH = 0x0BA4,
    	///
	    READ_BUFFER = 0x0C02,
    	///
	    READ_BUFFER_EXT = 0x0C02,
    	///
	    READ_BUFFER_NV = 0x0C02,
    	///
	    RED_BIAS = 0x0D15,
    	///
	    RED_BITS = 0x0D52,
    	///
	    RED_SCALE = 0x0D14,
    	///
	    REFERENCE_PLANE_EQUATION_SGIX = 0x817E,
    	///
	    REFERENCE_PLANE_SGIX = 0x817D,
    	///
	    RENDER_MODE = 0x0C40,
    	///
	    RESCALE_NORMAL_EXT = 0x803A,
    	///
	    RGBA_MODE = 0x0C31,
    	///
	    SAMPLES_SGIS = 0x80A9,
    	///
	    SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E,
    	///
	    SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F,
    	///
	    SAMPLE_BUFFERS_SGIS = 0x80A8,
    	///
	    SAMPLE_MASK_INVERT_SGIS = 0x80AB,
    	///
	    SAMPLE_MASK_SGIS = 0x80A0,
    	///
	    SAMPLE_MASK_VALUE_SGIS = 0x80AA,
    	///
	    SAMPLE_PATTERN_SGIS = 0x80AC,
    	///
	    SCISSOR_BOX = 0x0C10,
    	///
	    SCISSOR_TEST = 0x0C11,
    	///
	    SELECTION_BUFFER_SIZE = 0x0DF4,
    	///
	    SEPARABLE_2D_EXT = 0x8012,
    	///
	    SHADE_MODEL = 0x0B54,
    	///
	    SHARED_TEXTURE_PALETTE_EXT = 0x81FB,
    	///
	    SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23,
    	///
	    SMOOTH_LINE_WIDTH_RANGE = 0x0B22,
    	///
	    SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13,
    	///
	    SMOOTH_POINT_SIZE_RANGE = 0x0B12,
    	///
	    SPRITE_AXIS_SGIX = 0x814A,
    	///
	    SPRITE_MODE_SGIX = 0x8149,
    	///
	    SPRITE_SGIX = 0x8148,
    	///
	    SPRITE_TRANSLATION_SGIX = 0x814B,
    	///
	    STENCIL_BITS = 0x0D57,
    	///
	    STENCIL_CLEAR_VALUE = 0x0B91,
    	///
	    STENCIL_FAIL = 0x0B94,
    	///
	    STENCIL_FUNC = 0x0B92,
    	///
	    STENCIL_PASS_DEPTH_FAIL = 0x0B95,
    	///
	    STENCIL_PASS_DEPTH_PASS = 0x0B96,
    	///
	    STENCIL_REF = 0x0B97,
    	///
	    STENCIL_TEST = 0x0B90,
    	///
	    STENCIL_VALUE_MASK = 0x0B93,
    	///
	    STENCIL_WRITEMASK = 0x0B98,
    	///
	    STEREO = 0x0C33,
    	///
	    SUBPIXEL_BITS = 0x0D50,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D_BINDING_EXT = 0x806A,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_4D_BINDING_SGIS = 0x814F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_BINDING_1D = 0x8068,
    	///
	    TEXTURE_BINDING_2D = 0x8069,
    	///
	    TEXTURE_BINDING_3D = 0x806A,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC,
    	///
	    TEXTURE_COORD_ARRAY = 0x8078,
    	///
	    TEXTURE_COORD_ARRAY_COUNT_EXT = 0x808B,
    	///
	    TEXTURE_COORD_ARRAY_SIZE = 0x8088,
    	///
	    TEXTURE_COORD_ARRAY_STRIDE = 0x808A,
    	///
	    TEXTURE_COORD_ARRAY_TYPE = 0x8089,
    	///
	    TEXTURE_GEN_Q = 0x0C63,
    	///
	    TEXTURE_GEN_R = 0x0C62,
    	///
	    TEXTURE_GEN_S = 0x0C60,
    	///
	    TEXTURE_GEN_T = 0x0C61,
    	///
	    TEXTURE_MATRIX = 0x0BA8,
    	///
	    TEXTURE_STACK_DEPTH = 0x0BA5,
    	///
	    UNPACK_ALIGNMENT = 0x0CF5,
    	///
	    UNPACK_CMYK_HINT_EXT = 0x800F,
    	///
	    UNPACK_IMAGE_DEPTH_SGIS = 0x8133,
    	///
	    UNPACK_IMAGE_HEIGHT_EXT = 0x806E,
    	///
	    UNPACK_LSB_FIRST = 0x0CF1,
    	///
	    UNPACK_RESAMPLE_SGIX = 0x842F,
    	///
	    UNPACK_ROW_LENGTH = 0x0CF2,
    	///
	    UNPACK_SKIP_IMAGES_EXT = 0x806D,
    	///
	    UNPACK_SKIP_PIXELS = 0x0CF4,
    	///
	    UNPACK_SKIP_ROWS = 0x0CF3,
    	///
	    UNPACK_SKIP_VOLUMES_SGIS = 0x8132,
    	///
	    UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1,
    	///
	    UNPACK_SWAP_BYTES = 0x0CF0,
    	///
	    VERTEX_ARRAY = 0x8074,
    	///
	    VERTEX_ARRAY_COUNT_EXT = 0x807D,
    	///
	    VERTEX_ARRAY_SIZE = 0x807A,
    	///
	    VERTEX_ARRAY_STRIDE = 0x807C,
    	///
	    VERTEX_ARRAY_TYPE = 0x807B,
    	///
	    VERTEX_PRECLIP_HINT_SGIX = 0x83EF,
    	///
	    VERTEX_PRECLIP_SGIX = 0x83EE,
    	///
	    VIEWPORT = 0x0BA2,
    	///
	    ZOOM_X = 0x0D16,
    	///
	    ZOOM_Y = 0x0D17
	}

	///
	enum GetPointervPName {
    	///
	    COLOR_ARRAY_POINTER = 0x8090,
    	///
	    COLOR_ARRAY_POINTER_EXT = 0x8090,
    	///
	    EDGE_FLAG_ARRAY_POINTER = 0x8093,
    	///
	    EDGE_FLAG_ARRAY_POINTER_EXT = 0x8093,
    	///
	    FEEDBACK_BUFFER_POINTER = 0x0DF0,
    	///
	    INDEX_ARRAY_POINTER = 0x8091,
    	///
	    INDEX_ARRAY_POINTER_EXT = 0x8091,
    	///
	    INSTRUMENT_BUFFER_POINTER_SGIX = 0x8180,
    	///
	    NORMAL_ARRAY_POINTER = 0x808F,
    	///
	    NORMAL_ARRAY_POINTER_EXT = 0x808F,
    	///
	    SELECTION_BUFFER_POINTER = 0x0DF3,
    	///
	    TEXTURE_COORD_ARRAY_POINTER = 0x8092,
    	///
	    TEXTURE_COORD_ARRAY_POINTER_EXT = 0x8092,
    	///
	    VERTEX_ARRAY_POINTER = 0x808E,
    	///
	    VERTEX_ARRAY_POINTER_EXT = 0x808E
	}

	///
	enum GetTextureParameter {
    	///
	    DETAIL_TEXTURE_FUNC_POINTS_SGIS = 0x809C,
    	///
	    DETAIL_TEXTURE_LEVEL_SGIS = 0x809A,
    	///
	    DETAIL_TEXTURE_MODE_SGIS = 0x809B,
    	///
	    DUAL_TEXTURE_SELECT_SGIS = 0x8124,
    	///
	    GENERATE_MIPMAP_SGIS = 0x8191,
    	///
	    POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179,
    	///
	    POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A,
    	///
	    QUAD_TEXTURE_SELECT_SGIS = 0x8125,
    	///
	    SHADOW_AMBIENT_SGIX = 0x80BF,
    	///
	    SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 0x80B0,
    	///
	    TEXTURE_4DSIZE_SGIS = 0x8136,
    	///
	    TEXTURE_ALPHA_SIZE = 0x805F,
    	///
	    TEXTURE_BASE_LEVEL_SGIS = 0x813C,
    	///
	    TEXTURE_BLUE_SIZE = 0x805E,
    	///
	    TEXTURE_BORDER = 0x1005,
    	///
	    TEXTURE_BORDER_COLOR = 0x1004,
    	///
	    TEXTURE_BORDER_COLOR_NV = 0x1004,
    	///
	    TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171,
    	///
	    TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176,
    	///
	    TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172,
    	///
	    TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175,
    	///
	    TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173,
    	///
	    TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174,
    	///
	    TEXTURE_COMPARE_OPERATOR_SGIX = 0x819B,
    	///
	    TEXTURE_COMPARE_SGIX = 0x819A,
    	///
	    TEXTURE_COMPONENTS = 0x1003,
    	///
	    TEXTURE_DEPTH_EXT = 0x8071,
    	///
	    TEXTURE_FILTER4_SIZE_SGIS = 0x8147,
    	///
	    TEXTURE_GEQUAL_R_SGIX = 0x819D,
    	///
	    TEXTURE_GREEN_SIZE = 0x805D,
    	///
	    TEXTURE_HEIGHT = 0x1001,
    	///
	    TEXTURE_INTENSITY_SIZE = 0x8061,
    	///
	    TEXTURE_INTERNAL_FORMAT = 0x1003,
    	///
	    TEXTURE_LEQUAL_R_SGIX = 0x819C,
    	///
	    TEXTURE_LOD_BIAS_R_SGIX = 0x8190,
    	///
	    TEXTURE_LOD_BIAS_S_SGIX = 0x818E,
    	///
	    TEXTURE_LOD_BIAS_T_SGIX = 0x818F,
    	///
	    TEXTURE_LUMINANCE_SIZE = 0x8060,
    	///
	    TEXTURE_MAG_FILTER = 0x2800,
    	///
	    TEXTURE_MAX_CLAMP_R_SGIX = 0x836B,
    	///
	    TEXTURE_MAX_CLAMP_S_SGIX = 0x8369,
    	///
	    TEXTURE_MAX_CLAMP_T_SGIX = 0x836A,
    	///
	    TEXTURE_MAX_LEVEL_SGIS = 0x813D,
    	///
	    TEXTURE_MAX_LOD_SGIS = 0x813B,
    	///
	    TEXTURE_MIN_FILTER = 0x2801,
    	///
	    TEXTURE_MIN_LOD_SGIS = 0x813A,
    	///
	    TEXTURE_PRIORITY = 0x8066,
    	///
	    TEXTURE_RED_SIZE = 0x805C,
    	///
	    TEXTURE_RESIDENT = 0x8067,
    	///
	    TEXTURE_WIDTH = 0x1000,
    	///
	    TEXTURE_WRAP_Q_SGIS = 0x8137,
    	///
	    TEXTURE_WRAP_R_EXT = 0x8072,
    	///
	    TEXTURE_WRAP_S = 0x2802,
    	///
	    TEXTURE_WRAP_T = 0x2803
	}

	///
	enum HintMode {
    	///
	    DONT_CARE = 0x1100,
    	///
	    FASTEST = 0x1101,
    	///
	    NICEST = 0x1102
	}

	///
	enum HintTarget {
    	///
	    ALLOW_DRAW_FRG_HINT_PGI = 0x1A210,
    	///
	    ALLOW_DRAW_MEM_HINT_PGI = 0x1A211,
    	///
	    ALLOW_DRAW_OBJ_HINT_PGI = 0x1A20E,
    	///
	    ALLOW_DRAW_WIN_HINT_PGI = 0x1A20F,
    	///
	    ALWAYS_FAST_HINT_PGI = 0x1A20C,
    	///
	    ALWAYS_SOFT_HINT_PGI = 0x1A20D,
    	///
	    BACK_NORMALS_HINT_PGI = 0x1A223,
    	///
	    BINNING_CONTROL_HINT_QCOM = 0x8FB0,
    	///
	    CLIP_FAR_HINT_PGI = 0x1A221,
    	///
	    CLIP_NEAR_HINT_PGI = 0x1A220,
    	///
	    CLIP_VOLUME_CLIPPING_HINT_EXT = 0x80F0,
    	///
	    CONSERVE_MEMORY_HINT_PGI = 0x1A1FD,
    	///
	    CONVOLUTION_HINT_SGIX = 0x8316,
    	///
	    FOG_HINT = 0x0C54,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 0x8B8B,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B,
    	///
	    FULL_STIPPLE_HINT_PGI = 0x1A219,
    	///
	    GENERATE_MIPMAP_HINT = 0x8192,
    	///
	    GENERATE_MIPMAP_HINT_SGIS = 0x8192,
    	///
	    LINE_QUALITY_HINT_SGIX = 0x835B,
    	///
	    LINE_SMOOTH_HINT = 0x0C52,
    	///
	    MATERIAL_SIDE_HINT_PGI = 0x1A22C,
    	///
	    MAX_VERTEX_HINT_PGI = 0x1A22D,
    	///
	    MULTISAMPLE_FILTER_HINT_NV = 0x8534,
    	///
	    NATIVE_GRAPHICS_BEGIN_HINT_PGI = 0x1A203,
    	///
	    NATIVE_GRAPHICS_END_HINT_PGI = 0x1A204,
    	///
	    PACK_CMYK_HINT_EXT = 0x800E,
    	///
	    PERSPECTIVE_CORRECTION_HINT = 0x0C50,
    	///
	    PHONG_HINT_WIN = 0x80EB,
    	///
	    POINT_SMOOTH_HINT = 0x0C51,
    	///
	    POLYGON_SMOOTH_HINT = 0x0C53,
    	///
	    PREFER_DOUBLEBUFFER_HINT_PGI = 0x1A1F8,
    	///
	    PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257,
    	///
	    RECLAIM_MEMORY_HINT_PGI = 0x1A1FE,
    	///
	    SCALEBIAS_HINT_SGIX = 0x8322,
    	///
	    STRICT_DEPTHFUNC_HINT_PGI = 0x1A216,
    	///
	    STRICT_LIGHTING_HINT_PGI = 0x1A217,
    	///
	    STRICT_SCISSOR_HINT_PGI = 0x1A218,
    	///
	    TEXTURE_COMPRESSION_HINT = 0x84EF,
    	///
	    TEXTURE_COMPRESSION_HINT_ARB = 0x84EF,
    	///
	    TEXTURE_MULTI_BUFFER_HINT_SGIX = 0x812E,
    	///
	    TEXTURE_STORAGE_HINT_APPLE = 0x85BC,
    	///
	    TRANSFORM_HINT_APPLE = 0x85B1,
    	///
	    UNPACK_CMYK_HINT_EXT = 0x800F,
    	///
	    VERTEX_ARRAY_STORAGE_HINT_APPLE = 0x851F,
    	///
	    VERTEX_CONSISTENT_HINT_PGI = 0x1A22B,
    	///
	    VERTEX_DATA_HINT_PGI = 0x1A22A,
    	///
	    VERTEX_PRECLIP_HINT_SGIX = 0x83EF,
    	///
	    VERTEX_PRECLIP_SGIX = 0x83EE,
    	///
	    WIDE_LINE_HINT_PGI = 0x1A222
	}

	///
	enum HistogramTargetEXT {
    	///
	    HISTOGRAM = 0x8024,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    PROXY_HISTOGRAM = 0x8025,
    	///
	    PROXY_HISTOGRAM_EXT = 0x8025
	}

	///
	enum IndexPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum InterleavedArrayFormat {
    	///
	    C3F_V3F = 0x2A24,
    	///
	    C4F_N3F_V3F = 0x2A26,
    	///
	    C4UB_V2F = 0x2A22,
    	///
	    C4UB_V3F = 0x2A23,
    	///
	    N3F_V3F = 0x2A25,
    	///
	    T2F_C3F_V3F = 0x2A2A,
    	///
	    T2F_C4F_N3F_V3F = 0x2A2C,
    	///
	    T2F_C4UB_V3F = 0x2A29,
    	///
	    T2F_N3F_V3F = 0x2A2B,
    	///
	    T2F_V3F = 0x2A27,
    	///
	    T4F_C4F_N3F_V4F = 0x2A2D,
    	///
	    T4F_V4F = 0x2A28,
    	///
	    V2F = 0x2A20,
    	///
	    V3F = 0x2A21
	}

	///
	enum LightEnvModeSGIX {
    	///
	    ADD = 0x0104,
    	///
	    MODULATE = 0x2100,
    	///
	    REPLACE = 0x1E01
	}

	///
	enum LightEnvParameterSGIX {
    	///
	    LIGHT_ENV_MODE_SGIX = 0x8407
	}

	///
	enum LightModelColorControl {
    	///
	    SEPARATE_SPECULAR_COLOR = 0x81FA,
    	///
	    SEPARATE_SPECULAR_COLOR_EXT = 0x81FA,
    	///
	    SINGLE_COLOR = 0x81F9,
    	///
	    SINGLE_COLOR_EXT = 0x81F9
	}

	///
	enum LightModelParameter {
    	///
	    LIGHT_MODEL_AMBIENT = 0x0B53,
    	///
	    LIGHT_MODEL_COLOR_CONTROL = 0x81F8,
    	///
	    LIGHT_MODEL_COLOR_CONTROL_EXT = 0x81F8,
    	///
	    LIGHT_MODEL_LOCAL_VIEWER = 0x0B51,
    	///
	    LIGHT_MODEL_TWO_SIDE = 0x0B52
	}

	///
	enum LightName {
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHT1_SGIX = 0x840D,
    	///
	    FRAGMENT_LIGHT2_SGIX = 0x840E,
    	///
	    FRAGMENT_LIGHT3_SGIX = 0x840F,
    	///
	    FRAGMENT_LIGHT4_SGIX = 0x8410,
    	///
	    FRAGMENT_LIGHT5_SGIX = 0x8411,
    	///
	    FRAGMENT_LIGHT6_SGIX = 0x8412,
    	///
	    FRAGMENT_LIGHT7_SGIX = 0x8413,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007
	}

	///
	enum LightParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    CONSTANT_ATTENUATION = 0x1207,
    	///
	    DIFFUSE = 0x1201,
    	///
	    LINEAR_ATTENUATION = 0x1208,
    	///
	    POSITION = 0x1203,
    	///
	    QUADRATIC_ATTENUATION = 0x1209,
    	///
	    SPECULAR = 0x1202,
    	///
	    SPOT_CUTOFF = 0x1206,
    	///
	    SPOT_DIRECTION = 0x1204,
    	///
	    SPOT_EXPONENT = 0x1205
	}

	///
	enum ListMode {
    	///
	    COMPILE = 0x1300,
    	///
	    COMPILE_AND_EXECUTE = 0x1301
	}

	///
	enum ListNameType {
    	///
	    BYTES_2 = 0x1407,
    	///
	    BYTES_3 = 0x1408,
    	///
	    BYTES_4 = 0x1409,
    	///
	    BYTE = 0x1400,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403
	}

	///
	enum ListParameterName {
    	///
	    LIST_PRIORITY_SGIX = 0x8182
	}

	///
	enum LogicOp {
    	///
	    AND = 0x1501,
    	///
	    AND_INVERTED = 0x1504,
    	///
	    AND_REVERSE = 0x1502,
    	///
	    CLEAR = 0x1500,
    	///
	    COPY = 0x1503,
    	///
	    COPY_INVERTED = 0x150C,
    	///
	    EQUIV = 0x1509,
    	///
	    INVERT = 0x150A,
    	///
	    NAND = 0x150E,
    	///
	    NOOP = 0x1505,
    	///
	    NOR = 0x1508,
    	///
	    OR = 0x1507,
    	///
	    OR_INVERTED = 0x150D,
    	///
	    OR_REVERSE = 0x150B,
    	///
	    SET = 0x150F,
    	///
	    XOR = 0x1506
	}

	///
	@Bitmaskable
	enum MapBufferUsageMask {
    	///
	    CLIENT_STORAGE_BIT = 0x0200,
    	///
	    DYNAMIC_STORAGE_BIT = 0x0100,
    	///
	    MAP_COHERENT_BIT = 0x0080,
    	///
	    MAP_FLUSH_EXPLICIT_BIT = 0x0010,
    	///
	    MAP_FLUSH_EXPLICIT_BIT_EXT = 0x0010,
    	///
	    MAP_INVALIDATE_BUFFER_BIT = 0x0008,
    	///
	    MAP_INVALIDATE_BUFFER_BIT_EXT = 0x0008,
    	///
	    MAP_INVALIDATE_RANGE_BIT = 0x0004,
    	///
	    MAP_INVALIDATE_RANGE_BIT_EXT = 0x0004,
    	///
	    MAP_PERSISTENT_BIT = 0x0040,
    	///
	    MAP_READ_BIT = 0x0001,
    	///
	    MAP_READ_BIT_EXT = 0x0001,
    	///
	    MAP_UNSYNCHRONIZED_BIT = 0x0020,
    	///
	    MAP_UNSYNCHRONIZED_BIT_EXT = 0x0020,
    	///
	    MAP_WRITE_BIT = 0x0002,
    	///
	    MAP_WRITE_BIT_EXT = 0x0002
	}

	///
	enum MapTarget {
    	///
	    GEOMETRY_DEFORMATION_SGIX = 0x8194,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    TEXTURE_DEFORMATION_SGIX = 0x8195
	}

	///
	enum MapTextureFormatINTEL {
    	///
	    LAYOUT_DEFAULT_INTEL = 0,
    	///
	    LAYOUT_LINEAR_CPU_CACHED_INTEL = 2,
    	///
	    LAYOUT_LINEAR_INTEL = 1
	}

	///
	enum MaterialFace {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum MaterialParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    AMBIENT_AND_DIFFUSE = 0x1602,
    	///
	    COLOR_INDEXES = 0x1603,
    	///
	    DIFFUSE = 0x1201,
    	///
	    EMISSION = 0x1600,
    	///
	    SHININESS = 0x1601,
    	///
	    SPECULAR = 0x1202
	}

	///
	enum MatrixMode {
    	///
	    MODELVIEW = 0x1700,
    	///
	    MODELVIEW0_EXT = 0x1700,
    	///
	    PROJECTION = 0x1701,
    	///
	    TEXTURE = 0x1702
	}

	///
	@Bitmaskable
	enum MemoryBarrierMask {
    	///
	    ALL_BARRIER_BITS = 0xFFFFFFFF,
    	///
	    ALL_BARRIER_BITS_EXT = 0xFFFFFFFF,
    	///
	    ATOMIC_COUNTER_BARRIER_BIT = 0x00001000,
    	///
	    ATOMIC_COUNTER_BARRIER_BIT_EXT = 0x00001000,
    	///
	    BUFFER_UPDATE_BARRIER_BIT = 0x00000200,
    	///
	    BUFFER_UPDATE_BARRIER_BIT_EXT = 0x00000200,
    	///
	    CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000,
    	///
	    COMMAND_BARRIER_BIT = 0x00000040,
    	///
	    COMMAND_BARRIER_BIT_EXT = 0x00000040,
    	///
	    ELEMENT_ARRAY_BARRIER_BIT = 0x00000002,
    	///
	    ELEMENT_ARRAY_BARRIER_BIT_EXT = 0x00000002,
    	///
	    FRAMEBUFFER_BARRIER_BIT = 0x00000400,
    	///
	    FRAMEBUFFER_BARRIER_BIT_EXT = 0x00000400,
    	///
	    PIXEL_BUFFER_BARRIER_BIT = 0x00000080,
    	///
	    PIXEL_BUFFER_BARRIER_BIT_EXT = 0x00000080,
    	///
	    QUERY_BUFFER_BARRIER_BIT = 0x00008000,
    	///
	    SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = 0x00000010,
    	///
	    SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020,
    	///
	    SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = 0x00000020,
    	///
	    SHADER_STORAGE_BARRIER_BIT = 0x00002000,
    	///
	    TEXTURE_FETCH_BARRIER_BIT = 0x00000008,
    	///
	    TEXTURE_FETCH_BARRIER_BIT_EXT = 0x00000008,
    	///
	    TEXTURE_UPDATE_BARRIER_BIT = 0x00000100,
    	///
	    TEXTURE_UPDATE_BARRIER_BIT_EXT = 0x00000100,
    	///
	    TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800,
    	///
	    TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = 0x00000800,
    	///
	    UNIFORM_BARRIER_BIT = 0x00000004,
    	///
	    UNIFORM_BARRIER_BIT_EXT = 0x00000004,
    	///
	    VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001,
    	///
	    VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = 0x00000001
	}

	///
	enum MeshMode1 {
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum MeshMode2 {
    	///
	    FILL = 0x1B02,
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum MinmaxTargetEXT {
    	///
	    MINMAX = 0x802E,
    	///
	    MINMAX_EXT = 0x802E
	}

	///
	enum NormalPointerType {
    	///
	    BYTE = 0x1400,
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum PixelCopyType {
    	///
	    COLOR = 0x1800,
    	///
	    COLOR_EXT = 0x1800,
    	///
	    DEPTH = 0x1801,
    	///
	    DEPTH_EXT = 0x1801,
    	///
	    STENCIL = 0x1802,
    	///
	    STENCIL_EXT = 0x1802
	}

	///
	enum PixelFormat {
    	///
	    ABGR_EXT = 0x8000,
    	///
	    ALPHA = 0x1906,
    	///
	    BLUE = 0x1905,
    	///
	    CMYKA_EXT = 0x800D,
    	///
	    CMYK_EXT = 0x800C,
    	///
	    COLOR_INDEX = 0x1900,
    	///
	    DEPTH_COMPONENT = 0x1902,
    	///
	    GREEN = 0x1904,
    	///
	    LUMINANCE = 0x1909,
    	///
	    LUMINANCE_ALPHA = 0x190A,
    	///
	    RED = 0x1903,
    	///
	    RED_EXT = 0x1903,
    	///
	    RGB = 0x1907,
    	///
	    RGBA = 0x1908,
    	///
	    STENCIL_INDEX = 0x1901,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403,
    	///
	    YCRCB_422_SGIX = 0x81BB,
    	///
	    YCRCB_444_SGIX = 0x81BC
	}

	///
	enum InternalFormat {
    	///
	    ALPHA12 = 0x803D,
    	///
	    ALPHA16 = 0x803E,
    	///
	    ALPHA4 = 0x803B,
    	///
	    ALPHA8 = 0x803C,
    	///
	    DEPTH_COMPONENT16_SGIX = 0x81A5,
    	///
	    DEPTH_COMPONENT24_SGIX = 0x81A6,
    	///
	    DEPTH_COMPONENT32_SGIX = 0x81A7,
    	///
	    DUAL_ALPHA12_SGIS = 0x8112,
    	///
	    DUAL_ALPHA16_SGIS = 0x8113,
    	///
	    DUAL_ALPHA4_SGIS = 0x8110,
    	///
	    DUAL_ALPHA8_SGIS = 0x8111,
    	///
	    DUAL_INTENSITY12_SGIS = 0x811A,
    	///
	    DUAL_INTENSITY16_SGIS = 0x811B,
    	///
	    DUAL_INTENSITY4_SGIS = 0x8118,
    	///
	    DUAL_INTENSITY8_SGIS = 0x8119,
    	///
	    DUAL_LUMINANCE12_SGIS = 0x8116,
    	///
	    DUAL_LUMINANCE16_SGIS = 0x8117,
    	///
	    DUAL_LUMINANCE4_SGIS = 0x8114,
    	///
	    DUAL_LUMINANCE8_SGIS = 0x8115,
    	///
	    DUAL_LUMINANCE_ALPHA4_SGIS = 0x811C,
    	///
	    DUAL_LUMINANCE_ALPHA8_SGIS = 0x811D,
    	///
	    INTENSITY = 0x8049,
    	///
	    INTENSITY12 = 0x804C,
    	///
	    INTENSITY16 = 0x804D,
    	///
	    INTENSITY4 = 0x804A,
    	///
	    INTENSITY8 = 0x804B,
    	///
	    LUMINANCE12 = 0x8041,
    	///
	    LUMINANCE12_ALPHA12 = 0x8047,
    	///
	    LUMINANCE12_ALPHA4 = 0x8046,
    	///
	    LUMINANCE16 = 0x8042,
    	///
	    LUMINANCE16_ALPHA16 = 0x8048,
    	///
	    LUMINANCE4 = 0x803F,
    	///
	    LUMINANCE4_ALPHA4 = 0x8043,
    	///
	    LUMINANCE6_ALPHA2 = 0x8044,
    	///
	    LUMINANCE8 = 0x8040,
    	///
	    LUMINANCE8_ALPHA8 = 0x8045,
    	///
	    QUAD_ALPHA4_SGIS = 0x811E,
    	///
	    QUAD_ALPHA8_SGIS = 0x811F,
    	///
	    QUAD_INTENSITY4_SGIS = 0x8122,
    	///
	    QUAD_INTENSITY8_SGIS = 0x8123,
    	///
	    QUAD_LUMINANCE4_SGIS = 0x8120,
    	///
	    QUAD_LUMINANCE8_SGIS = 0x8121,
    	///
	    R3_G3_B2 = 0x2A10,
    	///
	    RGB10 = 0x8052,
    	///
	    RGB10_A2 = 0x8059,
    	///
	    RGB12 = 0x8053,
    	///
	    RGB16 = 0x8054,
    	///
	    RGB2_EXT = 0x804E,
    	///
	    RGB4 = 0x804F,
    	///
	    RGB5 = 0x8050,
    	///
	    RGB5_A1 = 0x8057,
    	///
	    RGB8 = 0x8051,
    	///
	    RGBA12 = 0x805A,
    	///
	    RGBA16 = 0x805B,
    	///
	    RGBA2 = 0x8055,
    	///
	    RGBA4 = 0x8056,
    	///
	    RGBA8 = 0x8058
	}

	///
	enum PixelMap {
    	///
	    PIXEL_MAP_A_TO_A = 0x0C79,
    	///
	    PIXEL_MAP_B_TO_B = 0x0C78,
    	///
	    PIXEL_MAP_G_TO_G = 0x0C77,
    	///
	    PIXEL_MAP_I_TO_A = 0x0C75,
    	///
	    PIXEL_MAP_I_TO_B = 0x0C74,
    	///
	    PIXEL_MAP_I_TO_G = 0x0C73,
    	///
	    PIXEL_MAP_I_TO_I = 0x0C70,
    	///
	    PIXEL_MAP_I_TO_R = 0x0C72,
    	///
	    PIXEL_MAP_R_TO_R = 0x0C76,
    	///
	    PIXEL_MAP_S_TO_S = 0x0C71
	}

	///
	enum PixelStoreParameter {
    	///
	    PACK_ALIGNMENT = 0x0D05,
    	///
	    PACK_IMAGE_DEPTH_SGIS = 0x8131,
    	///
	    PACK_IMAGE_HEIGHT = 0x806C,
    	///
	    PACK_IMAGE_HEIGHT_EXT = 0x806C,
    	///
	    PACK_LSB_FIRST = 0x0D01,
    	///
	    PACK_RESAMPLE_OML = 0x8984,
    	///
	    PACK_RESAMPLE_SGIX = 0x842E,
    	///
	    PACK_ROW_LENGTH = 0x0D02,
    	///
	    PACK_SKIP_IMAGES = 0x806B,
    	///
	    PACK_SKIP_IMAGES_EXT = 0x806B,
    	///
	    PACK_SKIP_PIXELS = 0x0D04,
    	///
	    PACK_SKIP_ROWS = 0x0D03,
    	///
	    PACK_SKIP_VOLUMES_SGIS = 0x8130,
    	///
	    PACK_SUBSAMPLE_RATE_SGIX = 0x85A0,
    	///
	    PACK_SWAP_BYTES = 0x0D00,
    	///
	    PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145,
    	///
	    PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144,
    	///
	    PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143,
    	///
	    PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142,
    	///
	    PIXEL_TILE_HEIGHT_SGIX = 0x8141,
    	///
	    PIXEL_TILE_WIDTH_SGIX = 0x8140,
    	///
	    UNPACK_ALIGNMENT = 0x0CF5,
    	///
	    UNPACK_IMAGE_DEPTH_SGIS = 0x8133,
    	///
	    UNPACK_IMAGE_HEIGHT = 0x806E,
    	///
	    UNPACK_IMAGE_HEIGHT_EXT = 0x806E,
    	///
	    UNPACK_LSB_FIRST = 0x0CF1,
    	///
	    UNPACK_RESAMPLE_OML = 0x8985,
    	///
	    UNPACK_RESAMPLE_SGIX = 0x842F,
    	///
	    UNPACK_ROW_LENGTH = 0x0CF2,
    	///
	    UNPACK_ROW_LENGTH_EXT = 0x0CF2,
    	///
	    UNPACK_SKIP_IMAGES = 0x806D,
    	///
	    UNPACK_SKIP_IMAGES_EXT = 0x806D,
    	///
	    UNPACK_SKIP_PIXELS = 0x0CF4,
    	///
	    UNPACK_SKIP_PIXELS_EXT = 0x0CF4,
    	///
	    UNPACK_SKIP_ROWS = 0x0CF3,
    	///
	    UNPACK_SKIP_ROWS_EXT = 0x0CF3,
    	///
	    UNPACK_SKIP_VOLUMES_SGIS = 0x8132,
    	///
	    UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1,
    	///
	    UNPACK_SWAP_BYTES = 0x0CF0
	}

	///
	enum PixelStoreResampleMode {
    	///
	    RESAMPLE_DECIMATE_SGIX = 0x8430,
    	///
	    RESAMPLE_REPLICATE_SGIX = 0x8433,
    	///
	    RESAMPLE_ZERO_FILL_SGIX = 0x8434
	}

	///
	enum PixelStoreSubsampleRate {
    	///
	    PIXEL_SUBSAMPLE_2424_SGIX = 0x85A3,
    	///
	    PIXEL_SUBSAMPLE_4242_SGIX = 0x85A4,
    	///
	    PIXEL_SUBSAMPLE_4444_SGIX = 0x85A2
	}

	///
	enum PixelTexGenMode {
    	///
	    LUMINANCE = 0x1909,
    	///
	    LUMINANCE_ALPHA = 0x190A,
    	///
	    NONE = 0,
    	///
	    PIXEL_TEX_GEN_ALPHA_LS_SGIX = 0x8189,
    	///
	    PIXEL_TEX_GEN_ALPHA_MS_SGIX = 0x818A,
    	///
	    PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 0x8188,
    	///
	    PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 0x8187,
    	///
	    RGB = 0x1907,
    	///
	    RGBA = 0x1908
	}

	///
	enum PixelTexGenParameterNameSGIS {
    	///
	    PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 0x8355,
    	///
	    PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 0x8354
	}

	///
	enum PixelTransferParameter {
    	///
	    ALPHA_BIAS = 0x0D1D,
    	///
	    ALPHA_SCALE = 0x0D1C,
    	///
	    BLUE_BIAS = 0x0D1B,
    	///
	    BLUE_SCALE = 0x0D1A,
    	///
	    DEPTH_BIAS = 0x0D1F,
    	///
	    DEPTH_SCALE = 0x0D1E,
    	///
	    GREEN_BIAS = 0x0D19,
    	///
	    GREEN_SCALE = 0x0D18,
    	///
	    INDEX_OFFSET = 0x0D13,
    	///
	    INDEX_SHIFT = 0x0D12,
    	///
	    MAP_COLOR = 0x0D10,
    	///
	    MAP_STENCIL = 0x0D11,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE = 0x80B7,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE = 0x80B5,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5,
    	///
	    POST_COLOR_MATRIX_RED_BIAS = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_SCALE = 0x80B4,
    	///
	    POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE = 0x801F,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F,
    	///
	    POST_CONVOLUTION_BLUE_BIAS = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_SCALE = 0x801E,
    	///
	    POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E,
    	///
	    POST_CONVOLUTION_GREEN_BIAS = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_SCALE = 0x801D,
    	///
	    POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D,
    	///
	    POST_CONVOLUTION_RED_BIAS = 0x8020,
    	///
	    POST_CONVOLUTION_RED_BIAS_EXT = 0x8020,
    	///
	    POST_CONVOLUTION_RED_SCALE = 0x801C,
    	///
	    POST_CONVOLUTION_RED_SCALE_EXT = 0x801C,
    	///
	    RED_BIAS = 0x0D15,
    	///
	    RED_SCALE = 0x0D14
	}

	///
	enum PixelType {
    	///
	    BITMAP = 0x1A00,
    	///
	    BYTE = 0x1400,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_BYTE_3_3_2 = 0x8032,
    	///
	    UNSIGNED_BYTE_3_3_2_EXT = 0x8032,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_INT_10_10_10_2 = 0x8036,
    	///
	    UNSIGNED_INT_10_10_10_2_EXT = 0x8036,
    	///
	    UNSIGNED_INT_8_8_8_8 = 0x8035,
    	///
	    UNSIGNED_INT_8_8_8_8_EXT = 0x8035,
    	///
	    UNSIGNED_SHORT = 0x1403,
    	///
	    UNSIGNED_SHORT_4_4_4_4 = 0x8033,
    	///
	    UNSIGNED_SHORT_4_4_4_4_EXT = 0x8033,
    	///
	    UNSIGNED_SHORT_5_5_5_1 = 0x8034,
    	///
	    UNSIGNED_SHORT_5_5_5_1_EXT = 0x8034
	}

	///
	enum PointParameterNameSGIS {
    	///
	    DISTANCE_ATTENUATION_EXT = 0x8129,
    	///
	    DISTANCE_ATTENUATION_SGIS = 0x8129,
    	///
	    POINT_DISTANCE_ATTENUATION = 0x8129,
    	///
	    POINT_DISTANCE_ATTENUATION_ARB = 0x8129,
    	///
	    POINT_FADE_THRESHOLD_SIZE = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_ARB = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_EXT = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128,
    	///
	    POINT_SIZE_MAX = 0x8127,
    	///
	    POINT_SIZE_MAX_ARB = 0x8127,
    	///
	    POINT_SIZE_MAX_EXT = 0x8127,
    	///
	    POINT_SIZE_MAX_SGIS = 0x8127,
    	///
	    POINT_SIZE_MIN = 0x8126,
    	///
	    POINT_SIZE_MIN_ARB = 0x8126,
    	///
	    POINT_SIZE_MIN_EXT = 0x8126,
    	///
	    POINT_SIZE_MIN_SGIS = 0x8126
	}

	///
	enum PolygonMode {
    	///
	    FILL = 0x1B02,
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum PrimitiveType {
    	///
	    LINES = 0x0001,
    	///
	    LINES_ADJACENCY = 0x000A,
    	///
	    LINES_ADJACENCY_ARB = 0x000A,
    	///
	    LINES_ADJACENCY_EXT = 0x000A,
    	///
	    LINE_LOOP = 0x0002,
    	///
	    LINE_STRIP = 0x0003,
    	///
	    LINE_STRIP_ADJACENCY = 0x000B,
    	///
	    LINE_STRIP_ADJACENCY_ARB = 0x000B,
    	///
	    LINE_STRIP_ADJACENCY_EXT = 0x000B,
    	///
	    PATCHES = 0x000E,
    	///
	    PATCHES_EXT = 0x000E,
    	///
	    POINTS = 0x0000,
    	///
	    POLYGON = 0x0009,
    	///
	    QUADS = 0x0007,
    	///
	    QUADS_EXT = 0x0007,
    	///
	    QUAD_STRIP = 0x0008,
    	///
	    TRIANGLES = 0x0004,
    	///
	    TRIANGLES_ADJACENCY = 0x000C,
    	///
	    TRIANGLES_ADJACENCY_ARB = 0x000C,
    	///
	    TRIANGLES_ADJACENCY_EXT = 0x000C,
    	///
	    TRIANGLE_FAN = 0x0006,
    	///
	    TRIANGLE_STRIP = 0x0005,
    	///
	    TRIANGLE_STRIP_ADJACENCY = 0x000D,
    	///
	    TRIANGLE_STRIP_ADJACENCY_ARB = 0x000D,
    	///
	    TRIANGLE_STRIP_ADJACENCY_EXT = 0x000D
	}

	///
	@Bitmaskable
	enum OcclusionQueryEventMaskAMD {
    	///
	    QUERY_DEPTH_PASS_EVENT_BIT_AMD = 0x00000001,
    	///
	    QUERY_DEPTH_FAIL_EVENT_BIT_AMD = 0x00000002,
    	///
	    QUERY_STENCIL_FAIL_EVENT_BIT_AMD = 0x00000004,
    	///
	    QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = 0x00000008,
    	///
	    QUERY_ALL_EVENT_BITS_AMD = 0xFFFFFFFF
	}

	///
	enum ReadBufferMode {
    	///
	    AUX0 = 0x0409,
    	///
	    AUX1 = 0x040A,
    	///
	    AUX2 = 0x040B,
    	///
	    AUX3 = 0x040C,
    	///
	    BACK = 0x0405,
    	///
	    BACK_LEFT = 0x0402,
    	///
	    BACK_RIGHT = 0x0403,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_LEFT = 0x0400,
    	///
	    FRONT_RIGHT = 0x0401,
    	///
	    LEFT = 0x0406,
    	///
	    RIGHT = 0x0407
	}

	///
	enum RenderingMode {
    	///
	    FEEDBACK = 0x1C01,
    	///
	    RENDER = 0x1C00,
    	///
	    SELECT = 0x1C02
	}

	///
	enum SamplePatternSGIS {
    	///
	    EXT_1PASS = 0x80A1,
    	///
	    SGIS_1PASS = 0x80A1,
    	///
	    EXT_2PASS_0 = 0x80A2,
    	///
	    SGIS_2PASS_0 = 0x80A2,
    	///
	    EXT_2PASS_1 = 0x80A3,
    	///
	    SGIS_2PASS_1 = 0x80A3,
    	///
	    EXT_4PASS_0 = 0x80A4,
    	///
	    SGIS_4PASS_0 = 0x80A4,
    	///
	    EXT_4PASS_1 = 0x80A5,
    	///
	    SGIS_4PASS_1 = 0x80A5,
    	///
	    EXT_4PASS_2 = 0x80A6,
    	///
	    SGIS_4PASS_2 = 0x80A6,
    	///
	    EXT_4PASS_3 = 0x80A7,
    	///
	    SGIS_4PASS_3 = 0x80A7
	}

	///
	enum SeparableTargetEXT {
    	///
	    SEPARABLE_2D = 0x8012,
    	///
	    SEPARABLE_2D_EXT = 0x8012
	}

	///
	enum ShadingModel {
    	///
	    FLAT = 0x1D00,
    	///
	    SMOOTH = 0x1D01
	}

	///
	enum StencilFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum StencilOp {
    	///
	    DECR = 0x1E03,
    	///
	    INCR = 0x1E02,
    	///
	    INVERT = 0x150A,
    	///
	    KEEP = 0x1E00,
    	///
	    REPLACE = 0x1E01,
    	///
	    ZERO = 0
	}

	///
	enum StringName {
    	///
	    EXTENSIONS = 0x1F03,
    	///
	    RENDERER = 0x1F01,
    	///
	    VENDOR = 0x1F00,
    	///
	    VERSION = 0x1F02
	}

	///
	enum TexCoordPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum TextureCoordName {
    	///
	    S = 0x2000,
    	///
	    T = 0x2001,
    	///
	    R = 0x2002,
    	///
	    Q = 0x2003
	}

	///
	enum TextureEnvMode {
    	///
	    ADD = 0x0104,
    	///
	    BLEND = 0x0BE2,
    	///
	    DECAL = 0x2101,
    	///
	    MODULATE = 0x2100,
    	///
	    REPLACE_EXT = 0x8062,
    	///
	    TEXTURE_ENV_BIAS_SGIX = 0x80BE
	}

	///
	enum TextureEnvParameter {
    	///
	    TEXTURE_ENV_COLOR = 0x2201,
    	///
	    TEXTURE_ENV_MODE = 0x2200
	}

	///
	enum TextureEnvTarget {
    	///
	    TEXTURE_ENV = 0x2300
	}

	///
	enum TextureFilterFuncSGIS {
    	///
	    FILTER4_SGIS = 0x8146
	}

	///
	enum TextureGenMode {
    	///
	    EYE_DISTANCE_TO_LINE_SGIS = 0x81F2,
    	///
	    EYE_DISTANCE_TO_POINT_SGIS = 0x81F0,
    	///
	    EYE_LINEAR = 0x2400,
    	///
	    OBJECT_DISTANCE_TO_LINE_SGIS = 0x81F3,
    	///
	    OBJECT_DISTANCE_TO_POINT_SGIS = 0x81F1,
    	///
	    OBJECT_LINEAR = 0x2401,
    	///
	    SPHERE_MAP = 0x2402
	}

	///
	enum TextureGenParameter {
    	///
	    EYE_LINE_SGIS = 0x81F6,
    	///
	    EYE_PLANE = 0x2502,
    	///
	    EYE_POINT_SGIS = 0x81F4,
    	///
	    OBJECT_LINE_SGIS = 0x81F7,
    	///
	    OBJECT_PLANE = 0x2501,
    	///
	    OBJECT_POINT_SGIS = 0x81F5,
    	///
	    TEXTURE_GEN_MODE = 0x2500
	}

	///
	enum TextureMagFilter {
    	///
	    FILTER4_SGIS = 0x8146,
    	///
	    LINEAR = 0x2601,
    	///
	    LINEAR_DETAIL_ALPHA_SGIS = 0x8098,
    	///
	    LINEAR_DETAIL_COLOR_SGIS = 0x8099,
    	///
	    LINEAR_DETAIL_SGIS = 0x8097,
    	///
	    LINEAR_SHARPEN_ALPHA_SGIS = 0x80AE,
    	///
	    LINEAR_SHARPEN_COLOR_SGIS = 0x80AF,
    	///
	    LINEAR_SHARPEN_SGIS = 0x80AD,
    	///
	    NEAREST = 0x2600,
    	///
	    PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184,
    	///
	    PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186,
    	///
	    PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185
	}

	///
	enum TextureMinFilter {
    	///
	    FILTER4_SGIS = 0x8146,
    	///
	    LINEAR = 0x2601,
    	///
	    LINEAR_CLIPMAP_LINEAR_SGIX = 0x8170,
    	///
	    LINEAR_CLIPMAP_NEAREST_SGIX = 0x844F,
    	///
	    LINEAR_MIPMAP_LINEAR = 0x2703,
    	///
	    LINEAR_MIPMAP_NEAREST = 0x2701,
    	///
	    NEAREST = 0x2600,
    	///
	    NEAREST_CLIPMAP_LINEAR_SGIX = 0x844E,
    	///
	    NEAREST_CLIPMAP_NEAREST_SGIX = 0x844D,
    	///
	    NEAREST_MIPMAP_LINEAR = 0x2702,
    	///
	    NEAREST_MIPMAP_NEAREST = 0x2700,
    	///
	    PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184,
    	///
	    PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186,
    	///
	    PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185
	}

	///
	enum TextureParameterName {
    	///
	    DETAIL_TEXTURE_LEVEL_SGIS = 0x809A,
    	///
	    DETAIL_TEXTURE_MODE_SGIS = 0x809B,
    	///
	    DUAL_TEXTURE_SELECT_SGIS = 0x8124,
    	///
	    GENERATE_MIPMAP = 0x8191,
    	///
	    GENERATE_MIPMAP_SGIS = 0x8191,
    	///
	    POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179,
    	///
	    POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A,
    	///
	    QUAD_TEXTURE_SELECT_SGIS = 0x8125,
    	///
	    SHADOW_AMBIENT_SGIX = 0x80BF,
    	///
	    TEXTURE_BORDER_COLOR = 0x1004,
    	///
	    TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171,
    	///
	    TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176,
    	///
	    TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172,
    	///
	    TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175,
    	///
	    TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173,
    	///
	    TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174,
    	///
	    TEXTURE_COMPARE_SGIX = 0x819A,
    	///
	    TEXTURE_LOD_BIAS_R_SGIX = 0x8190,
    	///
	    TEXTURE_LOD_BIAS_S_SGIX = 0x818E,
    	///
	    TEXTURE_LOD_BIAS_T_SGIX = 0x818F,
    	///
	    TEXTURE_MAG_FILTER = 0x2800,
    	///
	    TEXTURE_MAX_CLAMP_R_SGIX = 0x836B,
    	///
	    TEXTURE_MAX_CLAMP_S_SGIX = 0x8369,
    	///
	    TEXTURE_MAX_CLAMP_T_SGIX = 0x836A,
    	///
	    TEXTURE_MIN_FILTER = 0x2801,
    	///
	    TEXTURE_PRIORITY = 0x8066,
    	///
	    TEXTURE_PRIORITY_EXT = 0x8066,
    	///
	    TEXTURE_WRAP_Q_SGIS = 0x8137,
    	///
	    TEXTURE_WRAP_R = 0x8072,
    	///
	    TEXTURE_WRAP_R_EXT = 0x8072,
    	///
	    TEXTURE_WRAP_R_OES = 0x8072,
    	///
	    TEXTURE_WRAP_S = 0x2802,
    	///
	    TEXTURE_WRAP_T = 0x2803
	}

	///
	enum TextureTarget {
    	///
	    DETAIL_TEXTURE_2D_SGIS = 0x8095,
    	///
	    PROXY_TEXTURE_1D = 0x8063,
    	///
	    PROXY_TEXTURE_1D_EXT = 0x8063,
    	///
	    PROXY_TEXTURE_2D = 0x8064,
    	///
	    PROXY_TEXTURE_2D_EXT = 0x8064,
    	///
	    PROXY_TEXTURE_3D = 0x8070,
    	///
	    PROXY_TEXTURE_3D_EXT = 0x8070,
    	///
	    PROXY_TEXTURE_4D_SGIS = 0x8135,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D = 0x806F,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_3D_OES = 0x806F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_BASE_LEVEL = 0x813C,
    	///
	    TEXTURE_BASE_LEVEL_SGIS = 0x813C,
    	///
	    TEXTURE_MAX_LEVEL = 0x813D,
    	///
	    TEXTURE_MAX_LEVEL_SGIS = 0x813D,
    	///
	    TEXTURE_MAX_LOD = 0x813B,
    	///
	    TEXTURE_MAX_LOD_SGIS = 0x813B,
    	///
	    TEXTURE_MIN_LOD = 0x813A,
    	///
	    TEXTURE_MIN_LOD_SGIS = 0x813A
	}

	///
	enum TextureWrapMode {
    	///
	    CLAMP = 0x2900,
    	///
	    CLAMP_TO_BORDER = 0x812D,
    	///
	    CLAMP_TO_BORDER_ARB = 0x812D,
    	///
	    CLAMP_TO_BORDER_NV = 0x812D,
    	///
	    CLAMP_TO_BORDER_SGIS = 0x812D,
    	///
	    CLAMP_TO_EDGE = 0x812F,
    	///
	    CLAMP_TO_EDGE_SGIS = 0x812F,
    	///
	    REPEAT = 0x2901
	}

	///
	@Bitmaskable
	enum UseProgramStageMask {
    	///
	    VERTEX_SHADER_BIT = 0x00000001,
    	///
	    VERTEX_SHADER_BIT_EXT = 0x00000001,
    	///
	    FRAGMENT_SHADER_BIT = 0x00000002,
    	///
	    FRAGMENT_SHADER_BIT_EXT = 0x00000002,
    	///
	    GEOMETRY_SHADER_BIT = 0x00000004,
    	///
	    GEOMETRY_SHADER_BIT_EXT = 0x00000004,
    	///
	    TESS_CONTROL_SHADER_BIT = 0x00000008,
    	///
	    TESS_CONTROL_SHADER_BIT_EXT = 0x00000008,
    	///
	    TESS_EVALUATION_SHADER_BIT = 0x00000010,
    	///
	    TESS_EVALUATION_SHADER_BIT_EXT = 0x00000010,
    	///
	    COMPUTE_SHADER_BIT = 0x00000020,
    	///
	    ALL_SHADER_BITS = 0xFFFFFFFF,
    	///
	    ALL_SHADER_BITS_EXT = 0xFFFFFFFF
	}

	///
	enum VertexPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

extern(C) {

    /++
     + glActiveShaderProgram: man4/glActiveShaderProgram.xml
     + 
     + $(D_INLINECODE glActiveShaderProgram) sets the linked program named by $(D_INLINECODE program) to be the active program for the program pipeline object $(D_INLINECODE pipeline). The active program in the active program pipeline object is the target of calls to $(D_INLINECODE glUniform) when no program has been made current through a call to $(D_INLINECODE glUseProgram).
     + 
     + Params:
     +     pipeline = Specifies the program pipeline object to set the active program object for.
     +     program  = Specifies the program object to set as the active program pipeline object $(D_INLINECODE pipeline).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glIsProgramPipeline), $(D_INLINECODE glUseProgram), $(D_INLINECODE glUniform)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glActiveShaderProgram(GLuint pipeline, GLuint program) @system @nogc nothrow;

    /++
     + glActiveTexture: man4/glActiveTexture.xml
     + 
     + $(D_INLINECODE glActiveTexture) selects which texture unit subsequent texture state calls will affect.  The number of texture units an implementation supports is implementation dependent, but must be at least 80.
     + 
     + Params:
     +     texture = Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. $(D_INLINECODE texture) must be one of $(D_INLINECODE GL_TEXTURE), where ranges from zero to the value of $(D_INLINECODE GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS) minus one. The initial value is $(D_INLINECODE GL_TEXTURE0).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTextures), $(D_INLINECODE glBindTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDeleteTextures) $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter),
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glActiveTexture(GLenum texture) @system @nogc nothrow;

    /++
     + glAttachShader: man4/glAttachShader.xml
     + 
     + In order to create a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. $(D_INLINECODE glAttachShader) attaches the shader object specified by $(D_INLINECODE shader) to the program object specified by $(D_INLINECODE program). This indicates that $(D_INLINECODE shader) will be included in link operations that will be performed on $(D_INLINECODE program). All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. It is permissible to attach multiple shader objects of the same type because each may contain a portion of the complete shader. It is also permissible to attach a shader object to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until $(D_INLINECODE glDetachShader) is called to detach it from all program objects to which it is attached.
     + 
     + Params:
     +     program = Specifies the program object to which a shader object will be attached.
     +     shader  = Specifies the shader object that is to be attached.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glAttachShader(GLuint program, GLuint shader) @system @nogc nothrow;

    /++
     + glBeginConditionalRender: man4/glBeginConditionalRender.xml
     + 
     + Conditional rendering is started using $(D_INLINECODE glBeginConditionalRender) and ended using $(D_INLINECODE glEndConditionalRender). During conditional rendering, all vertex array commands, as well as $(D_INLINECODE glClear) and $(D_INLINECODE glClearBuffer) have no effect if the ( $(D_INLINECODE GL_SAMPLES_PASSED) ) result of the query object $(D_INLINECODE id) is zero, or if the ( $(D_INLINECODE GL_ANY_SAMPLES_PASSED) ) result is $(D_INLINECODE GL_FALSE). The results of commands setting the current vertex state, such as $(D_INLINECODE glVertexAttrib) are undefined. If the ( $(D_INLINECODE GL_SAMPLES_PASSED) ) result is non-zero or if the ( $(D_INLINECODE GL_ANY_SAMPLES_PASSED) ) result is $(D_INLINECODE GL_TRUE), such commands are not discarded. The $(D_INLINECODE id) parameter to $(D_INLINECODE glBeginConditionalRender) must be the name of a query object previously returned from a call to $(D_INLINECODE glGenQueries). $(D_INLINECODE mode) specifies how the results of the query object are to be interpreted. If $(D_INLINECODE mode) is $(D_INLINECODE GL_QUERY_WAIT), the GL waits for the results of the query to be available and then uses the results to determine if subsequent rendering commands are discarded. If $(D_INLINECODE mode) is $(D_INLINECODE GL_QUERY_NO_WAIT), the GL may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete. If $(D_INLINECODE mode) is $(D_INLINECODE GL_QUERY_BY_REGION_WAIT), the GL will also wait for occlusion query results and discard rendering commands if the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed, but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample count in the specified occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering command results may not be discarded for any samples that contributed to the occlusion query sample count. If $(D_INLINECODE mode) is $(D_INLINECODE GL_QUERY_BY_REGION_NO_WAIT), the GL operates as in $(D_INLINECODE GL_QUERY_BY_REGION_WAIT), but may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.
     + 
     + $(D_INLINECODE glBeginConditionalRender) and $(D_INLINECODE glEndConditionalRender) are available only if the GL version is 3.0 or greater. The $(D_INLINECODE GL_ANY_SAMPLES_PASSED) query result is available only if the GL version is 3.3 or greater.
     + 
     + Params:
     +     id   = Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
     +     mode = Specifies how $(D_INLINECODE glBeginConditionalRender) interprets the results of the occlusion query.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenQueries), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glBeginQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glBeginConditionalRender(GLuint id, GLenum mode) @system @nogc nothrow;

    /++
     + glBeginQuery: man4/glBeginQuery.xml
     + 
     + $(D_INLINECODE glBeginQuery) and $(D_INLINECODE glEndQuery) delimit the boundaries of a query object. $(D_INLINECODE query) must be a name previously returned from a call to $(D_INLINECODE glGenQueries). If a query object with name $(D_INLINECODE id) does not yet exist it is created with the type determined by $(D_INLINECODE target). $(D_INLINECODE target) must be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), or $(D_INLINECODE GL_TIME_ELAPSED). The behavior of the query object depends on its type and is as follows. If $(D_INLINECODE target) is $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE id) must be an unused name, or the name of an existing occlusion query object. When $(D_INLINECODE glBeginQuery) is executed, the query object's samples-passed counter is reset to 0.  Subsequent rendering will increment the counter for every sample that passes the depth test.  If the value of $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of $(D_INLINECODE GL_SAMPLES) if any sample in the fragment is covered. When $(D_INLINECODE glEndQuery) is executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). If $(D_INLINECODE target) is $(D_INLINECODE GL_ANY_SAMPLES_PASSED) or $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE), $(D_INLINECODE id) must be an unused name, or the name of an existing boolean occlusion query object. When $(D_INLINECODE glBeginQuery) is executed, the query object's samples-passed flag is reset to $(D_INLINECODE GL_FALSE). Subsequent rendering causes the flag to be set to $(D_INLINECODE GL_TRUE) if any sample passes the depth test in the case of $(D_INLINECODE GL_ANY_SAMPLES_PASSED), or if the implementation determines that any sample might pass the depth test in the case of $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE). The implementation may be able to provide a more efficient test in the case of $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) if some false positives are acceptable to the application.  When $(D_INLINECODE glEndQuery) is executed, the samples-passed flag is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). If $(D_INLINECODE target) is $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE id) must be an unused name, or the name of an existing primitive query object previously bound to the $(D_INLINECODE GL_PRIMITIVES_GENERATED) query binding. When $(D_INLINECODE glBeginQuery) is executed, the query object's primitives-generated counter is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader, or from the vertex shader if no geometry shader is present.  When $(D_INLINECODE glEndQuery) is executed, the primitives-generated counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). If $(D_INLINECODE target) is $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE id) must be an unused name, or the name of an existing primitive query object previously bound to the $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN) query binding. When $(D_INLINECODE glBeginQuery) is executed, the query object's primitives-written counter is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s).  If transform feedback mode is not activated between the call to $(D_INLINECODE glBeginQuery) and $(D_INLINECODE glEndQuery), the counter will not be incremented.  When $(D_INLINECODE glEndQuery) is executed, the primitives-written counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). If $(D_INLINECODE target) is $(D_INLINECODE GL_TIME_ELAPSED), $(D_INLINECODE id) must be an unused name, or the name of an existing timer query object previously bound to the $(D_INLINECODE GL_TIME_ELAPSED) query binding. When $(D_INLINECODE glBeginQuery) is executed, the query object's time counter is reset to 0.  When $(D_INLINECODE glEndQuery) is executed, the elapsed server time that has passed since the call to $(D_INLINECODE glBeginQuery) is written into the query object's time counter.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). Querying the $(D_INLINECODE GL_QUERY_RESULT) implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE) can be queried to determine if the result is immediately available or if the rendering is not yet complete.
     + 
     + If the query target's count exceeds the maximum value representable in the number of available bits, as reported by $(D_INLINECODE glGetQueryiv) with $(D_INLINECODE target) set to the appropriate query target and $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_COUNTER_BITS), the count becomes undefined. An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless. When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test.  When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test. The query targets $(D_INLINECODE GL_ANY_SAMPLES_PASSED), and $(D_INLINECODE GL_TIME_ELAPSED) are availale only if the GL version is 3.3 or higher. The query target $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) is available only of the GL version is 4.3 or higher.
     + 
     + Params:
     +     target = Specifies the target type of query object established between $(D_INLINECODE glBeginQuery) and the subsequent $(D_INLINECODE glEndQuery). The symbolic constant must be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE), $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), or $(D_INLINECODE GL_TIME_ELAPSED).
     +     id     = Specifies the name of a query object.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQueryIndexed), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glBeginQuery(GLenum target, GLuint id) @system @nogc nothrow;

    /++
     + glBeginQueryIndexed: man4/glBeginQueryIndexed.xml
     + 
     + $(D_INLINECODE glBeginQueryIndexed) and $(D_INLINECODE glEndQueryIndexed) delimit the boundaries of a query object. $(D_INLINECODE query) must be a name previously returned from a call to $(D_INLINECODE glGenQueries). If a query object with name $(D_INLINECODE id) does not yet exist it is created with the type determined by $(D_INLINECODE target). $(D_INLINECODE target) must be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), or $(D_INLINECODE GL_TIME_ELAPSED). The behavior of the query object depends on its type and is as follows. $(D_INLINECODE index) specifies the index of the query target and must be between a $(D_INLINECODE target) -specific maximum. If $(D_INLINECODE target) is $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE id) must be an unused name, or the name of an existing occlusion query object. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's samples-passed counter is reset to 0.  Subsequent rendering will increment the counter for every sample that passes the depth test.  If the value of $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of $(D_INLINECODE GL_SAMPLES) if any sample in the fragment is covered. When $(D_INLINECODE glEndQueryIndexed) is executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE index) must be zero. If $(D_INLINECODE target) is $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE id) must be an unused name, or the name of an existing boolean occlusion query object. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's samples-passed flag is reset to $(D_INLINECODE GL_FALSE). Subsequent rendering causes the flag to be set to $(D_INLINECODE GL_TRUE) if any sample passes the depth test.  When $(D_INLINECODE glEndQueryIndexed) is executed, the samples-passed flag is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE index) must be zero. If $(D_INLINECODE target) is $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE id) must be an unused name, or the name of an existing primitive query object previously bound to the $(D_INLINECODE GL_PRIMITIVES_GENERATED) query binding. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's primitives-generated counter is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader to the stream given by $(D_INLINECODE index), or from the vertex shader if $(D_INLINECODE index) is zero and no geometry shader is present. When $(D_INLINECODE glEndQueryIndexed) is executed, the primitives-generated counter for stream $(D_INLINECODE index) is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_STREAMS). If $(D_INLINECODE target) is $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE id) must be an unused name, or the name of an existing primitive query object previously bound to the $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN) query binding. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's primitives-written counter for the stream specified by $(D_INLINECODE index) is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s) for stream $(D_INLINECODE index).  If transform feedback mode is not activated between the call to $(D_INLINECODE glBeginQueryIndexed) and $(D_INLINECODE glEndQueryIndexed), the counter will not be incremented.  When $(D_INLINECODE glEndQueryIndexed) is executed, the primitives-written counter for stream $(D_INLINECODE index) is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_STREAMS). If $(D_INLINECODE target) is $(D_INLINECODE GL_TIME_ELAPSED), $(D_INLINECODE id) must be an unused name, or the name of an existing timer query object previously bound to the $(D_INLINECODE GL_TIME_ELAPSED) query binding. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's time counter is reset to 0.  When $(D_INLINECODE glEndQueryIndexed) is executed, the elapsed server time that has passed since the call to $(D_INLINECODE glBeginQueryIndexed) is written into the query object's time counter.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_TIME_ELAPSED), $(D_INLINECODE index) must be zero. Querying the $(D_INLINECODE GL_QUERY_RESULT) implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE) can be queried to determine if the result is immediately available or if the rendering is not yet complete.
     + 
     + If the query target's count exceeds the maximum value representable in the number of available bits, as reported by $(D_INLINECODE glGetQueryiv) with $(D_INLINECODE target) set to the appropriate query target and $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_COUNTER_BITS), the count becomes undefined. An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless. When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test.  When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test. Calling $(D_INLINECODE glBeginQuery) or $(D_INLINECODE glEndQuery) is equivalent to calling $(D_INLINECODE glBeginQueryIndexed) or $(D_INLINECODE glEndQueryIndexed) with $(D_INLINECODE index) set to zero, respectively.
     + 
     + Params:
     +     target = Specifies the target type of query object established between $(D_INLINECODE glBeginQueryIndexed) and the subsequent $(D_INLINECODE glEndQueryIndexed). The symbolic constant must be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), or $(D_INLINECODE GL_TIME_ELAPSED).
     +     index  = Specifies the index of the query target upon which to begin the query.
     +     id     = Specifies the name of a query object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id) @system @nogc nothrow;

    /++
     + glBeginTransformFeedback: man4/glBeginTransformFeedback.xml
     + 
     + Transform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry shader). Transform feedback is said to be active after a call to $(D_INLINECODE glBeginTransformFeedback) until a subsequent call to $(D_INLINECODE glEndTransformFeedback). Transform feedback commands must be paired. If no geometry shader is present, while transform feedback is active the $(D_INLINECODE mode) parameter to $(D_INLINECODE glDrawArrays) must match those specified in the following table: $(B Transform Feedback $(D_INLINECODE primitiveMode)) $(B Allowed Render Primitive $(D_INLINECODE modes)) $(D_INLINECODE GL_POINTS) $(D_INLINECODE GL_POINTS) $(D_INLINECODE GL_LINES) $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY) $(D_INLINECODE GL_TRIANGLES) $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) If a geometry shader is present, the output primitive type from the geometry shader must match those provided in the following table: $(B Transform Feedback $(D_INLINECODE primitiveMode)) $(B Allowed Geometry Shader Output Primitive Type) $(D_INLINECODE GL_POINTS) $(D_INLINECODE points) $(D_INLINECODE GL_LINES) $(D_INLINECODE line_strip) $(D_INLINECODE GL_TRIANGLES) $(D_INLINECODE triangle_strip)
     + 
     + Geometry shaders, and the $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY) and $(D_INLINECODE GL_LINE_STRIP_ADJACENCY) primtive modes are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     primitiveMode = Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glBeginTransformFeedback(GLenum primitiveMode) @system @nogc nothrow;

    /++
     + glBindAttribLocation: man4/glBindAttribLocation.xml
     + 
     + $(D_INLINECODE glBindAttribLocation) is used to associate a user-defined attribute variable in the program object specified by $(D_INLINECODE program) with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in $(D_INLINECODE name). The generic vertex attribute index to be bound to this variable is specified by $(D_INLINECODE index). When $(D_INLINECODE program) is made part of current state, values provided via the generic vertex attribute $(D_INLINECODE index) will modify the value of the user-defined attribute variable specified by $(D_INLINECODE name). If $(D_INLINECODE name) refers to a matrix attribute variable, $(D_INLINECODE index) refers to the first column of the matrix. Other matrix columns are then automatically bound to locations $(D_INLINECODE index+1) for a matrix of type $(D_INLINECODE mat2); $(D_INLINECODE index+1) and $(D_INLINECODE index+2) for a matrix of type $(D_INLINECODE mat3); and $(D_INLINECODE index+1), $(D_INLINECODE index+2), and $(D_INLINECODE index+3) for a matrix of type $(D_INLINECODE mat4). This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from zero to the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS) minus one. The values sent to each generic attribute index are part of current state. If a different program object is made current by calling $(D_INLINECODE glUseProgram), the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to $(D_INLINECODE index). Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling $(D_INLINECODE glBindAttribLocation). Attribute bindings do not go into effect until $(D_INLINECODE glLinkProgram) is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs. Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.
     + 
     + $(D_INLINECODE glBindAttribLocation) can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader. If $(D_INLINECODE name) was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index. Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing. Active attributes that are not explicitly bound will be bound by the linker when $(D_INLINECODE glLinkProgram) is called. The locations assigned can be queried by calling $(D_INLINECODE glGetAttribLocation). OpenGL copies the $(D_INLINECODE name) string when $(D_INLINECODE glBindAttribLocation) is called, so an application may free its copy of the $(D_INLINECODE name) string immediately after the function returns. Generic attribute locations may be specified in the shader source text using a $(D_INLINECODE location) layout qualifier. In this case, the location of the attribute specified in the shader's source takes precedence and may be queried by calling $(D_INLINECODE glGetAttribLocation).
     + 
     + Params:
     +     program = Specifies the handle of the program object in which the association is to be made.
     +     index   = Specifies the index of the generic vertex attribute to be bound.
     +     name    = Specifies a null terminated string containing the name of the vertex shader attribute variable to which $(D_INLINECODE index) is to be bound.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glUseProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glBindAttribLocation(GLuint program, GLuint index, const GLchar* name) @system @nogc nothrow;

    /++
     + glBindBuffer: man4/glBindBuffer.xml
     + 
     + $(D_INLINECODE glBindBuffer) binds a buffer object to the specified buffer binding point. Calling $(D_INLINECODE glBindBuffer) with $(D_INLINECODE target) set to one of the accepted symbolic constants and $(D_INLINECODE buffer) set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name $(D_INLINECODE buffer) exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken. Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, $(D_INLINECODE buffer) set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions. $(D_INLINECODE glGenBuffers) must be used to generate a set of unused buffer object names. The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with $(D_INLINECODE GL_READ_WRITE) access and $(D_INLINECODE GL_STATIC_DRAW) usage. While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an $(D_INLINECODE GL_INVALID_OPERATION) error. When a non-zero buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target, the vertex array pointer parameter is interpreted as an offset within the buffer object measured in basic machine units. When a non-zero buffer object is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) target, parameters for draws issued through $(D_INLINECODE glDrawArraysIndirect) and $(D_INLINECODE glDrawElementsIndirect) are sourced from the specified offset in that buffer object's data store. When a non-zero buffer object is bound to the $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) target, the parameters for compute dispatches issued through $(D_INLINECODE glDispatchComputeIndirect) are sourced from the specified offset in that buffer object's data store. While a non-zero buffer object is bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) target, the indices parameter of $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawRangeElementsBaseVertex), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glMultiDrawElementsBaseVertex) is interpreted as an offset within the buffer object measured in basic machine units. While a non-zero buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target, the following commands are affected: $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glGetTexImage), and $(D_INLINECODE glReadPixels). The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units. While a non-zero buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target, the following commands are affected: $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D). The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units. The buffer targets $(D_INLINECODE GL_COPY_READ_BUFFER) and $(D_INLINECODE GL_COPY_WRITE_BUFFER) are provided to allow $(D_INLINECODE glCopyBufferSubData) to be used without disturbing the state of other bindings. However, $(D_INLINECODE glCopyBufferSubData) may be used with any pair of buffer binding points. The $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) buffer binding point may be passed to $(D_INLINECODE glBindBuffer), but will not directly affect transform feedback state. Instead, the indexed $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) bindings must be used through a call to $(D_INLINECODE glBindBufferBase) or $(D_INLINECODE glBindBufferRange). This will affect the generic $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) binding. Likewise, the $(D_INLINECODE GL_UNIFORM_BUFFER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) buffer binding points may be used, but do not directly affect uniform buffer, atomic counter buffer or shader storage buffer state, respectively. $(D_INLINECODE glBindBufferBase) or $(D_INLINECODE glBindBufferRange) must be used to bind a buffer to an indexed uniform buffer, atomic counter buffer or shader storage buffer binding point. The $(D_INLINECODE GL_QUERY_BUFFER) binding point is used to specify a buffer object that is to receive the results of query objects through calls to the $(D_INLINECODE glGetQueryObject) family of commands. A buffer object binding created with $(D_INLINECODE glBindBuffer) remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with $(D_INLINECODE glDeleteBuffers). Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.
     + 
     + The $(D_INLINECODE GL_COPY_READ_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER) and $(D_INLINECODE GL_TEXTURE_BUFFER) targets are available only if the GL version is 3.1 or greater. The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of a buffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGet), $(D_INLINECODE glIsBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glBindBuffer(GLenum target, GLuint buffer) @system @nogc nothrow;

    /++
     + glBindBufferBase: man4/glBindBufferBase.xml
     + 
     + $(D_INLINECODE glBindBufferBase) binds the buffer object $(D_INLINECODE buffer) to the binding point at index $(D_INLINECODE index) of the array of targets specified by $(D_INLINECODE target). Each $(D_INLINECODE target) represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as $(D_INLINECODE glBindBuffer) or $(D_INLINECODE glMapBuffer). In addition to binding $(D_INLINECODE buffer) to the indexed buffer binding target, $(D_INLINECODE glBindBufferBase) also binds $(D_INLINECODE buffer) to the generic buffer binding point specified by $(D_INLINECODE target).
     + 
     + Calling $(D_INLINECODE glBindBufferBase) is equivalent to calling $(D_INLINECODE glBindBufferRange) with $(D_INLINECODE offset) zero and $(D_INLINECODE size) equal to the size of the buffer. The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) target is available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     target = Specify the target of the bind operation. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER) or $(D_INLINECODE GL_SHADER_STORAGE_BUFFER).
     +     index  = Specify the index of the binding point within the array specified by $(D_INLINECODE target).
     +     buffer = The name of a buffer object to bind to the specified binding point.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer),
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glBindBufferBase(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;

    /++
     + glBindBufferRange: man4/glBindBufferRange.xml
     + 
     + $(D_INLINECODE glBindBufferRange) binds a range the buffer object $(D_INLINECODE buffer) represented by $(D_INLINECODE offset) and $(D_INLINECODE size) to the binding point at index $(D_INLINECODE index) of the array of targets specified by $(D_INLINECODE target). Each $(D_INLINECODE target) represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as $(D_INLINECODE glBindBuffer) or $(D_INLINECODE glMapBuffer). In addition to binding a range of $(D_INLINECODE buffer) to the indexed buffer binding target, $(D_INLINECODE glBindBufferRange) also binds the range to the generic buffer binding point specified by $(D_INLINECODE target). $(D_INLINECODE offset) specifies the offset in basic machine units into the buffer object $(D_INLINECODE buffer) and $(D_INLINECODE size) specifies the amount of data that can be read from the buffer object while used as an indexed target.
     + 
     + The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) target is available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     target = Specify the target of the bind operation. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER), or $(D_INLINECODE GL_SHADER_STORAGE_BUFFER).
     +     index  = Specify the index of the binding point within the array specified by $(D_INLINECODE target).
     +     buffer = The name of a buffer object to bind to the specified binding point.
     +     offset = The starting offset in basic machine units into the buffer object $(D_INLINECODE buffer).
     +     size   = The amount of data in machine units that can be read from the buffer object while used as an indexed target.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer),
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;

    /++
     + glBindBuffersBase: man4/glBindBuffersBase.xml
     + 
     + $(D_INLINECODE glBindBuffersBase) binds a set of $(D_INLINECODE count) buffer objects whose names are given in the array $(D_INLINECODE buffers) to the $(D_INLINECODE count) consecutive binding points starting from index $(D_INLINECODE index) of the array of targets specified by $(D_INLINECODE target). If $(D_INLINECODE buffers) is $(D_INLINECODE null
     + ) then $(D_INLINECODE glBindBuffersBase) unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following pseudo-code, which calls $(D_INLINECODE glBindBufferBase) :
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (buffers != NULL) {
     +         glBindBufferBase(target, first + i, buffers[i]);
     +     } else {
     +         glBindBufferBase(target, first + i, 0);
     +     }
     + }
     + ---
     + 
     + 
     + $(D_INLINECODE glBindBuffersBase) is available only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specify the target of the bind operation. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER) or $(D_INLINECODE GL_SHADER_STORAGE_BUFFER).
     +     index   = Specify the index of the first binding point within the array specified by $(D_INLINECODE target).
     +     count   = Specify the number of contiguous binding points to which to bind buffers.
     +     buffers = A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or $(D_INLINECODE null).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBuffersRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint* buffers) @system @nogc nothrow;

    /++
     + glBindBuffersRange: man4/glBindBuffersRange.xml
     + 
     + $(D_INLINECODE glBindBuffersRange) binds a set of $(D_INLINECODE count) ranges from buffer objects whose names are given in the array $(D_INLINECODE buffers) to the $(D_INLINECODE count) consecutive binding points starting from index $(D_INLINECODE index) of the array of targets specified by $(D_INLINECODE target). $(D_INLINECODE offsets) specifies the address of an array containing $(D_INLINECODE count) starting offsets within the buffers, and $(D_INLINECODE sizes) specifies the adderess of an array of $(D_INLINECODE count) sizes of the ranges. If $(D_INLINECODE buffers) is $(D_INLINECODE null
     + ) then $(D_INLINECODE offsets) and $(D_INLINECODE sizes) are ignored and $(D_INLINECODE glBindBuffersRange) unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following pseudo-code, which calls $(D_INLINECODE glBindBufferRange) :
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (buffers != NULL) {
     +         glBindBufferRange(target, first + i, buffers[i], offsets[i], sizes[i]);
     +     } else {
     +         glBindBufferBase(target, first + i, 0);
     +     }
     + }
     + ---
     + 
     + 
     + $(D_INLINECODE glBindBuffersBase) is available only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specify the target of the bind operation. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER) or $(D_INLINECODE GL_SHADER_STORAGE_BUFFER).
     +     index   = Specify the index of the first binding point within the array specified by $(D_INLINECODE target).
     +     count   = Specify the number of contiguous binding points to which to bind buffers.
     +     buffers = A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or $(D_INLINECODE null).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBuffersRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLintptr* sizes) @system @nogc nothrow;

    /++
     + glBindFragDataLocation: man4/glBindFragDataLocation.xml
     + 
     + $(D_INLINECODE glBindFragDataLocation) explicitly specifies the binding of the user-defined varying out variable $(D_INLINECODE name) to fragment shader color number $(D_INLINECODE colorNumber) for program $(D_INLINECODE program). If $(D_INLINECODE name) was bound previously, its assigned binding is replaced with $(D_INLINECODE colorNumber). $(D_INLINECODE name) must be a null-terminated string. $(D_INLINECODE colorNumber) must be less than $(D_INLINECODE GL_MAX_DRAW_BUFFERS). The bindings specified by $(D_INLINECODE glBindFragDataLocation) have no effect until $(D_INLINECODE program) is next linked. Bindings may be specified at any time after $(D_INLINECODE program) has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in $(D_INLINECODE name), including a name that is never used as a varying out variable in any fragment shader object. Names beginning with $(D_INLINECODE gl_) are reserved by the GL. In addition to the errors generated by $(D_INLINECODE glBindFragDataLocation), the program $(D_INLINECODE program) will fail to link if: $(OL $(LI The number of active outputs is greater than the value $(D_INLINECODE GL_MAX_DRAW_BUFFERS).) $(LI More than one varying out variable is bound to the same color number.))
     + 
     + Varying out varyings may have indexed locations assigned explicitly in the shader text using a $(D_INLINECODE location) layout qualifier. If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any location assigned with $(D_INLINECODE glBindFragDataLocation) is ignored.
     + 
     + Params:
     +     program     = The name of the program containing varying out variable whose binding to modify
     +     colorNumber = The color number to bind the user-defined varying out variable to
     +     name        = The name of the user-defined varying out variable whose binding to modify
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glGetFragDataLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char* name) @system @nogc nothrow;

    /++
     + glBindFragDataLocationIndexed: man4/glBindFragDataLocationIndexed.xml
     + 
     + $(D_INLINECODE glBindFragDataLocationIndexed) specifies that the varying out variable $(D_INLINECODE name) in $(D_INLINECODE program) should be bound to fragment color $(D_INLINECODE colorNumber) when the program is next linked. $(D_INLINECODE index) may be zero or one to specify that the color be used as either the first or second color input to the blend equation, respectively. The bindings specified by $(D_INLINECODE glBindFragDataLocationIndexed) have no effect until $(D_INLINECODE program) is next linked. Bindings may be specified at any time after $(D_INLINECODE program) has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in $(D_INLINECODE name), including a name that is never used as a varying out variable in any fragment shader object. Names beginning with $(D_INLINECODE gl_) are reserved by the GL. If $(D_INLINECODE name) was bound previously, its assigned binding is replaced with $(D_INLINECODE colorNumber) and $(D_INLINECODE index). $(D_INLINECODE name) must be a null-terminated string. $(D_INLINECODE index) must be less than or equal to one, and $(D_INLINECODE colorNumber) must be less than the value of $(D_INLINECODE GL_MAX_DRAW_BUFFERS) if $(D_INLINECODE index) is zero, and less than the value of $(D_INLINECODE GL_MAX_DUAL_SOURCE_DRAW_BUFFERS) if index is greater than or equal to one. In addition to the errors generated by $(D_INLINECODE glBindFragDataLocationIndexed), the program $(D_INLINECODE program) will fail to link if: $(OL $(LI The number of active outputs is greater than the value $(D_INLINECODE GL_MAX_DRAW_BUFFERS).) $(LI More than one varying out variable is bound to the same color number.))
     + 
     + Varying out varyings may have locations assigned explicitly in the shader text using a $(D_INLINECODE location) layout qualifier. If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any location assigned with $(D_INLINECODE glBindFragDataLocation) is ignored.
     + 
     + Params:
     +     program     = The name of the program containing varying out variable whose binding to modify
     +     colorNumber = The color number to bind the user-defined varying out variable to
     +     index       = The index of the color input to bind the user-defined varying out variable to
     +     name        = The name of the user-defined varying out variable whose binding to modify
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glLinkProgram) $(D_INLINECODE glGetFragDataLocation), $(D_INLINECODE glGetFragDataIndex) $(D_INLINECODE glBindFragDataLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_blend_func_extended")
    void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char* name) @system @nogc nothrow;

    /++
     + glBindFramebuffer: man4/glBindFramebuffer.xml
     + 
     + $(D_INLINECODE glBindFramebuffer) binds the framebuffer object with name $(D_INLINECODE framebuffer) to the framebuffer target specified by $(D_INLINECODE target). $(D_INLINECODE target) must be either $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). If a framebuffer object is bound to $(D_INLINECODE GL_DRAW_FRAMEBUFFER) or $(D_INLINECODE GL_READ_FRAMEBUFFER), it becomes the target for rendering or readback operations, respectively, until it is deleted or another framebuffer is bound to the corresponding bind point. Calling $(D_INLINECODE glBindFramebuffer) with $(D_INLINECODE target) set to $(D_INLINECODE GL_FRAMEBUFFER) binds $(D_INLINECODE framebuffer) to both the read and draw framebuffer targets. $(D_INLINECODE framebuffer) is the name of a framebuffer object previously returned from a call to $(D_INLINECODE glGenFramebuffers), or zero to break the existing binding of a framebuffer object to $(D_INLINECODE target).
     + 
     + Params:
     +     target      = Specifies the framebuffer target of the binding operation.
     +     framebuffer = Specifies the name of the framebuffer object to bind.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), $(D_INLINECODE glFramebufferTexture3D), $(D_INLINECODE glFramebufferTextureLayer), $(D_INLINECODE glDeleteFramebuffers), $(D_INLINECODE glIsFramebuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glBindFramebuffer(GLenum target, GLuint framebuffer) @system @nogc nothrow;

    /++
     + glBindImageTexture: man4/glBindImageTexture.xml
     + 
     + $(D_INLINECODE glBindImageTexture) binds a single level of a texture to an image unit for the purpose of reading and writing it from shaders. $(D_INLINECODE unit) specifies the zero-based index of the image unit to which to bind the texture level. $(D_INLINECODE texture) specifies the name of an existing texture object to bind to the image unit. If $(D_INLINECODE texture) is zero, then any existing binding to the image unit is broken. $(D_INLINECODE level) specifies the level of the texture to bind to the image unit. If $(D_INLINECODE texture) is the name of a one-, two-, or three-dimensional array texture, a cube map or cube map array texture, or a two-dimensional multisample array texture, then it is possible to bind either the entire array, or only a single layer of the array to the image unit. In such cases, if $(D_INLINECODE layered) is $(D_INLINECODE GL_TRUE), the entire array is attached to the image unit and $(D_INLINECODE layer) is ignored. However, if $(D_INLINECODE layered) is $(D_INLINECODE GL_FALSE) then $(D_INLINECODE layer) specifies the layer of the array to attach to the image unit. $(D_INLINECODE access) specifies the access types to be performed by shaders and may be set to $(D_INLINECODE GL_READ_ONLY), $(D_INLINECODE GL_WRITE_ONLY), or $(D_INLINECODE GL_READ_WRITE) to indicate read-only, write-only or read-write access, respectively. Violation of the access type specified in $(D_INLINECODE access) (for example, if a shader writes to an image bound with $(D_INLINECODE access) set to $(D_INLINECODE GL_READ_ONLY) ) will lead to undefined results, possibly including program termination. $(D_INLINECODE format) specifies the format that is to be used when performing formatted stores into the image from shaders. $(D_INLINECODE format) must be compatible with the texture's internal format and must be one of the formats listed in the following table.<h3> Internal Image Formats</h3> $(B Image Unit Format) $(B Format Qualifier) $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE rgba32f) $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE rgba16f) $(D_INLINECODE GL_RG32F) $(D_INLINECODE rg32f) $(D_INLINECODE GL_RG16F) $(D_INLINECODE rg16f) $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE r11f_g11f_b10f) $(D_INLINECODE GL_R32F) $(D_INLINECODE r32f) $(D_INLINECODE GL_R16F) $(D_INLINECODE r16f) $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE rgba32ui) $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE rgba16ui) $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE rgb10_a2ui) $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE rgba8ui) $(D_INLINECODE GL_RG32UI) $(D_INLINECODE rg32ui) $(D_INLINECODE GL_RG16UI) $(D_INLINECODE rg16ui) $(D_INLINECODE GL_RG8UI) $(D_INLINECODE rg8ui) $(D_INLINECODE GL_R32UI) $(D_INLINECODE r32ui) $(D_INLINECODE GL_R16UI) $(D_INLINECODE r16ui) $(D_INLINECODE GL_R8UI) $(D_INLINECODE r8ui) $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE rgba32i) $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE rgba16i) $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE rgba8i) $(D_INLINECODE GL_RG32I) $(D_INLINECODE rg32i) $(D_INLINECODE GL_RG16I) $(D_INLINECODE rg16i) $(D_INLINECODE GL_RG8I) $(D_INLINECODE rg8i) $(D_INLINECODE GL_R32I) $(D_INLINECODE r32i) $(D_INLINECODE GL_R16I) $(D_INLINECODE r16i) $(D_INLINECODE GL_R8I) $(D_INLINECODE r8i) $(D_INLINECODE GL_RGBA16) $(D_INLINECODE rgba16) $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE rgb10_a2) $(D_INLINECODE GL_RGBA8) $(D_INLINECODE rgba8) $(D_INLINECODE GL_RG16) $(D_INLINECODE rg16) $(D_INLINECODE GL_RG8) $(D_INLINECODE rg8) $(D_INLINECODE GL_R16) $(D_INLINECODE r16) $(D_INLINECODE GL_R8) $(D_INLINECODE r8) $(D_INLINECODE GL_RGBA16_SNORM) $(D_INLINECODE rgba16_snorm) $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE rgba8_snorm) $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE rg16_snorm) $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE rg8_snorm) $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE r16_snorm) $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE r8_snorm) When a texture is bound to an image unit, the $(D_INLINECODE format) parameter for the image unit need not exactly match the texture internal format as long as the formats are considered compatible as defined in the OpenGL Specification. The matching criterion used for a given texture may be determined by calling $(D_INLINECODE glGetTexParameter) with $(D_INLINECODE value) set to $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE), with return values of $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE) and $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS), specifying matches by size and class, respectively.
     + 
     + The $(D_INLINECODE glBindImageTexture) is available only if the GL version is 4.2 or greater.
     + 
     + Params:
     +     unit    = Specifies the index of the image unit to which to bind the texture
     +     texture = Specifies the name of the texture to bind to the image unit.
     +     level   = Specifies the level of the texture that is to be bound.
     +     layered = Specifies whether a layered texture binding is to be established.
     +     layer   = If $(D_INLINECODE layered) is $(D_INLINECODE GL_FALSE), specifies the layer of $(D_INLINECODE texture) to be bound to the image unit. Ignored otherwise.
     +     access  = Specifies a token indicating the type of access that will be performed on the image.
     +     format  = Specifies the format that the elements of the image will be treated as for the purposes of formatted stores.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTextures), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glBindTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_image_load_store")
    void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) @system @nogc nothrow;

    /++
     + glBindImageTextures: man4/glBindImageTextures.xml
     + 
     + $(D_INLINECODE glBindImageTextures) binds images from an array of existing texture objects to a specified number of consecutive image units. $(D_INLINECODE count) specifies the number of texture objects whose names are stored in the array $(D_INLINECODE textures). That number of texture names are read from the array and bound to the $(D_INLINECODE count) consecutive texture units starting from $(D_INLINECODE first). If the name zero appears in the $(D_INLINECODE textures) array, any existing binding to the image unit is reset. Any non-zero entry in $(D_INLINECODE textures) must be the name of an existing texture object. When a non-zero entry in $(D_INLINECODE textures) is present, the image at level zero is bound, the binding is considered layered, with the first layer set to zero, and the image is bound for read-write access. The image unit format parameter is taken from the internal format of the image at level zero of the texture object. For cube map textures, the internal format of the positive X image of level zero is used. If $(D_INLINECODE textures) is $(D_INLINECODE null
     + ) then it is as if an appropriately sized array containing only zeros had been specified. $(D_INLINECODE glBindImageTextures) is equivalent to the following pseudo code:
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (textures == NULL || textures[i] = 0) {
     +         glBindImageTexture(first + i, 0, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R8);
     +     } else {
     +         glBindImageTexture(first + i, textures[i], 0, GL_TRUE, 0, GL_READ_WRITE, lookupInternalFormat(textures[i]));
     +     }
     + }
     + ---
     +  Each entry in $(D_INLINECODE textures) will be checked individually and if found to be invalid, the state for that image unit will not be changed and an error will be generated. However, the state for other texture image units referenced by the command will still be updated.
     + 
     + $(D_INLINECODE glBindImageTextures) is available only if the GL version is 4.4 or higher. Note that because $(D_INLINECODE glBindImageTextures) cannot create new textures (even if a name passed has been previously generated by call to $(D_INLINECODE glGenTextures) ), names pased to $(D_INLINECODE glBindTextures) must have been bound at least once previously via a call to $(D_INLINECODE glBindTexture).
     + 
     + Params:
     +     first    = Specifies the first image unit to which a texture is to be bound.
     +     count    = Specifies the number of textures to bind.
     +     textures = Specifies the address of an array of names of existing texture objects.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glBindTextures), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage2DMultisample), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glTexStorage3DMultisample), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindImageTextures(GLuint first, GLsizei count, const GLuint* textures) @system @nogc nothrow;

    /++
     + glBindProgramPipeline: man4/glBindProgramPipeline.xml
     + 
     + $(D_INLINECODE glBindProgramPipeline) binds a program pipeline object to the current context. $(D_INLINECODE pipeline) must be a name previously returned from a call to $(D_INLINECODE glGenProgramPipelines). If no program pipeline exists with name $(D_INLINECODE pipeline) then a new pipeline object is created with that name and initialized to the default state vector. When a program pipeline object is bound using $(D_INLINECODE glBindProgramPipeline), any previous binding is broken and is replaced with a binding to the specified pipeline object. If $(D_INLINECODE pipeline) is zero, the previous binding is broken and is not replaced, leaving no pipeline object bound. If no current program object has been established by $(D_INLINECODE glUseProgram), the program objects used for each stage and for uniform updates are taken from the bound program pipeline object, if any. If there is a current program object established by $(D_INLINECODE glUseProgram), the bound program pipeline object has no effect on rendering or uniform updates. When a bound program pipeline object is used for rendering, individual shader executables are taken from its program objects.
     + 
     + Params:
     +     pipeline = Specifies the name of the pipeline object to bind to the context.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCompileShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glIsProgramPipeline)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glBindProgramPipeline(GLuint pipeline) @system @nogc nothrow;

    /++
     + glBindRenderbuffer: man4/glBindRenderbuffer.xml
     + 
     + $(D_INLINECODE glBindRenderbuffer) binds the renderbuffer object with name $(D_INLINECODE renderbuffer) to the renderbuffer target specified by $(D_INLINECODE target). $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER). $(D_INLINECODE renderbuffer) is the name of a renderbuffer object previously returned from a call to $(D_INLINECODE glGenRenderbuffers), or zero to break the existing binding of a renderbuffer object to $(D_INLINECODE target).
     + 
     + Params:
     +     target       = Specifies the renderbuffer target of the binding operation. $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer = Specifies the name of the renderbuffer object to bind.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteRenderbuffers), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glIsRenderbuffer), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glRenderbufferStorageMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glBindRenderbuffer(GLenum target, GLuint renderbuffer) @system @nogc nothrow;

    /++
     + glBindSampler: man4/glBindSampler.xml
     + 
     + $(D_INLINECODE glBindSampler) binds $(D_INLINECODE sampler) to the texture unit at index $(D_INLINECODE unit). $(D_INLINECODE sampler) must be zero or the name of a sampler object previously returned from a call to $(D_INLINECODE glGenSamplers). $(D_INLINECODE unit) must be less than the value of $(D_INLINECODE GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS). When a sampler object is bound to a texture unit, its state supersedes that of the texture object bound to that texture unit. If the sampler name zero is bound to a texture unit, the currently bound texture's sampler state becomes active. A single sampler object may be bound to multiple texture units simultaneously.
     + 
     + $(D_INLINECODE glBindSampler) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     unit    = Specifies the index of the texture unit to which the sampler is bound.
     +     sampler = Specifies the name of a sampler.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glGet), $(D_INLINECODE glSamplerParameter), $(D_INLINECODE glGetSamplerParameter), $(D_INLINECODE glGenTextures), $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glBindSampler(GLuint unit, GLuint sampler) @system @nogc nothrow;

    /++
     + glBindSamplers: man4/glBindSamplers.xml
     + 
     + $(D_INLINECODE glBindSamplers) binds samplers from an array of existing sampler objects to a specified number of consecutive sampler units. $(D_INLINECODE count) specifies the number of sampler objects whose names are stored in the array $(D_INLINECODE samplers). That number of sampler names is read from the array and bound to the $(D_INLINECODE count) consecutive sampler units starting from $(D_INLINECODE first). If the name zero appears in the $(D_INLINECODE samplers) array, any existing binding to the sampler unit is reset. Any non-zero entry in $(D_INLINECODE samplers) must be the name of an existing sampler object. When a non-zero entry in $(D_INLINECODE samplers) is present, that sampler object is bound to the corresponding sampler unit. If $(D_INLINECODE samplers) is $(D_INLINECODE null
     + ) then it is as if an appropriately sized array containing only zeros had been specified. $(D_INLINECODE glBindSamplers) is equivalent to the following pseudo code:
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (samplers == NULL) {
     +         glBindSampler(first + i, 0);
     +     } else {
     +         glBindSampler(first + i, samplers[i]);
     +     }
     + }
     + ---
     +  Each entry in $(D_INLINECODE samplers) will be checked individually and if found to be invalid, the state for that sampler unit will not be changed and an error will be generated. However, the state for other sampler units referenced by the command will still be updated.
     + 
     + $(D_INLINECODE glBindSamplers) is available only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     first    = Specifies the first sampler unit to which a sampler object is to be bound.
     +     count    = Specifies the number of samplers to bind.
     +     samplers = Specifies the address of an array of names of existing sampler objects.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glBindSampler), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glGet), $(D_INLINECODE glSamplerParameter), $(D_INLINECODE glGetSamplerParameter), $(D_INLINECODE glGenTextures), $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindSamplers(GLuint first, GLsizei count, const GLuint* samplers) @system @nogc nothrow;

    /++
     + glBindTexture: man4/glBindTexture.xml
     + 
     + $(D_INLINECODE glBindTexture) lets you create or use a named texture. Calling $(D_INLINECODE glBindTexture) with $(D_INLINECODE target) set to $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) and $(D_INLINECODE texture) set to the name of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for that target is automatically broken. Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions. You must use $(D_INLINECODE glGenTextures) to generate a set of new texture names. When a texture is first bound, it assumes the specified target: A texture first bound to $(D_INLINECODE GL_TEXTURE_1D) becomes one-dimensional texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_2D) becomes two-dimensional texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_3D) becomes three-dimensional texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_1D_ARRAY) becomes one-dimensional array texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_2D_ARRAY) becomes two-dimensional array texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_RECTANGLE) becomes rectangle texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_CUBE_MAP) becomes a cube-mapped texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) becomes a cube-mapped array texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_BUFFER) becomes a buffer texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) becomes a two-dimensional multisampled texture, and a texture first bound to $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) becomes a two-dimensional multisampled array texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the default $(D_INLINECODE GL_TEXTURE_1D) at GL initialization, and similarly for the other texture types. While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization. A texture binding created with $(D_INLINECODE glBindTexture) remains active until a different texture is bound to the same target, or until the bound texture is deleted with $(D_INLINECODE glDeleteTextures). Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use $(D_INLINECODE glBindTexture) to bind an existing named texture to one of the texture targets than it is to reload the texture image using $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D) or another similar function.
     + 
     + The $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) and $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) targets are available only if the GL version is 3.2 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound. Must be one of $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
     +     texture = Specifies the name of a texture.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glBindTexture(GLenum target, GLuint texture) @system @nogc nothrow;

    /++
     + glBindTextures: man4/glBindTextures.xml
     + 
     + $(D_INLINECODE glBindTextures) binds an array of existing texture objects to a specified number of consecutive texture units. $(D_INLINECODE count) specifies the number of texture objects whose names are stored in the array $(D_INLINECODE textures). That number of texture names are read from the array and bound to the $(D_INLINECODE count) consecutive texture units starting from $(D_INLINECODE first). The target, or type of texture is deduced from the texture object and each texture is bound to the corresponding target of the texture unit. If the name zero appears in the $(D_INLINECODE textures) array, any existing binding to any target of the texture unit is reset and the default texture for that target is bound in its place. Any non-zero entry in $(D_INLINECODE textures) must be the name of an existing texture object. If $(D_INLINECODE textures) is $(D_INLINECODE null
     + ) then it is as if an appropriately sized array containing only zeros had been specified. With the exception that the active texture selector maintains its current value, $(D_INLINECODE glBindTextures) is equivalent to the following pseudo code:
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     GLuint texture;
     +     if (textures == NULL) {
     +         texture = 0;
     +     } else {
     +         texture = textures[i];
     +     }
     +     glActiveTexture(GL_TEXTURE0 + first + i);
     +     if (texture != 0) {
     +         GLenum target = /* target of textures[i] */;
     +         glBindTexture(target, textures[i]);
     +     } else {
     +         for (target in all supported targets) {
     +             glBindTexture(target, 0);
     +         }
     +     }
     + }
     + ---
     +  Each entry in $(D_INLINECODE textures) will be checked individually and if found to be invalid, the state for that texture unit will not be changed and an error will be generated. However, the state for other texture units referenced by the command will still be updated.
     + 
     + $(D_INLINECODE glBindTextures) is available only if the GL version is 4.4 or higher. Note that because $(D_INLINECODE glBindTextures) cannot create new textures (even if a name passed has been previously generated by call to $(D_INLINECODE glGenTextures) ), names pased to $(D_INLINECODE glBindTextures) must have been bound at least once previously via a call to $(D_INLINECODE glBindTexture).
     + 
     + Params:
     +     first    = Specifies the first texture unit to which a texture is to be bound.
     +     count    = Specifies the number of textures to bind.
     +     textures = Specifies the address of an array of names of existing texture objects.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindTextures(GLuint first, GLsizei count, const GLuint* textures) @system @nogc nothrow;

    /++
     + glBindTextureUnit: man4/glBindTextureUnit.xml
     + 
     + $(D_INLINECODE glBindTextureUnit) binds an existing texture object to the texture unit numbered $(D_INLINECODE unit). $(D_INLINECODE texture) must be zero or the name of an existing texture object. When $(D_INLINECODE texture) is the name of an existing texture object, that object is bound to the target, in the corresponding texture unit, that was specified when the object was created. When $(D_INLINECODE texture) is zero, each of the targets enumerated at the beginning of this section is reset to its default texture for the corresponding texture image unit.
     + 
     + Params:
     +     unit    = Specifies the texture unit, to which the texture object should be bound to.
     +     texture = Specifies the name of a texture.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glBindTextureUnit(GLuint unit, GLuint texture) @system @nogc nothrow;

    /++
     + glBindTransformFeedback: man4/glBindTransformFeedback.xml
     + 
     + $(D_INLINECODE glBindTransformFeedback) binds the transform feedback object with name $(D_INLINECODE id) to the current GL state. $(D_INLINECODE id) must be a name previously returned from a call to $(D_INLINECODE glGenTransformFeedbacks). If $(D_INLINECODE id) has not previously been bound, a new transform feedback object with name $(D_INLINECODE id) and initialized with with the default transform state vector is created. In the initial state, a default transform feedback object is bound and treated as a transform feedback object with a name of zero. If the name zero is subsequently bound, the default transform feedback object is again bound to the GL state. While a transform feedback buffer object is bound, GL operations on the target to which it is bound affect the bound transform feedback object, and queries of the target to which a transform feedback object is bound return state from the bound object. When buffer objects are bound for transform feedback, they are attached to the currently bound transform feedback object. Buffer objects are used for trans- form feedback only if they are attached to the currently bound transform feedback object.
     + 
     + Params:
     +     target = Specifies the target to which to bind the transform feedback object $(D_INLINECODE id). $(D_INLINECODE target) must be $(D_INLINECODE GL_TRANSFORM_FEEDBACK).
     +     id     = Specifies the name of a transform feedback object reserved by $(D_INLINECODE glGenTransformFeedbacks).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glDeleteTransformFeedbacks), $(D_INLINECODE glIsTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glResumeTransformFeedback), $(D_INLINECODE glEndTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glBindTransformFeedback(GLenum target, GLuint id) @system @nogc nothrow;

    /++
     + glBindVertexArray: man4/glBindVertexArray.xml
     + 
     + $(D_INLINECODE glBindVertexArray) binds the vertex array object with name $(D_INLINECODE array). $(D_INLINECODE array) is the name of a vertex array object previously returned from a call to $(D_INLINECODE glGenVertexArrays), or zero to break the existing vertex array object binding. If no vertex array object with name $(D_INLINECODE array) exists, one is created when $(D_INLINECODE array) is first bound. If the bind is successful no change is made to the state of the vertex array object, and any previous vertex array object binding is broken.
     + 
     + Params:
     +     array = Specifies the name of the vertex array to bind.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteVertexArrays), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glGenVertexArrays), $(D_INLINECODE glIsVertexArray), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    void glBindVertexArray(GLuint array) @system @nogc nothrow;

    /++
     + glBindVertexBuffer: man4/glBindVertexBuffer.xml
     + 
     + $(D_INLINECODE glBindVertexBuffer) and $(D_INLINECODE glVertexArrayVertexBuffer) bind the buffer named $(D_INLINECODE buffer) to the vertex buffer binding point whose index is given by $(D_INLINECODE bindingindex). $(D_INLINECODE glBindVertexBuffer) modifies the binding of the currently bound vertex array object, whereas $(D_INLINECODE glVertexArrayVertexBuffer) allows the caller to specify ID of the vertex array object with an argument named $(D_INLINECODE vaobj), for which the binding should be modified. $(D_INLINECODE offset) and $(D_INLINECODE stride) specify the offset of the first element within the buffer and the distance between elements within the buffer, respectively, and are both measured in basic machine units. $(D_INLINECODE bindingindex) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIB_BINDINGS). $(D_INLINECODE offset) and $(D_INLINECODE stride) must be greater than or equal to zero. If $(D_INLINECODE buffer) is zero, then any buffer currently bound to the specified binding point is unbound. If $(D_INLINECODE buffer) is not the name of an existing buffer object, the GL first creates a new state vector, initialized with a zero-sized memory buffer and comprising all the state and with the same initial values as in case of $(D_INLINECODE glBindBuffer). $(D_INLINECODE buffer) is then attached to the specified $(D_INLINECODE bindingindex) of the vertex array object.
     + 
     + Params:
     +     vaobj        = Specifies the name of the vertex array object to be used by $(D_INLINECODE glVertexArrayVertexBuffer) function.
     +     bindingindex = The index of the vertex buffer binding point to which to bind the buffer.
     +     buffer       = The name of a buffer to bind to the vertex buffer binding point.
     +     offset       = The offset of the first element of the buffer.
     +     stride       = The distance between elements within the buffer.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glVertexAttribBinding), $(D_INLINECODE glVertexAttribFormat), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexBindingDivisor).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) @system @nogc nothrow;

    /++
     + glBindVertexBuffers: man4/glBindVertexBuffers.xml
     + 
     + $(D_INLINECODE glBindVertexBuffers) and $(D_INLINECODE glVertexArrayVertexBuffers) bind storage from an array of existing buffer objects to a specified number of consecutive vertex buffer binding points units in a vertex array object. For $(D_INLINECODE glBindVertexBuffers), the vertex array object is the currently bound vertex array object. For $(D_INLINECODE glVertexArrayVertexBuffers), $(D_INLINECODE vaobj) is the name of the vertex array object. $(D_INLINECODE count) existing buffer objects are bound to vertex buffer binding points numbered $first$ through $first + count - 1$. If $(D_INLINECODE buffers) is not null, it
     +  specifies an array of
     +  $(D_INLINECODE count) values, each of which must be zero or the name of an existing buffer object. $(D_INLINECODE offsets) and $(D_INLINECODE strides) specify arrays of $(D_INLINECODE count) values indicating the offset of the first element and stride between elements in each buffer, respectively. If $(D_INLINECODE buffers) is null, each
     +  affected vertex buffer binding point from $first$ through $first
     +  + count - 1$ will be reset to have no bound buffer object. In
     +  this case, the offsets and strides associated with the binding
     +  points are set to default values, ignoring
     +  $(D_INLINECODE offsets) and $(D_INLINECODE strides). $(D_INLINECODE glBindVertexBuffers) is equivalent (assuming no errors are generated) to:
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (buffers == NULL) {
     +         glBindVertexBuffer(first + i, 0, 0, 16);
     +     } else {
     +         glBindVertexBuffer(first + i, buffers[i], offsets[i], strides[i]);
     +     }
     + }
     + ---
     +  except that buffers will not be created if they do not exist. $(D_INLINECODE glVertexArrayVertexBuffers) is equivalent to the pseudocode above, but replacing $(D_INLINECODE glBindVertexBuffers) (args) with $(D_INLINECODE glVertexArrayVertexBuffers) (vaobj, args). The values specified in $(D_INLINECODE buffers), $(D_INLINECODE offsets), and $(D_INLINECODE strides) will be checked separately for each vertex buffer binding point. When a value for a specific vertex buffer binding point is invalid, the state for that binding point will be unchanged and an error will be generated. However, state for other vertex buffer binding points will still be changed if their corresponding values are valid.
     + 
     + Params:
     +     vaobj   = Specifies the name of the vertex array object for $(D_INLINECODE glVertexArrayVertexBuffers).
     +     first   = Specifies the first vertex buffer binding point to which a buffer object is to be bound.
     +     count   = Specifies the number of buffers to bind.
     +     buffers = Specifies the address of an array of names of existing buffer objects.
     +     offsets = Specifies the address of an array of offsets to associate with the binding points.
     +     buffers = Specifies the address of an array of strides to associate with the binding points.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDeleteBuffers) $(D_INLINECODE glDeleteTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint* buffers, const GLuintptr* offsets, const GLsizei* strides) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides) @system @nogc nothrow;

    /++
     + glBlendColor: man4/glBlendColor.xml
     + 
     + The $(D_INLINECODE GL_BLEND_COLOR) may be used to calculate the source and destination blending factors. The color components are clamped to the range 0 1 before being stored. See $(D_INLINECODE glBlendFunc) for a complete description of the blending operations. Initially the $(D_INLINECODE GL_BLEND_COLOR) is set to (0, 0, 0, 0).
     + 
     + The type of the $(D_INLINECODE red), $(D_INLINECODE green), $(D_INLINECODE blue), and $(D_INLINECODE alpha) parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     red = specify the components of $(D_INLINECODE GL_BLEND_COLOR)
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendEquation), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glGetString), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    @OpenGL_Extension("GL_ARB_imaging")
    void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;

    /++
     + glBlendEquation: man4/glBlendEquation.xml
     + 
     + The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color).  This function sets both the RGB blend equation and the alpha blend equation to a single equation. $(D_INLINECODE glBlendEquationi) specifies the blend equation for a single draw buffer whereas $(D_INLINECODE glBlendEquation) sets the blend equation for all draw buffers. These equations use the source and destination blend factors specified by either $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate). See $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate) for a description of the various blend factors. In the equations that follow, source and destination color components are referred to as R s G s B s A s and R d G d B d A d, respectively. The result color is referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G s B s A and d R d G d B d A, respectively. For these equations all color components are understood to have values in the range 0 1. $(B Mode) $(B RGB Components) $(B Alpha Component) $(D_INLINECODE GL_FUNC_ADD) Rr = R s &it; s R + R d &it; d R Gr = G s &it; s G + G d &it; d G Br = B s &it; s B + B d &it; d B Ar = A s &it; s A + A d &it; d A $(D_INLINECODE GL_FUNC_SUBTRACT) Rr = R s &it; s R - R d &it; d R Gr = G s &it; s G - G d &it; d G Br = B s &it; s B - B d &it; d B Ar = A s &it; s A - A d &it; d A $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT) Rr = R d &it; d R - R s &it; s R Gr = G d &it; d G - G s &it; s G Br = B d &it; d B - B s &it; s B Ar = A d &it; d A - A s &it; s A $(D_INLINECODE GL_MIN) Rr = min &af; R s R d Gr = min &af; G s G d Br = min &af; B s B d Ar = min &af; A s A d $(D_INLINECODE GL_MAX) Rr = max &af; R s R d Gr = max &af; G s G d Br = max &af; B s B d Ar = max &af; A s A d The results of these equations are clamped to the range 0 1. The $(D_INLINECODE GL_MIN) and $(D_INLINECODE GL_MAX) equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The $(D_INLINECODE GL_FUNC_ADD) equation is useful for antialiasing and transparency, among other things. Initially, both the RGB blend equation and the alpha blend equation are set to $(D_INLINECODE GL_FUNC_ADD).
     + 
     + The $(D_INLINECODE GL_MIN), and $(D_INLINECODE GL_MAX) equations do not use the source or destination factors, only the source and destination colors.
     + 
     + Params:
     +     buf  = for $(D_INLINECODE glBlendEquationi), specifies the index of the draw buffer for which to set the blend equation.
     +     mode = specifies how source and destination colors are combined. It must be $(D_INLINECODE GL_FUNC_ADD), $(D_INLINECODE GL_FUNC_SUBTRACT), $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT), $(D_INLINECODE GL_MIN), $(D_INLINECODE GL_MAX).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc) $(D_INLINECODE glBlendFuncSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    @OpenGL_Extension("GL_ARB_imaging")
    void glBlendEquation(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glBlendEquationi(GLuint buf, GLenum mode) @system @nogc nothrow;

    /++
     + glBlendEquationSeparate: man4/glBlendEquationSeparate.xml
     + 
     + The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color).  These functions specify one blend equation for the RGB-color components and one blend equation for the alpha component. $(D_INLINECODE glBlendEquationSeparatei) specifies the blend equations for a single draw buffer whereas $(D_INLINECODE glBlendEquationSeparate) sets the blend equations for all draw buffers. The blend equations use the source and destination blend factors specified by either $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate). See $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate) for a description of the various blend factors. In the equations that follow, source and destination color components are referred to as R s G s B s A s and R d G d B d A d, respectively. The result color is referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G s B s A and d R d G d B d A, respectively. For these equations all color components are understood to have values in the range 0 1. $(B Mode) $(B RGB Components) $(B Alpha Component) $(D_INLINECODE GL_FUNC_ADD) Rr = R s &it; s R + R d &it; d R Gr = G s &it; s G + G d &it; d G Br = B s &it; s B + B d &it; d B Ar = A s &it; s A + A d &it; d A $(D_INLINECODE GL_FUNC_SUBTRACT) Rr = R s &it; s R - R d &it; d R Gr = G s &it; s G - G d &it; d G Br = B s &it; s B - B d &it; d B Ar = A s &it; s A - A d &it; d A $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT) Rr = R d &it; d R - R s &it; s R Gr = G d &it; d G - G s &it; s G Br = B d &it; d B - B s &it; s B Ar = A d &it; d A - A s &it; s A $(D_INLINECODE GL_MIN) Rr = min &af; R s R d Gr = min &af; G s G d Br = min &af; B s B d Ar = min &af; A s A d $(D_INLINECODE GL_MAX) Rr = max &af; R s R d Gr = max &af; G s G d Br = max &af; B s B d Ar = max &af; A s A d The results of these equations are clamped to the range 0 1. The $(D_INLINECODE GL_MIN) and $(D_INLINECODE GL_MAX) equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The $(D_INLINECODE GL_FUNC_ADD) equation is useful for antialiasing and transparency, among other things. Initially, both the RGB blend equation and the alpha blend equation are set to $(D_INLINECODE GL_FUNC_ADD).
     + 
     + The $(D_INLINECODE GL_MIN), and $(D_INLINECODE GL_MAX) equations do not use the source or destination factors, only the source and destination colors.
     + 
     + Params:
     +     buf       = for $(D_INLINECODE glBlendEquationSeparatei), specifies the index of the draw buffer for which to set the blend equations.
     +     modeRGB   = specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be $(D_INLINECODE GL_FUNC_ADD), $(D_INLINECODE GL_FUNC_SUBTRACT), $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT), $(D_INLINECODE GL_MIN), $(D_INLINECODE GL_MAX).
     +     modeAlpha = specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be $(D_INLINECODE GL_FUNC_ADD), $(D_INLINECODE GL_FUNC_SUBTRACT), $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT), $(D_INLINECODE GL_MIN), $(D_INLINECODE GL_MAX).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetString), $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glBlendFuncSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;

    /++
     + glBlendFunc: man4/glBlendFunc.xml
     + 
     + Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_BLEND) to enable and disable blending. $(D_INLINECODE glBlendFunc) defines the operation of blending for all draw buffers when it is enabled. $(D_INLINECODE glBlendFunci) defines the operation of blending for a single draw buffer specified by $(D_INLINECODE buf) when enabled for that draw buffer. $(D_INLINECODE sfactor) specifies which method is used to scale the source color components. $(D_INLINECODE dfactor) specifies which method is used to scale the destination color components. Both parameters must be one of the following symbolic constants: $(D_INLINECODE GL_ZERO), $(D_INLINECODE GL_ONE), $(D_INLINECODE GL_SRC_COLOR), $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR), $(D_INLINECODE GL_DST_COLOR), $(D_INLINECODE GL_ONE_MINUS_DST_COLOR), $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), $(D_INLINECODE GL_DST_ALPHA), $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA), $(D_INLINECODE GL_CONSTANT_COLOR), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR), $(D_INLINECODE GL_CONSTANT_ALPHA), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA), $(D_INLINECODE GL_SRC_ALPHA_SATURATE), $(D_INLINECODE GL_SRC1_COLOR), $(D_INLINECODE GL_ONE_MINUS_SRC1_COLOR), $(D_INLINECODE GL_SRC1_ALPHA), and $(D_INLINECODE GL_ONE_MINUS_SRC1_ALPHA). The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as R s0 G s0 B s0 A s0, R s1 G s1 B s1 A s1 and R d G d B d A d, respectively. The color specified by $(D_INLINECODE glBlendColor) is referred to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B k A, where k c = 2 m c - 1 and m R m G m B m A is the number of red, green, blue, and alpha bitplanes. Source and destination scale factors are referred to as s R s G s B s A and d R d G d B d A. The scale factors described in the table, denoted f R f G f B f A, represent either source or destination factors. All scale factors have range 0 1. $(B Parameter) f R f G f B f A $(D_INLINECODE GL_ZERO) 0 0 0 0 $(D_INLINECODE GL_ONE) 1 1 1 1 $(D_INLINECODE GL_SRC_COLOR) R s0 k R G s0 k G B s0 k B A s0 k A $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 1 1 1 - R s0 k R G s0 k G B s0 k B A s0 k A $(D_INLINECODE GL_DST_COLOR) R d k R G d k G B d k B A d k A $(D_INLINECODE GL_ONE_MINUS_DST_COLOR) 1 1 1 1 - R d k R G d k G B d k B A d k A $(D_INLINECODE GL_SRC_ALPHA) A s0 k A A s0 k A A s0 k A A s0 k A $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 1 1 1 - A s0 k A A s0 k A A s0 k A A s0 k A $(D_INLINECODE GL_DST_ALPHA) A d k A A d k A A d k A A d k A $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA) 1 1 1 1 - A d k A A d k A A d k A A d k A $(D_INLINECODE GL_CONSTANT_COLOR) R c G c B c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR) 1 1 1 1 - R c G c B c A c $(D_INLINECODE GL_CONSTANT_ALPHA) A c A c A c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA) 1 1 1 1 - A c A c A c A c $(D_INLINECODE GL_SRC_ALPHA_SATURATE) i i i 1 $(D_INLINECODE GL_SRC1_COLOR) R s1 k R G s1 k G B s1 k B A s1 k A $(D_INLINECODE GL_ONE_MINUS_SRC1_COLOR) 1 1 1 1 - R s1 k R G s1 k G B s1 k B A s1 k A $(D_INLINECODE GL_SRC1_ALPHA) A s1 k A A s1 k A A s1 k A A s1 k A $(D_INLINECODE GL_ONE_MINUS_SRC1_ALPHA) 1 1 1 1 - A s1 k A A s1 k A A s1 k A A s1 k A In the table, i = min &af; A s k A - A d k A To determine the blended RGBA values of a pixel, the system uses the following equations: R d = min &af; k R R s &it; s R + R d &it; d R G d = min &af; k G G s &it; s G + G d &it; d G B d = min &af; k B B s &it; s B + B d &it; d B A d = min &af; k A A s &it; s A + A d &it; d A Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when $(D_INLINECODE sfactor) is $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE dfactor) is $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), and A s is equal to k A, the equations reduce to simple replacement: R d = R s G d = G s B d = B s A d = A s
     + 
     + Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency. When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See $(D_INLINECODE glDrawBuffer).) When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by $(D_INLINECODE GL_MAX_DUAL_SOURCE_DRAW_BUFFERS), which may be lower than $(D_INLINECODE GL_MAX_DRAW_BUFFERS).
     + 
     + Params:
     +     buf     = For $(D_INLINECODE glBlendFunci), specifies the index of the draw buffer for which to set the blend function.
     +     sfactor = Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is $(D_INLINECODE GL_ONE).
     +     dfactor = Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: $(D_INLINECODE GL_ZERO), $(D_INLINECODE GL_ONE), $(D_INLINECODE GL_SRC_COLOR), $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR), $(D_INLINECODE GL_DST_COLOR), $(D_INLINECODE GL_ONE_MINUS_DST_COLOR), $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), $(D_INLINECODE GL_DST_ALPHA), $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA). $(D_INLINECODE GL_CONSTANT_COLOR), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR), $(D_INLINECODE GL_CONSTANT_ALPHA), and $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA). The initial value is $(D_INLINECODE GL_ZERO).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendEquation), $(D_INLINECODE glBlendFuncSeparate), $(D_INLINECODE glClear), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glBlendFunc(GLenum sfactor, GLenum dfactor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor) @system @nogc nothrow;

    /++
     + glBlendFuncSeparate: man4/glBlendFuncSeparate.xml
     + 
     + Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_BLEND) to enable and disable blending. $(D_INLINECODE glBlendFuncSeparate) defines the operation of blending for all draw buffers when it is enabled. $(D_INLINECODE glBlendFuncSeparatei) defines the operation of blending for a single draw buffer specified by $(D_INLINECODE buf) when enabled for that draw buffer. $(D_INLINECODE srcRGB) specifies which method is used to scale the source RGB-color components. $(D_INLINECODE dstRGB) specifies which method is used to scale the destination RGB-color components. Likewise, $(D_INLINECODE srcAlpha) specifies which method is used to scale the source alpha color component, and $(D_INLINECODE dstAlpha) specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as R s0 G s0 B s0 A s0, R s1 G s1 B s1 A s1, and R d G d B d A d, respectively. The color specified by $(D_INLINECODE glBlendColor) is referred to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B k A, where k c = 2 m c - 1 and m R m G m B m A is the number of red, green, blue, and alpha bitplanes. Source and destination scale factors are referred to as s R s G s B s A and d R d G d B d A. All scale factors have range 0 1. $(B Parameter) $(B RGB Factor) $(B Alpha Factor) $(D_INLINECODE GL_ZERO) 0 0 0 0 $(D_INLINECODE GL_ONE) 1 1 1 1 $(D_INLINECODE GL_SRC_COLOR) R s0 k R G s0 k G B s0 k B A s0 k A $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 1 1 1 - R s0 k R G s0 k G B s0 k B 1 - A s0 k A $(D_INLINECODE GL_DST_COLOR) R d k R G d k G B d k B A d k A $(D_INLINECODE GL_ONE_MINUS_DST_COLOR) 1 1 1 - R d k R G d k G B d k B 1 - A d k A $(D_INLINECODE GL_SRC_ALPHA) A s0 k A A s0 k A A s0 k A A s0 k A $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 1 1 - A s0 k A A s0 k A A s0 k A 1 - A s0 k A $(D_INLINECODE GL_DST_ALPHA) A d k A A d k A A d k A A d k A $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA) 1 1 1 - A d k A A d k A A d k A 1 - A d k A $(D_INLINECODE GL_CONSTANT_COLOR) R c G c B c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR) 1 1 1 - R c G c B c 1 - A c $(D_INLINECODE GL_CONSTANT_ALPHA) A c A c A c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA) 1 1 1 - A c A c A c 1 - A c $(D_INLINECODE GL_SRC_ALPHA_SATURATE) i i i 1 $(D_INLINECODE GL_SRC1_COLOR) R s1 k R G s1 k G B s1 k B A s1 k A $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 1 1 1 - R s1 k R G s1 k G B s1 k B 1 - A s1 k A $(D_INLINECODE GL_SRC1_ALPHA) A s1 k A A s1 k A A s1 k A A s1 k A $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 1 1 - A s1 k A A s1 k A A s1 k A 1 - A s1 k A In the table, i = min &af; A s 1 - A d To determine the blended RGBA values of a pixel, the system uses the following equations: R d = min &af; k R R s &it; s R + R d &it; d R G d = min &af; k G G s &it; s G + G d &it; d G B d = min &af; k B B s &it; s B + B d &it; d B A d = min &af; k A A s &it; s A + A d &it; d A Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values.  However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0.  For example, when $(D_INLINECODE srcRGB) is $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE dstRGB) is $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), and A s is equal to k A, the equations reduce to simple replacement: R d = R s G d = G s B d = B s A d = A s
     + 
     + Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency. When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See $(D_INLINECODE glDrawBuffer).) When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by $(D_INLINECODE GL_MAX_DUAL_SOURCE_DRAW_BUFFERS), which may be lower than $(D_INLINECODE GL_MAX_DRAW_BUFFERS).
     + 
     + Params:
     +     buf      = For $(D_INLINECODE glBlendFuncSeparatei), specifies the index of the draw buffer for which to set the blend functions.
     +     srcRGB   = Specifies how the red, green, and blue blending factors are computed. The initial value is $(D_INLINECODE GL_ONE).
     +     dstRGB   = Specifies how the red, green, and blue destination blending factors are computed. The initial value is $(D_INLINECODE GL_ZERO).
     +     srcAlpha = Specified how the alpha source blending factor is computed. The initial value is $(D_INLINECODE GL_ONE).
     +     dstAlpha = Specified how the alpha destination blending factor is computed. The initial value is $(D_INLINECODE GL_ZERO).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glBlendEquation), $(D_INLINECODE glClear), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;

    /++
     + glBlitFramebuffer: man4/glBlitFramebuffer.xml
     + 
     + $(D_INLINECODE glBlitFramebuffer) and $(D_INLINECODE glBlitNamedFramebuffer) transfer a rectangle of pixel values from one region of a read framebuffer to another region of a draw framebuffer. For $(D_INLINECODE glBlitFramebuffer), the read and draw framebuffers are those bound to the $(D_INLINECODE GL_READ_FRAMEBUFFER) and $(D_INLINECODE GL_DRAW_FRAMEBUFFER) targets respectively. For $(D_INLINECODE glBlitNamedFramebuffer), $(D_INLINECODE readFramebuffer) and $(D_INLINECODE drawFramebuffer) are the names of the read read and draw framebuffer objects respectively. If $(D_INLINECODE readFramebuffer) or $(D_INLINECODE drawFramebuffer) is zero, then the default read or draw framebuffer respectively is used. $(D_INLINECODE mask) is the bitwise OR of a number of values indicating which buffers are to be copied. The values are $(D_INLINECODE GL_COLOR_BUFFER_BIT), $(D_INLINECODE GL_DEPTH_BUFFER_BIT), and $(D_INLINECODE GL_STENCIL_BUFFER_BIT). The pixels corresponding to these buffers are copied from the source rectangle bounded by the locations ( $(D_INLINECODE srcX0), $(D_INLINECODE srcY0) ) and ( $(D_INLINECODE srcX1), $(D_INLINECODE srcY1) ) to the destination rectangle bounded by the locations ( $(D_INLINECODE dstX0), $(D_INLINECODE dstY0) ) and ( $(D_INLINECODE dstX1), $(D_INLINECODE dstY1) ). The lower bounds of the rectangle are inclusive, while the upper bounds are exclusive. The actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred, which may include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending on mask. The actual region written to the draw framebuffer is limited to the intersection of the destination buffers being written, which may include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether or not the source or destination regions are altered due to these limits, the scaling and offset applied to pixels being transferred is performed as though no such limits were present. If the sizes of the source and destination rectangles are not equal, $(D_INLINECODE filter) specifies the interpolation method that will be applied to resize the source image , and must be $(D_INLINECODE GL_NEAREST) or $(D_INLINECODE GL_LINEAR). $(D_INLINECODE GL_LINEAR) is only a valid interpolation method for the color buffer. If $(D_INLINECODE filter) is not $(D_INLINECODE GL_NEAREST) and $(D_INLINECODE mask) includes $(D_INLINECODE GL_DEPTH_BUFFER_BIT) or $(D_INLINECODE GL_STENCIL_BUFFER_BIT), no data is transferred and a $(D_INLINECODE GL_INVALID_OPERATION) error is generated. If $(D_INLINECODE filter) is $(D_INLINECODE GL_LINEAR) and the source rectangle would require sampling outside the bounds of the source framebuffer, values are read as if the $(D_INLINECODE GL_CLAMP_TO_EDGE) texture wrapping mode were applied. When the color buffer is transferred, values are taken from the read buffer of the specified read framebuffer and written to each of the draw buffers of the specified draw framebuffer. If the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result of the operation is undefined.
     + 
     + Params:
     +     readFramebuffer = Specifies the name of the source framebuffer object for $(D_INLINECODE glBlitNamedFramebuffer).
     +     drawFramebuffer = Specifies the name of the destination framebuffer object for $(D_INLINECODE glBlitNamedFramebuffer).
     +     srcX0           = Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
     +     dstX0           = Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
     +     mask            = The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are $(D_INLINECODE GL_COLOR_BUFFER_BIT), $(D_INLINECODE GL_DEPTH_BUFFER_BIT) and $(D_INLINECODE GL_STENCIL_BUFFER_BIT).
     +     filter          = Specifies the interpolation to be applied if the image is stretched. Must be $(D_INLINECODE GL_NEAREST) or $(D_INLINECODE GL_LINEAR).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glReadPixels) $(D_INLINECODE glCheckFramebufferStatus), $(D_INLINECODE glGenFramebuffers) $(D_INLINECODE glBindFramebuffer) $(D_INLINECODE glDeleteFramebuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;

    /++
     + glBufferData: man4/glBufferData.xml
     + 
     + $(D_INLINECODE glBufferData) and $(D_INLINECODE glNamedBufferData) create a new data store for a buffer object. In case of $(D_INLINECODE glBufferData), the buffer object currently bound to $(D_INLINECODE target) is used. For $(D_INLINECODE glNamedBufferData), a buffer object associated with ID specified by the caller in $(D_INLINECODE buffer) will be used instead. While creating the new storage, any pre-existing data store is deleted. The new data store is created with the specified $(D_INLINECODE size) in bytes and $(D_INLINECODE usage). If $(D_INLINECODE data) is not $(D_INLINECODE null
     + ), the data store is initialized with data from this pointer. In its initial state, the new data store is not mapped, it has a $(D_INLINECODE null
     + ) mapped pointer, and its mapped access is $(D_INLINECODE GL_READ_WRITE). $(D_INLINECODE usage) is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. $(D_INLINECODE usage) can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these: The nature of access may be one of these:
     + 
     + If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), a data store of the specified size is still created, but its contents remain uninitialized and thus undefined. Clients must align data elements consistently with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N. The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glBufferData), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glNamedBufferData) function.
     +     size   = Specifies the size in bytes of the buffer object's new data store.
     +     data   = Specifies a pointer to data that will be copied into the data store for initialization, or $(D_INLINECODE null) if no data is to be copied.
     +     usage  = Specifies the expected usage pattern of the data store. The symbolic constant must be $(D_INLINECODE GL_STREAM_DRAW), $(D_INLINECODE GL_STREAM_READ), $(D_INLINECODE GL_STREAM_COPY), $(D_INLINECODE GL_STATIC_DRAW), $(D_INLINECODE GL_STATIC_READ), $(D_INLINECODE GL_STATIC_COPY), $(D_INLINECODE GL_DYNAMIC_DRAW), $(D_INLINECODE GL_DYNAMIC_READ), or $(D_INLINECODE GL_DYNAMIC_COPY).
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedBufferData(GLuint buffer, GLsizei size, const void* data, GLenum usage) @system @nogc nothrow;

    /++
     + glBufferStorage: man4/glBufferStorage.xml
     + 
     + $(D_INLINECODE glBufferStorage) and $(D_INLINECODE glNamedBufferStorage) create a new immutable data store. For $(D_INLINECODE glBufferStorage), the buffer object currently bound to $(D_INLINECODE target) will be initialized. For $(D_INLINECODE glNamedBufferStorage), $(D_INLINECODE buffer) is the name of the buffer object that will be configured. The size of the data store is specified by $(D_INLINECODE size). If an initial data is available, its address may be supplied in $(D_INLINECODE data). Otherwise, to create an uninitialized data store, $(D_INLINECODE data) should be $(D_INLINECODE null
     + ). The $(D_INLINECODE flags) parameters specifies the intended usage of the buffer's data store. It must be a bitwise combination of a subset of the following flags: The allowed combinations of flags are subject to certain restrictions. They are as follows: $(OL $(LI If $(D_INLINECODE flags) contains $(D_INLINECODE GL_MAP_PERSISTENT_BIT), it must also contain at least one of $(D_INLINECODE GL_MAP_READ_BIT) or $(D_INLINECODE GL_MAP_WRITE_BIT).) $(LI If $(D_INLINECODE flags) contains $(D_INLINECODE GL_MAP_COHERENT_BIT), it must also contain $(D_INLINECODE GL_MAP_PERSISTENT_BIT).))
     + 
     + $(D_INLINECODE glBufferStorage) is available only if the GL version is 4.4 or greater. $(D_INLINECODE glNamedBufferStorage) is available only if the GL version is 4.5 or greater. If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glBufferStorage), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glNamedBufferStorage) function.
     +     size   = Specifies the size in bytes of the buffer object's new data store.
     +     data   = Specifies a pointer to data that will be copied into the data store for initialization, or $(D_INLINECODE null) if no data is to be copied.
     +     flags  = Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. $(D_INLINECODE GL_DYNAMIC_STORAGE_BIT), $(D_INLINECODE GL_MAP_READ_BIT) $(D_INLINECODE GL_MAP_WRITE_BIT), $(D_INLINECODE GL_MAP_PERSISTENT_BIT), $(D_INLINECODE GL_MAP_COHERENT_BIT), and $(D_INLINECODE GL_CLIENT_STORAGE_BIT).
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_buffer_storage")
    void glBufferStorage(GLenum target, GLsizeiptr size, const GLvoid* data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedBufferStorage(GLuint buffer, GLsizei size, const void* data, GLbitfield flags) @system @nogc nothrow;

    /++
     + glBufferSubData: man4/glBufferSubData.xml
     + 
     + $(D_INLINECODE glBufferSubData) and $(D_INLINECODE glNamedBufferSubData) redefine some or all of the data store for the specified buffer object. Data starting at byte offset $(D_INLINECODE offset) and extending for $(D_INLINECODE size) bytes is copied to the data store from the memory pointed to by $(D_INLINECODE data). $(D_INLINECODE offset) and $(D_INLINECODE size) must define a range lying entirely within the buffer object's data store.
     + 
     + When replacing the entire data store, consider using $(D_INLINECODE glBufferSubData) rather than completely recreating the data store with $(D_INLINECODE glBufferData). This avoids the cost of reallocating the data store. Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by $(D_INLINECODE glBufferSubData), especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated. Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$. The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glBufferSubData), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glNamedBufferSubData).
     +     offset = Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
     +     size   = Specifies the size in bytes of the data store region being replaced.
     +     data   = Specifies a pointer to the new data that will be copied into the data store.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glMapBufferRange), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizei size, const void* data) @system @nogc nothrow;

    /++
     + glCheckFramebufferStatus: man4/glCheckFramebufferStatus.xml
     + 
     + $(D_INLINECODE glCheckFramebufferStatus) and $(D_INLINECODE glCheckNamedFramebufferStatus) return the completeness status of a framebuffer object when treated as a read or draw framebuffer, depending on the value of $(D_INLINECODE target). For $(D_INLINECODE glCheckFramebufferStatus), the framebuffer checked is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glCheckNamedFramebufferStatus), $(D_INLINECODE framebuffer) is zero or the name of the framebuffer object to check. If $(D_INLINECODE framebuffer) is zero, then the status of the default read or draw framebuffer, as determined by $(D_INLINECODE target), is returned. The return value is $(D_INLINECODE GL_FRAMEBUFFER_COMPLETE) if the specified framebuffer is complete. Otherwise, the return value is determined as follows: $(OL $(LI $(D_INLINECODE GL_FRAMEBUFFER_UNDEFINED) is returned if the specified framebuffer is the default read or draw framebuffer, but the default framebuffer does not exist.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT) is returned if any of the framebuffer attachment points are framebuffer incomplete.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) is returned if the framebuffer does not have at least one image attached to it.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER) is returned if the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_NONE) for any color attachment point(s) named by $(D_INLINECODE GL_DRAW_BUFFERi).) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER) is returned if $(D_INLINECODE GL_READ_BUFFER) is not $(D_INLINECODE GL_NONE) and the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_NONE) for the color attachment point named by $(D_INLINECODE GL_READ_BUFFER).) $(LI $(D_INLINECODE GL_FRAMEBUFFER_UNSUPPORTED) is returned if the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) is returned if the value of $(D_INLINECODE GL_RENDERBUFFER_SAMPLES) is not the same for all attached renderbuffers; if the value of $(D_INLINECODE GL_TEXTURE_SAMPLES) is the not same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of $(D_INLINECODE GL_RENDERBUFFER_SAMPLES) does not match the value of $(D_INLINECODE GL_TEXTURE_SAMPLES).) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) is also returned if the value of $(D_INLINECODE GL_TEXTURE_FIXED_SAMPLE_LOCATIONS) is not the same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of $(D_INLINECODE GL_TEXTURE_FIXED_SAMPLE_LOCATIONS) is not $(D_INLINECODE GL_TRUE) for all attached textures.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS) is returned if any framebuffer attachment is layered, and any populated attachment is not layered, or if all populated color attachments are not from textures of the same target.)) Additionally, if an error occurs, zero is returned.
     + 
     + Params:
     +     target      = Specify the target to which the framebuffer is bound for $(D_INLINECODE glCheckFramebufferStatus), and the target against which framebuffer completeness of $(D_INLINECODE framebuffer) is checked for $(D_INLINECODE glCheckNamedFramebufferStatus).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glCheckNamedFramebufferStatus)
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glDeleteFramebuffers) $(D_INLINECODE glBindFramebuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    GLenum glCheckFramebufferStatus(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target) @system @nogc nothrow;

    /++
     + glClampColor: man4/glClampColor.xml
     + 
     + $(D_INLINECODE glClampColor) controls color clamping that is performed during $(D_INLINECODE glReadPixels). $(D_INLINECODE target) must be $(D_INLINECODE GL_CLAMP_READ_COLOR). If $(D_INLINECODE clamp) is $(D_INLINECODE GL_TRUE), read color clamping is enabled; if $(D_INLINECODE clamp) is $(D_INLINECODE GL_FALSE), read color clamping is disabled. If $(D_INLINECODE clamp) is $(D_INLINECODE GL_FIXED_ONLY), read color clamping is enabled only if the selected read buffer has fixed point components and disabled otherwise.
     + 
     + Params:
     +     target = Target for color clamping. $(D_INLINECODE target) must be $(D_INLINECODE GL_CLAMP_READ_COLOR).
     +     clamp  = Specifies whether to apply color clamping. $(D_INLINECODE clamp) must be $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClampColor(GLenum target, GLenum clamp) @system @nogc nothrow;

    /++
     + glClear: man4/glClear.xml
     + 
     + $(D_INLINECODE glClear) sets the bitplane area of the window to values previously selected by $(D_INLINECODE glClearColor), $(D_INLINECODE glClearDepth), and $(D_INLINECODE glClearStencil). Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using $(D_INLINECODE glDrawBuffer). The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of $(D_INLINECODE glClear). The scissor box bounds the cleared region. Alpha function, blend function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by $(D_INLINECODE glClear). $(D_INLINECODE glClear) takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared. The values are as follows: The value to which each buffer is cleared depends on the setting of the clear value for that buffer.
     + 
     + If a buffer is not present, then a $(D_INLINECODE glClear) directed at that buffer has no effect.
     + 
     + Params:
     +     mask = Bitwise OR of masks that indicate the buffers to be cleared. The three masks are $(D_INLINECODE GL_COLOR_BUFFER_BIT), $(D_INLINECODE GL_DEPTH_BUFFER_BIT), and $(D_INLINECODE GL_STENCIL_BUFFER_BIT).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearColor), $(D_INLINECODE glClearDepth), $(D_INLINECODE glClearStencil), $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClear(GLbitfield mask) @system @nogc nothrow;

    /++
     + glClearBuffer: man4/glClearBuffer.xml
     + 
     + These commands clear a specified buffer of a framebuffer to specified value(s). For $(D_INLINECODE glClearBuffer*), the framebuffer is the currently bound draw framebuffer object. For $(D_INLINECODE glClearNamedFramebuffer*), $(D_INLINECODE framebuffer) is zero, indicating the default draw framebuffer, or the name of a framebuffer object. $(D_INLINECODE buffer) and $(D_INLINECODE drawbuffer) identify the buffer to clear. If $(D_INLINECODE buffer) is $(D_INLINECODE GL_COLOR), a particular draw buffer $(D_INLINECODE GL_DRAW_BUFFER) $(D_INLINECODE i) is specified by passing $(D_INLINECODE i) as $(D_INLINECODE drawbuffer), and $(D_INLINECODE value) points to a four-element vector specifying the R, G, B and A color to clear that draw buffer to. If the value of $(D_INLINECODE GL_DRAW_BUFFER) $(D_INLINECODE i) is $(D_INLINECODE GL_NONE), the command has no effect. Otherwise, the value of $(D_INLINECODE GL_DRAW_BUFFER) $(D_INLINECODE i) identifies one or more color buffers, each of which is cleared to the same value. Clamping and type conversion for fixed-point color buffers are performed in the same fashion as for $(D_INLINECODE glClearColor). The $(D_INLINECODE *fv), $(D_INLINECODE *iv) and $(D_INLINECODE *uiv) forms of these commands should be used to clear fixed- and floating-point, signed integer, and unsigned integer color buffers respectively. If $(D_INLINECODE buffer) is $(D_INLINECODE GL_DEPTH), $(D_INLINECODE drawbuffer) must be zero, and $(D_INLINECODE value) points to a single value to clear the depth buffer to. Clamping and type conversion for fixed-point depth buffers are performed in the same fashion as for $(D_INLINECODE glClearDepth). Only the $(D_INLINECODE *fv) forms of these commands should be used to clear depth buffers; other forms do not accept a $(D_INLINECODE buffer) of $(D_INLINECODE GL_DEPTH). If $(D_INLINECODE buffer) is $(D_INLINECODE GL_STENCIL), $(D_INLINECODE drawbuffer) must be zero, and $(D_INLINECODE value) points to a single value to clear the stencil buffer to. Masking is performed in the same fashion as for $(D_INLINECODE glClearStencil). Only the $(D_INLINECODE *iv) forms of these commands should be used to clear stencil buffers; be used to clear stencil buffers; other forms do not accept a $(D_INLINECODE buffer) of $(D_INLINECODE GL_STENCIL). $(D_INLINECODE glClearBufferfi) and $(D_INLINECODE glClearNamedFramebufferfi) are used to clear the depth and stencil buffers simultaneously. $(D_INLINECODE buffer) must be $(D_INLINECODE GL_DEPTH_STENCIL) and $(D_INLINECODE drawbuffer) must be zero. $(D_INLINECODE depth) and $(D_INLINECODE stencil) are the values to clear the depth and stencil buffers to, respectively. Clamping and type conversion of $(D_INLINECODE depth) for fixed-point depth buffers are performed in the same fashion as for $(D_INLINECODE glClearDepth). Masking of $(D_INLINECODE stencil) for stencil buffers is performed in the same fashion as for $(D_INLINECODE glClearStencil). These commands are equivalent to clearing the depth and stencil buffers separately, but may be faster when a buffer of internal format $(D_INLINECODE GL_DEPTH_STENCIL) is being cleared. The same per-fragment and masking operations defined for $(D_INLINECODE glClear) are applied. The result of these commands is undefined if no conversion between the type of the specified $(D_INLINECODE value) and the type of the buffer being cleared is defined (for example, if $(D_INLINECODE glClearBufferiv) is called for a fixed- or floating-point buffer, or if $(D_INLINECODE glClearBufferfv) is called for a signed or unsigned integer buffer). This is not an error.
     + 
     + Params:
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glClearNamedFramebuffer*).
     +     buffer      = Specify the buffer to clear.
     +     drawbuffer  = Specify a particular draw buffer to clear.
     +     value       = A pointer to the value or values to clear the buffer to.
     +     depth       = The value to clear the depth buffer to.
     +     stencil     = The value to clear the stencil buffer to.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearColor), $(D_INLINECODE glClearDepth), $(D_INLINECODE glClearStencil), $(D_INLINECODE glClear)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) @system @nogc nothrow;

    /++
     + glClearBufferData: man4/glClearBufferData.xml
     + 
     + $(D_INLINECODE glClearBufferData) and $(D_INLINECODE glClearNamedBufferData) fill the entirety of a buffer object's data store with data from client memory. Data, initially supplied in a format specified by $(D_INLINECODE format) in data type $(D_INLINECODE type) is read from the memory address given by $(D_INLINECODE data) and converted into the internal representation given by $(D_INLINECODE internalformat), which must be one of the following sized internal formats: $(B Component) $(B Sized Internal Format) $(B Base Type) $(B Components) $(B Norm) 0 1 2 3 $(D_INLINECODE GL_R8) ubyte 1 YES R 0 0 1 $(D_INLINECODE GL_R16) ushort 1 YES R 0 0 1 $(D_INLINECODE GL_R16F) half 1 NO R 0 0 1 $(D_INLINECODE GL_R32F) float 1 NO R 0 0 1 $(D_INLINECODE GL_R8I) byte 1 NO R 0 0 1 $(D_INLINECODE GL_R16I) short 1 NO R 0 0 1 $(D_INLINECODE GL_R32I) int 1 NO R 0 0 1 $(D_INLINECODE GL_R8UI) ubyte 1 NO R 0 0 1 $(D_INLINECODE GL_R16UI) ushort 1 NO R 0 0 1 $(D_INLINECODE GL_R32UI) uint 1 NO R 0 0 1 $(D_INLINECODE GL_RG8) ubyte 2 YES R G 0 1 $(D_INLINECODE GL_RG16) ushort 2 YES R G 0 1 $(D_INLINECODE GL_RG16F) half 2 NO R G 0 1 $(D_INLINECODE GL_RG32F) float 2 NO R G 0 1 $(D_INLINECODE GL_RG8I) byte 2 NO R G 0 1 $(D_INLINECODE GL_RG16I) short 2 NO R G 0 1 $(D_INLINECODE GL_RG32I) int 2 NO R G 0 1 $(D_INLINECODE GL_RG8UI) ubyte 2 NO R G 0 1 $(D_INLINECODE GL_RG16UI) ushort 2 NO R G 0 1 $(D_INLINECODE GL_RG32UI) uint 2 NO R G 0 1 $(D_INLINECODE GL_RGB32F) float 3 NO R G B 1 $(D_INLINECODE GL_RGB32I) int 3 NO R G B 1 $(D_INLINECODE GL_RGB32UI) uint 3 NO R G B 1 $(D_INLINECODE GL_RGBA8) uint 4 YES R G B A $(D_INLINECODE GL_RGBA16) short 4 YES R G B A $(D_INLINECODE GL_RGBA16F) half 4 NO R G B A $(D_INLINECODE GL_RGBA32F) float 4 NO R G B A $(D_INLINECODE GL_RGBA8I) byte 4 NO R G B A $(D_INLINECODE GL_RGBA16I) short 4 NO R G B A $(D_INLINECODE GL_RGBA32I) int 4 NO R G B A $(D_INLINECODE GL_RGBA8UI) ubyte 4 NO R G B A $(D_INLINECODE GL_RGBA16UI) ushort 4 NO R G B A $(D_INLINECODE GL_RGBA32UI) uint 4 NO R G B A This converted data is then replicated throughout the buffer object's data store. If $(D_INLINECODE data) is null,
     +  then the buffer's data store is filled with zeros.
     + 
     + Params:
     +     target         = Specifies the target to which the buffer object is bound for $(D_INLINECODE glClearBufferData), which must must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer         = Specifies the name of the buffer object for $(D_INLINECODE glClearNamedBufferData).
     +     internalformat = The internal format with which the data will be stored in the buffer object.
     +     format         = The format of the data in memory addressed by $(D_INLINECODE data).
     +     type           = The type of the data in memory addressed by $(D_INLINECODE data).
     +     data           = The address of a memory location storing the data to be replicated into the buffer's data store.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearBufferSubData).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_clear_buffer_object")
    void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data) @system @nogc nothrow;

    /++
     + glClearBufferSubData: man4/glClearBufferSubData.xml
     + 
     + $(D_INLINECODE glClearBufferSubData) and $(D_INLINECODE glClearNamedBufferSubData) fill a specified region of a buffer object's data store with data from client memory. $(D_INLINECODE offset) and $(D_INLINECODE size) specify the extent of the region within the data store of the buffer object to fill with data. Data, initially supplied in a format specified by $(D_INLINECODE format) in data type $(D_INLINECODE type) is read from the memory address given by $(D_INLINECODE data) and converted into the internal representation given by $(D_INLINECODE internalformat), which must be one of the following sized internal formats: $(B Component) $(B Sized Internal Format) $(B Base Type) $(B Components) $(B Norm) 0 1 2 3 $(D_INLINECODE GL_R8) ubyte 1 YES R 0 0 1 $(D_INLINECODE GL_R16) ushort 1 YES R 0 0 1 $(D_INLINECODE GL_R16F) half 1 NO R 0 0 1 $(D_INLINECODE GL_R32F) float 1 NO R 0 0 1 $(D_INLINECODE GL_R8I) byte 1 NO R 0 0 1 $(D_INLINECODE GL_R16I) short 1 NO R 0 0 1 $(D_INLINECODE GL_R32I) int 1 NO R 0 0 1 $(D_INLINECODE GL_R8UI) ubyte 1 NO R 0 0 1 $(D_INLINECODE GL_R16UI) ushort 1 NO R 0 0 1 $(D_INLINECODE GL_R32UI) uint 1 NO R 0 0 1 $(D_INLINECODE GL_RG8) ubyte 2 YES R G 0 1 $(D_INLINECODE GL_RG16) ushort 2 YES R G 0 1 $(D_INLINECODE GL_RG16F) half 2 NO R G 0 1 $(D_INLINECODE GL_RG32F) float 2 NO R G 0 1 $(D_INLINECODE GL_RG8I) byte 2 NO R G 0 1 $(D_INLINECODE GL_RG16I) short 2 NO R G 0 1 $(D_INLINECODE GL_RG32I) int 2 NO R G 0 1 $(D_INLINECODE GL_RG8UI) ubyte 2 NO R G 0 1 $(D_INLINECODE GL_RG16UI) ushort 2 NO R G 0 1 $(D_INLINECODE GL_RG32UI) uint 2 NO R G 0 1 $(D_INLINECODE GL_RGB32F) float 3 NO R G B 1 $(D_INLINECODE GL_RGB32I) int 3 NO R G B 1 $(D_INLINECODE GL_RGB32UI) uint 3 NO R G B 1 $(D_INLINECODE GL_RGBA8) uint 4 YES R G B A $(D_INLINECODE GL_RGBA16) short 4 YES R G B A $(D_INLINECODE GL_RGBA16F) half 4 NO R G B A $(D_INLINECODE GL_RGBA32F) float 4 NO R G B A $(D_INLINECODE GL_RGBA8I) byte 4 NO R G B A $(D_INLINECODE GL_RGBA16I) short 4 NO R G B A $(D_INLINECODE GL_RGBA32I) int 4 NO R G B A $(D_INLINECODE GL_RGBA8UI) ubyte 4 NO R G B A $(D_INLINECODE GL_RGBA16UI) ushort 4 NO R G B A $(D_INLINECODE GL_RGBA32UI) uint 4 NO R G B A This converted data is then replicated throughout the specified region of the buffer object's data store. If $(D_INLINECODE data) is null, then the subrange of the
     +  buffer's data store is filled with zeros.
     + 
     + Params:
     +     target         = Specifies the target to which the buffer object is bound for $(D_INLINECODE glClearBufferSubData), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer         = Specifies the name of the buffer object for $(D_INLINECODE glClearNamedBufferSubData).
     +     internalformat = The internal format with which the data will be stored in the buffer object.
     +     offset         = The offset in basic machine units into the buffer object's data store at which to start filling.
     +     size           = The size in basic machine units of the range of the data store to fill.
     +     format         = The format of the data in memory addressed by $(D_INLINECODE data).
     +     type           = The type of the data in memory addressed by $(D_INLINECODE data).
     +     data           = The address of a memory location storing the data to be replicated into the buffer's data store.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearBufferData).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_clear_buffer_object")
    void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizei size, GLenum format, GLenum type, const void* data) @system @nogc nothrow;

    /++
     + glClearColor: man4/glClearColor.xml
     + 
     + $(D_INLINECODE glClearColor) specifies the red, green, blue, and alpha values used by $(D_INLINECODE glClear) to clear the color buffers. Values specified by $(D_INLINECODE glClearColor) are clamped to the range 0 1.
     + 
     + The type of the $(D_INLINECODE red), $(D_INLINECODE green), $(D_INLINECODE blue), and $(D_INLINECODE alpha) parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     red = Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;

    /++
     + glClearDepth: man4/glClearDepth.xml
     + 
     + $(D_INLINECODE glClearDepth) specifies the depth value used by $(D_INLINECODE glClear) to clear the depth buffer. Values specified by $(D_INLINECODE glClearDepth) are clamped to the range 0 1.
     + 
     + The type of the $(D_INLINECODE depth) parameter was changed from GLclampf to GLfloat for $(D_INLINECODE glClearDepthf) and from GLclampd to GLdouble for $(D_INLINECODE glClearDepth). This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     depth = Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearDepth(GLdouble depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glClearDepthf(GLfloat depth) @system @nogc nothrow;

    /++
     + glClearStencil: man4/glClearStencil.xml
     + 
     + $(D_INLINECODE glClearStencil) specifies the index used by $(D_INLINECODE glClear) to clear the stencil buffer. $(D_INLINECODE s) is masked with 2 m - 1, where m is the number of bits in the stencil buffer.
     + 
     + Params:
     +     s = Specifies the index used when the stencil buffer is cleared. The initial value is 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearStencil(GLint s) @system @nogc nothrow;

    /++
     + glClearTexImage: man4/glClearTexImage.xml
     + 
     + $(D_INLINECODE glClearTexImage) fills all an image contained in a texture with an application supplied value. $(D_INLINECODE texture) must be the name of an existing texture. Further, $(D_INLINECODE texture) may not be the name of a buffer texture, nor may its internal format be compressed. $(D_INLINECODE format) and $(D_INLINECODE type) specify the format and type of the source data and are interpreted as they are for $(D_INLINECODE glTexImage3D). Textures with a base internal format of $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_STENCIL_INDEX), or $(D_INLINECODE GL_DEPTH_STENCIL) require depth component, stencil, or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures with integer internal formats require integer data. $(D_INLINECODE data) is a pointer to an array of between one and four components of texel data that will be used as the source for the constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was specified when the level was defined by any of the $(D_INLINECODE glTexImage*), $(D_INLINECODE glTexStorage*) or $(D_INLINECODE glCopyTexImage*) commands), and then used to fill the specified range of the destination texture level. If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), then the pointer is ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are cleared to the value specified by data.
     + 
     + $(D_INLINECODE glClearTexImage) is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     texture = The name of an existing texture object containing the image to be cleared.
     +     level   = The level of $(D_INLINECODE texture) containing the region to be cleared.
     +     format  = The format of the data whose address in memory is given by $(D_INLINECODE data).
     +     type    = The type of the data whose address in memory is given by $(D_INLINECODE data).
     +     data    = The address in memory of the data to be used to clear the specified region.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearTexSubImage), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_clear_texture")
    void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void* data) @system @nogc nothrow;

    /++
     + glClearTexSubImage: man4/glClearTexSubImage.xml
     + 
     + $(D_INLINECODE glClearTexSubImage) fills all or part of an image contained in a texture with an application supplied value. $(D_INLINECODE texture) must be the name of an existing texture. Further, $(D_INLINECODE texture) may not be the name of a buffer texture, nor may its internal format be compressed. Arguments $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), and $(D_INLINECODE zoffset) specify the lower left texel coordinates of a width-wide by height-high by depth-deep rectangular subregion of the texel array. For one-dimensional array textures, $(D_INLINECODE yoffset) is interpreted as the first layer to be cleared and $(D_INLINECODE height) is the number of layers to clear. For two-dimensional array textures, $(D_INLINECODE zoffset) is interpreted as the first layer to be cleared and $(D_INLINECODE depth) is the number of layers to clear. Cube map textures are treated as an array of six slices in the z-dimension, where the value of $(D_INLINECODE zoffset) is interpreted as specifying the cube map face for the corresponding layer and $(D_INLINECODE depth) is the number of faces to clear. For cube map array textures, $(D_INLINECODE zoffset) is the first layer-face to clear, and $(D_INLINECODE depth) is the number of layer-faces to clear. Each layer-face is translated into an array layer and a cube map face as described in the OpenGL Specification. Negative values of $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), and $(D_INLINECODE zoffset) correspond to the coordinates of border texels. Taking ws, hs, ds, wb, hb, and db to be the specified $(D_INLINECODE width), $(D_INLINECODE height), $(D_INLINECODE depth), and the border width, border height, and border depth of the texel array and taking x, y, z, w, h, and d to be the $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset), $(D_INLINECODE width), $(D_INLINECODE height), and $(D_INLINECODE depth) argument values, any of the following relationships generates a $(D_INLINECODE GL_INVALID_OPERATION) error: $(OL $(LI x &lt; w b) $(LI x + w &gt; w s - w b) $(LI y &lt; - h b) $(LI y + h &gt; h s - h b) $(LI z &lt; - d b) $(LI z + d &gt; d s - d b)) For texture types that do not have certain dimensions, this command treats those dimensions as having a size of 1. For example, to clear a portion of a two-dimensional texture, use $(D_INLINECODE zoffset) equal to zero and $(D_INLINECODE depth) equal to one. $(D_INLINECODE format) and $(D_INLINECODE type) specify the format and type of the source data and are interpreted as they are for $(D_INLINECODE glTexImage3D). Textures with a base internal format of $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_STENCIL_INDEX), or $(D_INLINECODE GL_DEPTH_STENCIL) require depth component, stencil, or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures with integer internal formats require integer data. $(D_INLINECODE data) is a pointer to an array of between one and four components of texel data that will be used as the source for the constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was specified when the level was defined by any of the $(D_INLINECODE glTexImage*), $(D_INLINECODE glTexStorage*) or $(D_INLINECODE glCopyTexImage*) commands), and then used to fill the specified range of the destination texture level. If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), then the pointer is ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are cleared to the value specified by data.
     + 
     + $(D_INLINECODE glClearTexSubImage) is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     texture = The name of an existing texture object containing the image to be cleared.
     +     level   = The level of $(D_INLINECODE texture) containing the region to be cleared.
     +     xoffset = The coordinate of the left edge of the region to be cleared.
     +     yoffset = The coordinate of the lower edge of the region to be cleared.
     +     zoffset = The coordinate of the front of the region to be cleared.
     +     width   = The width of the region to be cleared.
     +     height  = The height of the region to be cleared.
     +     depth   = The depth of the region to be cleared.
     +     format  = The format of the data whose address in memory is given by $(D_INLINECODE data).
     +     type    = The type of the data whose address in memory is given by $(D_INLINECODE data).
     +     data    = The address in memory of the data to be used to clear the specified region.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearTexImage), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_clear_texture")
    void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* data) @system @nogc nothrow;

    /++
     + glClientWaitSync: man4/glClientWaitSync.xml
     + 
     + $(D_INLINECODE glClientWaitSync) causes the client to block and wait for the sync object specified by $(D_INLINECODE sync) to become signaled. If $(D_INLINECODE sync) is signaled when $(D_INLINECODE glClientWaitSync) is called, $(D_INLINECODE glClientWaitSync) returns immediately, otherwise it will block and wait for up to $(D_INLINECODE timeout) nanoseconds for $(D_INLINECODE sync) to become signaled. The return value is one of four status values: $(OL $(LI $(D_INLINECODE GL_ALREADY_SIGNALED) indicates that $(D_INLINECODE sync) was signaled at the time that $(D_INLINECODE glClientWaitSync) was called.) $(LI $(D_INLINECODE GL_TIMEOUT_EXPIRED) indicates that at least $(D_INLINECODE timeout) nanoseconds passed and $(D_INLINECODE sync) did not become signaled.) $(LI $(D_INLINECODE GL_CONDITION_SATISFIED) indicates that $(D_INLINECODE sync) was signaled before the timeout expired.) $(LI $(D_INLINECODE GL_WAIT_FAILED) indicates that an error occurred. Additionally, an OpenGL error will be generated.))
     + 
     + $(D_INLINECODE glClientWaitSync) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     sync    = The sync object whose status to wait on.
     +     flags   = A bitfield controlling the command flushing behavior. $(D_INLINECODE flags) may be $(D_INLINECODE GL_SYNC_FLUSH_COMMANDS_BIT).
     +     timeout = The timeout, specified in nanoseconds, for which the implementation should wait for $(D_INLINECODE sync) to become signaled.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glIsSync) $(D_INLINECODE glWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;

    /++
     + glClipControl: man4/glClipControl.xml
     + 
     + $(D_INLINECODE glClipControl) controls the clipping volume behavior and the clip coordinate to window coordinate transformation behavior. The view volume is defined by $$z_{min} \leq z_c \leq w_c$$ where $z_{min} = -w_c$ when $(D_INLINECODE depth) is $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE), and $z_{min} = 0$ when $(D_INLINECODE depth) is $(D_INLINECODE GL_ZERO_TO_ONE). The normalized device coordinate $y_d$ is given by $$y_d = { { f \times y_c } \over w_c }$$ where $f = 1$ when $(D_INLINECODE origin) is $(D_INLINECODE GL_LOWER_LEFT), and $f = -1$ when $(D_INLINECODE origin) is $(D_INLINECODE GL_UPPER_LEFT). The window coordinate $z_w$ is given by $$z_w = s \times z_d + b$$ where $s = { { f - n } \over 2 }$ and $b = { {n + f} \over 2 }$ when $(D_INLINECODE depth) is $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE), and $s = f - n$ and $b = n$ when $(D_INLINECODE depth) is $(D_INLINECODE GL_ZERO_TO_ONE). $n$ and $f$ are the near and far depth range values set with $(D_INLINECODE glDepthRange). Finally, the polygon area computation defined by $(D_INLINECODE gl_FrontFacing) to determine if a polygon is front- or back-facing has its sign negated when $(D_INLINECODE origin) is $(D_INLINECODE GL_UPPER_LEFT).
     + 
     + The default GL clip volume definition is for a $(D_INLINECODE origin) of $(D_INLINECODE GL_LOWER_LEFT) and a $(D_INLINECODE depth) of $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE). An $(D_INLINECODE origin) of $(D_INLINECODE GL_UPPER_LEFT) and a $(D_INLINECODE depth) of $(D_INLINECODE GL_ZERO_TO_ONE) corresponds to Direct3D's clip volume definition. An $(D_INLINECODE origin) of $(D_INLINECODE GL_UPPER_LEFT) and a $(D_INLINECODE depth) of $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE) corresponds to the upper-left origin of the window coordinate system of Microsoft Windows and the X Window System. There is extensive discussion of the uses and further consequences of the different clip volume settings in the $(D_INLINECODE GL_ARB_clip_control) extension specification in the OpenGL Registry at URL $(LINK2 http://www.opengl.org/registry/, http://www.opengl.org/registry/).
     + 
     + Params:
     +     origin = Specifies the clip control origin. Must be one of $(D_INLINECODE GL_LOWER_LEFT) or $(D_INLINECODE GL_UPPER_LEFT).
     +     depth  = Specifies the clip control depth mode. Must be one of $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE) or $(D_INLINECODE GL_ZERO_TO_ONE).
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE gl_ClipDistance), $(D_INLINECODE gl_CullDistance), $(D_INLINECODE gl_FrontFacing), $(D_INLINECODE glDepthRange).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_clip_control")
    void glClipControl(GLenum origin, GLenum depth) @system @nogc nothrow;

    /++
     + glColorMask: man4/glColorMask.xml
     + 
     + $(D_INLINECODE glColorMask) and $(D_INLINECODE glColorMaski) specify whether the individual color components in the frame buffer can or cannot be written. $(D_INLINECODE glColorMaski) sets the mask for a specific draw buffer, whereas $(D_INLINECODE glColorMask) sets the mask for all draw buffers. If $(D_INLINECODE red) is $(D_INLINECODE GL_FALSE), for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted. Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.
     + 
     + Params:
     +     buf = For $(D_INLINECODE glColorMaski), specifies the index of the draw buffer whose color mask to set.
     +     red = Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all $(D_INLINECODE GL_TRUE), indicating that the color components are written.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE glDepthMask), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) @system @nogc nothrow;

    /++
     + glCompileShader: man4/glCompileShader.xml
     + 
     + $(D_INLINECODE glCompileShader) compiles the source code strings that have been stored in the shader object specified by $(D_INLINECODE shader). The compilation status will be stored as part of the shader object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the shader was compiled without errors and is ready for use, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetShader) with arguments $(D_INLINECODE shader) and $(D_INLINECODE GL_COMPILE_STATUS). Compilation of a shader can fail for a number of reasons as specified by the OpenGL Shading Language Specification. Whether or not the compilation was successful, information about the compilation can be obtained from the shader object's information log by calling $(D_INLINECODE glGetShaderInfoLog).
     + 
     + Params:
     +     shader = Specifies the shader object to be compiled.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glCompileShader(GLuint shader) @system @nogc nothrow;

    /++
     + glCompressedTexImage1D: man4/glCompressedTexImage1D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexImage1D) loads a previously defined, and retrieved, compressed one-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D) (see $(D_INLINECODE glTexImage1D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_1D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be an extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage1D) using a generic compressed  texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ) the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage1D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for $(D_INLINECODE glTexImage1D). In the following description, denote by b s, b w, b h, and b d the values of pixel storage modes $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_SIZE), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_HEIGHT), and $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_DEPTH), respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels. By default the pixel storage modes $(D_INLINECODE GL_UNPACK_ROW_LENGTH), $(D_INLINECODE GL_UNPACK_SKIP_ROWS), $(D_INLINECODE GL_UNPACK_SKIP_PIXELS), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) and $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) are ignored for compressed images. To enable $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) and $(D_INLINECODE GL_UNPACK_ROW_LENGTH), b s and b w must both be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_ROWS) and $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), b h must be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_IMAGES), b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results. When selecting a sub-rectangle from a compressed image, $(OL $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) must be a multiple of b w)) $(D_INLINECODE imageSize) must be equal to: b s &times; width b w
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_1D) or $(D_INLINECODE GL_PROXY_TEXTURE_1D).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     width          = Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
     +     border         = This value must be 0.
     +     imageSize      = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data           = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + glCompressedTexImage2D: man4/glCompressedTexImage2D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexImage2D) loads a previously defined, and retrieved, compressed two-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D), or one of the cube map faces such as $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X). (see $(D_INLINECODE glTexImage2D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE data) is treated as an array of compressed 1D textures. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage2D) using a generic compressed texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ), the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage2D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for $(D_INLINECODE glTexImage2D). In the following description, denote by b s, b w, b h, and b d, the values of pixel storage modes $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_SIZE), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_HEIGHT), and $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_DEPTH), respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels. By default the pixel storage modes $(D_INLINECODE GL_UNPACK_ROW_LENGTH), $(D_INLINECODE GL_UNPACK_SKIP_ROWS), $(D_INLINECODE GL_UNPACK_SKIP_PIXELS), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) and $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) are ignored for compressed images. To enable $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) and $(D_INLINECODE GL_UNPACK_ROW_LENGTH), b s and b w must both be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_ROWS) and $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), b h must be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_IMAGES), b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results. When selecting a sub-rectangle from a compressed image: $(OL $(LI The value of $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) must be a multiple of b w;) $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_ROWS) must be a multiple of b w.)) $(D_INLINECODE imageSize) must be equal to: b s &times; width b w &times; height b h
     + 
     + The specific compressed internal formats $(D_INLINECODE GL_COMPRESSED_RGB8_ETC2), $(D_INLINECODE GL_COMPRESSED_SRGB8_ETC2), $(D_INLINECODE GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2), $(D_INLINECODE GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2), $(D_INLINECODE GL_COMPRESSED_RGBA8_ETC2_EAC), $(D_INLINECODE GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC), $(D_INLINECODE GL_COMPRESSED_R11_EAC), $(D_INLINECODE GL_COMPRESSED_SIGNED_R11_EAC), $(D_INLINECODE GL_COMPRESSED_RG11_EAC), and $(D_INLINECODE GL_COMPRESSED_SIGNED_RG11_EAC) are available only if the GL version is 4.3 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     width          = Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
     +     height         = Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
     +     border         = This value must be 0.
     +     imageSize      = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data           = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + glCompressedTexImage3D: man4/glCompressedTexImage3D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexImage3D) loads a previously defined, and retrieved, compressed three-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_3D) (see $(D_INLINECODE glTexImage3D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE data) is treated as an array of compressed 2D textures. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_3D) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage2D) using a generic compressed texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ), the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage3D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for $(D_INLINECODE glTexImage1D). In the following description, denote by b s, b w, b h, and b d the values of pixel storage modes $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_SIZE), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_HEIGHT), and $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_DEPTH), respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels. By default the pixel storage modes $(D_INLINECODE GL_UNPACK_ROW_LENGTH), $(D_INLINECODE GL_UNPACK_SKIP_ROWS), $(D_INLINECODE GL_UNPACK_SKIP_PIXELS), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) and $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) are ignored for compressed images. To enable $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) and $(D_INLINECODE GL_UNPACK_ROW_LENGTH), b s and b w must both be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_ROWS) and $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), b h must be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_IMAGES), b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results. When selecting a sub-rectangle from a compressed image: $(OL $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) must be a multiple of b w;) $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_ROWS) must be a multiple of b w;) $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) must be a multiple of b w.)) $(D_INLINECODE imageSize) must be equal to: b s &times; width b w &times; height b h &times; depth b d
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     width          = Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
     +     height         = Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
     +     depth          = Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
     +     border         = This value must be 0.
     +     imageSize      = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data           = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage1D: man4/glCompressedTexSubImage1D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexSubImage1D) and $(D_INLINECODE glCompressedTextureSubImage1D) redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive.  This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage1D) ), and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + Params:
     +     target    = Specifies the target, to which the texture is bound, for $(D_INLINECODE glCompressedTexSubImage1D) function. Must be $(D_INLINECODE GL_TEXTURE_1D).
     +     texture   = Specifies the texture object name for $(D_INLINECODE glCompressedTextureSubImage1D) function.
     +     level     = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset   = Specifies a texel offset in the x direction within the texture array.
     +     width     = Specifies the width of the texture subimage.
     +     format    = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     imageSize = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data      = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage2D: man4/glCompressedTexSubImage2D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexSubImage2D) and $(D_INLINECODE glCompressedTextureSubImage2D) redefine a contiguous subregion of an existing two-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, and the y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage2D) ) and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + Params:
     +     target    = Specifies the target to which the texture is bound for $(D_INLINECODE glCompressedTexSubImage2D) function. Must be $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z).
     +     texture   = Specifies the texture object name for $(D_INLINECODE glCompressedTextureSubImage2D) function.
     +     level     = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset   = Specifies a texel offset in the x direction within the texture array.
     +     yoffset   = Specifies a texel offset in the y direction within the texture array.
     +     width     = Specifies the width of the texture subimage.
     +     height    = Specifies the height of the texture subimage.
     +     format    = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     imageSize = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data      = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage3D: man4/glCompressedTexSubImage3D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexSubImage3D) and $(D_INLINECODE glCompressedTextureSubImage3D) redefine a contiguous subregion of an existing three-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, and the y indices $(D_INLINECODE yoffset) and yoffset + height - 1, and the z indices $(D_INLINECODE zoffset) and zoffset + depth - 1, inclusive.  This region may not include any texels outside the range of the texture array as it was originally specified.  It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage3D) ) and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + Params:
     +     target    = Specifies the target to which the texture is bound for $(D_INLINECODE glCompressedTexSubImage3D) function. Must be $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY).
     +     texture   = Specifies the texture object name for $(D_INLINECODE glCompressedTextureSubImage3D) function.
     +     level     = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset   = Specifies a texel offset in the x direction within the texture array.
     +     yoffset   = Specifies a texel offset in the y direction within the texture array.
     +     width     = Specifies the width of the texture subimage.
     +     height    = Specifies the height of the texture subimage.
     +     depth     = Specifies the depth of the texture subimage.
     +     format    = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     imageSize = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data      = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;

    /++
     + glCopyBufferSubData: man4/glCopyBufferSubData.xml
     + 
     + $(D_INLINECODE glCopyBufferSubData) and $(D_INLINECODE glCopyNamedBufferSubData) copy part of the data store attached to a source buffer object to the data store attached to a destination buffer object. The number of basic machine units indicated by $(D_INLINECODE size) is copied from the source at offset $(D_INLINECODE readOffset) to the destination at $(D_INLINECODE writeOffset). $(D_INLINECODE readOffset), $(D_INLINECODE writeOffset) and $(D_INLINECODE size) are in terms of basic machine units. For $(D_INLINECODE glCopyBufferSubData), $(D_INLINECODE readTarget) and $(D_INLINECODE writeTarget) specify the targets to which the source and destination buffer objects are bound, and must each be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage Any of these targets may be used, but the targets $(D_INLINECODE GL_COPY_READ_BUFFER) and $(D_INLINECODE GL_COPY_WRITE_BUFFER) are provided specifically to allow copies between buffers without disturbing other GL state. $(D_INLINECODE readOffset), $(D_INLINECODE writeOffset) and $(D_INLINECODE size) must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of the buffer bound to $(D_INLINECODE writeTarget). If the source and destination are the same buffer object, then the source and destination ranges must not overlap.
     + 
     + The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     readTarget  = Specifies the target to which the source buffer object is bound for $(D_INLINECODE glCopyBufferSubData)
     +     writeTarget = Specifies the target to which the destination buffer object is bound for $(D_INLINECODE glCopyBufferSubData).
     +     readBuffer  = Specifies the name of the source buffer object for $(D_INLINECODE glCopyNamedBufferSubData).
     +     writeBuffer = Specifies the name of the destination buffer object for $(D_INLINECODE glCopyNamedBufferSubData).
     +     readOffset  = Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.
     +     writeOffset = Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written.
     +     size        = Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glGetBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glMapBufferRange)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_copy_buffer")
    void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizei size) @system @nogc nothrow;

    /++
     + glCopyImageSubData: man4/glCopyImageSubData.xml
     + 
     + $(D_INLINECODE glCopyImageSubData) may be used to copy data from one image (i.e. texture or renderbuffer) to another. $(D_INLINECODE glCopyImageSubData) does not perform general-purpose conversions such as scaling, resizing, blending, color-space, or format conversions. It should be considered to operate in a manner similar to a CPU memcpy. CopyImageSubData can copy between images with different internal formats, provided the formats are compatible. $(D_INLINECODE glCopyImageSubData) also allows copying between certain types of compressed and uncompressed internal formats. This copy does not perform on-the-fly compression or decompression. When copying from an uncompressed internal format to a compressed internal format, each texel of uncompressed data becomes a single block of compressed data. When copying from a compressed internal format to an uncompressed internal format, a block of compressed data becomes a single texel of uncompressed data. The texel size of the uncompressed format must be the same size the block size of the compressed formats. Thus it is permitted to copy between a 128-bit uncompressed format and a compressed format which uses 8-bit 4x4 blocks, or between a 64-bit uncompressed format and a compressed format which uses 4-bit 4x4 blocks. The source object is identified by $(D_INLINECODE srcName) and $(D_INLINECODE srcTarget) and the destination object is identified by $(D_INLINECODE dstName) and $(D_INLINECODE dstTarget). The interpretation of the name depends on the value of the corresponding $(D_INLINECODE target) parameter. If $(D_INLINECODE target) is $(D_INLINECODE GL_RENDERBUFFER), the name is interpreted as the name of a renderbuffer object.  If the target parameter is a texture target, the name is interpreted as a texture object.  All non-proxy texture targets are accepted, with the exception of $(D_INLINECODE GL_TEXTURE_BUFFER) and the cubemap face selectors. $(D_INLINECODE srcLevel) and $(D_INLINECODE dstLevel) identify the source and destination level of detail.  For textures, this must be a valid level of detail in the texture object.  For renderbuffers, this value must be zero. $(D_INLINECODE srcX), $(D_INLINECODE srcY), and $(D_INLINECODE srcZ) specify the lower left texel coordinates of a $(D_INLINECODE srcWidth) -wide by $(D_INLINECODE srcHeight) -high by $(D_INLINECODE srcDepth) -deep rectangular subregion of the source texel array. Similarly, $(D_INLINECODE dstX), $(D_INLINECODE dstY) and $(D_INLINECODE dstZ) specify the coordinates of a subregion of the destination texel array.  The source and destination subregions must be contained entirely within the specified level of the corresponding image objects. The dimensions are always specified in texels, even for compressed texture formats. However, it should be noted that if only one of the source and destination textures is compressed then the number of texels touched in the compressed image will be a factor of the block size larger than in the uncompressed image. Slices of a $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) $(D_INLINECODE GL_TEXTURE_3D) and faces of $(D_INLINECODE GL_TEXTURE_CUBE_MAP) are all compatible provided they share a compatible internal format, and multiple slices or faces may be copied between these objects with a single call by specifying the starting slice with $(D_INLINECODE srcZ) and $(D_INLINECODE dstZ), and the number of slices to be copied with $(D_INLINECODE srcDepth).  Cubemap textures always have six faces which are selected by a zero-based face index. For the purposes of CopyImageSubData, two internal formats are considered compatible if any of the following conditions are met: $(OL $(LI the formats are the same,) $(LI the formats are considered compatible according to the compatibility rules used for texture views as defined in section 3.9.X. In particular, if both internal formats are listed in the same entry of Table 3.X.2, they are considered compatible, or) $(LI one format is compressed and the other is uncompressed and Table 4.X.1 lists the two formats in the same row.)) If the formats are not compatible, an INVALID_OPERATION error is generated.<h3> Sized Internal Formats</h3> $(B Texel / Block Size) $(B Uncompressed Internal Format) $(B Compressed Internal Format(s)) 64-bit $(D_INLINECODE GL_RGBA32UI), $(D_INLINECODE GL_RGBA32I), $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_COMPRESSED_RGBA_S3TC_DXT3_EXT), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT), $(D_INLINECODE GL_COMPRESSED_RGBA_S3TC_DXT5_EXT), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT), $(D_INLINECODE GL_COMPRESSED_RG_RGTC2), $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2), $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM), $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT), $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) 128-bit $(D_INLINECODE GL_RGBA16UI), $(D_INLINECODE GL_RGBA16I), $(D_INLINECODE GL_RGBA16F), $(D_INLINECODE GL_RG32F), $(D_INLINECODE GL_RG32UI), $(D_INLINECODE GL_RG32I), $(D_INLINECODE GL_RGBA16), $(D_INLINECODE GL_RGBA16_SNORM) $(D_INLINECODE GL_COMPRESSED_RGB_S3TC_DXT1_EXT), $(D_INLINECODE GL_COMPRESSED_SRGB_S3TC_DXT1_EXT), $(D_INLINECODE GL_COMPRESSED_RGBA_S3TC_DXT1_EXT), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT), $(D_INLINECODE GL_COMPRESSED_RED_RGTC1), $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1)
     + 
     + Params:
     +     srcName   = The name of a texture or renderbuffer object from which to copy.
     +     srcTarget = The target representing the namespace of the source name $(D_INLINECODE srcName).
     +     srcLevel  = The mipmap level to read from the source.
     +     srcX      = The X coordinate of the left edge of the souce region to copy.
     +     srcY      = The Y coordinate of the top edge of the souce region to copy.
     +     srcZ      = The Z coordinate of the near edge of the souce region to copy.
     +     dstName   = The name of a texture or renderbuffer object to which to copy.
     +     dstTarget = The target representing the namespace of the destination name $(D_INLINECODE dstName).
     +     dstX      = The X coordinate of the left edge of the destination region.
     +     dstY      = The Y coordinate of the top edge of the destination region.
     +     dstZ      = The Z coordinate of the near edge of the destination region.
     +     srcWidth  = The width of the region to be copied.
     +     srcHeight = The height of the region to be copied.
     +     srcDepth  = The depth of the region to be copied.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDispatchComputeIndirect).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_copy_image")
    void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;

    /++
     + glCopyTexImage1D: man4/glCopyTexImage1D.xml
     + 
     + $(D_INLINECODE glCopyTexImage1D) defines a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). The screen-aligned pixel row with left corner at x y and with a length of width defines the texture array at the mipmap level specified by $(D_INLINECODE level). $(D_INLINECODE internalformat) specifies the internal format of the texture array. The pixels in the row are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. Pixel ordering is such that lower x screen coordinates correspond to lower texture coordinates. If any of the pixels within the specified row of the current $(D_INLINECODE GL_READ_BUFFER) are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined. $(D_INLINECODE glCopyTexImage1D) defines a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). When $(D_INLINECODE internalformat) is one of the sRGB  types, the GL does not automatically convert the source pixels to the sRGB color space.  In this case, the $(D_INLINECODE glPixelMap) function can be used to accomplish the conversion.
     + 
     + 1, 2, 3, and 4 are not accepted values for $(D_INLINECODE internalformat). An image with 0 width indicates a null texture.
     +  $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_1D).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the internal format of the texture. Must be one of the following symbolic constants: $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), $(D_INLINECODE GL_COMPRESSED_RGBA). $(D_INLINECODE GL_COMPRESSED_SRGB), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA). $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_COMPONENT16), $(D_INLINECODE GL_DEPTH_COMPONENT24), $(D_INLINECODE GL_DEPTH_COMPONENT32), $(D_INLINECODE GL_STENCIL_INDEX8), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_R3_G3_B2), $(D_INLINECODE GL_RGB4), $(D_INLINECODE GL_RGB5), $(D_INLINECODE GL_RGB8), $(D_INLINECODE GL_RGB10), $(D_INLINECODE GL_RGB12), $(D_INLINECODE GL_RGB16), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_RGBA2), $(D_INLINECODE GL_RGBA4), $(D_INLINECODE GL_RGB5_A1), $(D_INLINECODE GL_RGBA8), $(D_INLINECODE GL_RGB10_A2), $(D_INLINECODE GL_RGBA12), $(D_INLINECODE GL_RGBA16), $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), or $(D_INLINECODE GL_SRGB8_ALPHA8).
     +     x              = Specify the window coordinates of the left corner of the row of pixels to be copied.
     +     width          = Specifies the width of the texture image. The height of the texture image is 1.
     +     border         = Must be 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;

    /++
     + glCopyTexImage2D: man4/glCopyTexImage2D.xml
     + 
     + $(D_INLINECODE glCopyTexImage2D) defines a two-dimensional texture image, or cube-map texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). The screen-aligned pixel rectangle with lower left corner at ( $(D_INLINECODE x), $(D_INLINECODE y) ) and with a width of width and a height of height defines the texture array at the mipmap level specified by $(D_INLINECODE level). $(D_INLINECODE internalformat) specifies the internal format of the texture array. The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined. When $(D_INLINECODE internalformat) is one of the sRGB  types, the GL does not automatically convert the source pixels to the sRGB color space.  In this case, the $(D_INLINECODE glPixelMap) function can be used to accomplish the conversion.
     + 
     + 1, 2, 3, and 4 are not accepted values for $(D_INLINECODE internalformat). An image with height or width of 0 indicates a null texture.
     +  $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the internal format of the texture. Must be one of the following symbolic constants: $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), $(D_INLINECODE GL_COMPRESSED_RGBA). $(D_INLINECODE GL_COMPRESSED_SRGB), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA). $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_COMPONENT16), $(D_INLINECODE GL_DEPTH_COMPONENT24), $(D_INLINECODE GL_DEPTH_COMPONENT32), $(D_INLINECODE GL_STENCIL_INDEX8), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_R3_G3_B2), $(D_INLINECODE GL_RGB4), $(D_INLINECODE GL_RGB5), $(D_INLINECODE GL_RGB8), $(D_INLINECODE GL_RGB10), $(D_INLINECODE GL_RGB12), $(D_INLINECODE GL_RGB16), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_RGBA2), $(D_INLINECODE GL_RGBA4), $(D_INLINECODE GL_RGB5_A1), $(D_INLINECODE GL_RGBA8), $(D_INLINECODE GL_RGB10_A2), $(D_INLINECODE GL_RGBA12), $(D_INLINECODE GL_RGBA16), $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), or $(D_INLINECODE GL_SRGB8_ALPHA8).
     +     x              = Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
     +     width          = Specifies the width of the texture image.
     +     height         = Specifies the height of the texture image.
     +     border         = Must be 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;

    /++
     + glCopyTexSubImage1D: man4/glCopyTexSubImage1D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage1D) and $(D_INLINECODE glCopyTextureSubImage1D) replace a portion of a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage1D) ). For $(D_INLINECODE glCopyTexSubImage1D), the texture object that is bound to $(D_INLINECODE target) will be used for the process. For $(D_INLINECODE glCopyTextureSubImage1D), $(D_INLINECODE texture) tells which texture object should be used for the purpose of the call. The screen-aligned pixel row with left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ), and with length $(D_INLINECODE width) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive. The destination in the texture array may not include any texels outside the texture array as it was originally specified. The pixels in the row are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels within the specified row of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the or parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + The $(D_INLINECODE glPixelStore) mode affects texture images.
     + 
     + Params:
     +     target  = Specifies the target to which the texture object is bound for $(D_INLINECODE glCopyTexSubImage1D) function. Must be $(D_INLINECODE GL_TEXTURE_1D).
     +     texture = Specifies the texture object name for $(D_INLINECODE glCopyTextureSubImage1D) function.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies the texel offset within the texture array.
     +     x       = Specify the window coordinates of the left corner of the row of pixels to be copied.
     +     width   = Specifies the width of the texture subimage.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + glCopyTexSubImage2D: man4/glCopyTexSubImage2D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage2D) and $(D_INLINECODE glCopyTextureSubImage2D) replace a rectangular portion of a two-dimensional texture image, cube-map texture image, rectangular image, or a linear portion of a number of slices of a one-dimensional array texture with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage2D) ). The screen-aligned pixel rectangle with lower left corner at x y and with width $(D_INLINECODE width) and height $(D_INLINECODE height) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) through yoffset + height - 1, inclusive, at the mipmap level specified by $(D_INLINECODE level). The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range $[0,1]$ and then converted to the texture's internal format for storage in the texel array. The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D_ARRAY) then the y coordinate and height are treated as the start slice and number of slices to modify. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the,, or, parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images.
     + 
     + Params:
     +     target  = Specifies the target to which the texture object is bound for $(D_INLINECODE glCopyTexSubImage2D) function. Must be $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_TEXTURE_RECTANGLE).
     +     texture = Specifies the texture object name for $(D_INLINECODE glCopyTextureSubImage2D) function.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     x       = Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glCopyTexSubImage3D: man4/glCopyTexSubImage3D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage3D) and $(D_INLINECODE glCopyTextureSubImage3D) functions replace a rectangular portion of a three-dimensional or two-dimensional array texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage3D) ). The screen-aligned pixel rectangle with lower left corner at ( $(D_INLINECODE x), $(D_INLINECODE y) ) and with width $(D_INLINECODE width) and height $(D_INLINECODE height) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) through yoffset + height - 1, inclusive, at z index $(D_INLINECODE zoffset) and at the mipmap level specified by $(D_INLINECODE level). The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the,,,, or parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images.
     + 
     + Params:
     +     target  = Specifies the target to which the texture object is bound for $(D_INLINECODE glCopyTexSubImage3D) function. Must be $(D_INLINECODE GL_TEXTURE_3D) or $(D_INLINECODE GL_TEXTURE_2D_ARRAY).
     +     texture = Specifies the texture object name for $(D_INLINECODE glCopyTextureSubImage3D) function.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     zoffset = Specifies a texel offset in the z direction within the texture array.
     +     x       = Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glCreateBuffers: man4/glCreateBuffers.xml
     + 
     + $(D_INLINECODE glCreateBuffers) returns $(D_INLINECODE n) previously unused buffer names in $(D_INLINECODE buffers), each representing a new buffer object initialized as if it had been bound to an unspecified target.
     + 
     + Params:
     +     n       = Specifies the number of buffer objects to create.
     +     buffers = Specifies an array in which names of the new buffer objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGet), $(D_INLINECODE glIsBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateBuffers(GLsizei n, GLuint* buffers) @system @nogc nothrow;

    /++
     + glCreateFramebuffers: man4/glCreateFramebuffers.xml
     + 
     + $(D_INLINECODE glCreateFramebuffers) returns $(D_INLINECODE n) previously unused framebuffer names in $(D_INLINECODE framebuffers), each representing a new framebuffer object initialized to the default state.
     + 
     + Params:
     +     n            = Number of framebuffer objects to create.
     +     framebuffers = Specifies an array in which names of the new framebuffer objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), $(D_INLINECODE glFramebufferTexture3D), $(D_INLINECODE glFramebufferTextureLayer), $(D_INLINECODE glDeleteFramebuffers), $(D_INLINECODE glIsFramebuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateFramebuffers(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glCreateProgram: man4/glCreateProgram.xml
     + 
     + $(D_INLINECODE glCreateProgram) creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When no longer needed as part of a program object, shader objects can be detached. One or more executables are created in a program object by successfully attaching shader objects to it with $(D_INLINECODE glAttachShader), successfully compiling the shader objects with $(D_INLINECODE glCompileShader), and successfully linking the program object with $(D_INLINECODE glLinkProgram). These executables are made part of current state when $(D_INLINECODE glUseProgram) is called. Program objects can be deleted by calling $(D_INLINECODE glDeleteProgram). The memory associated with the program object will be deleted when it is no longer part of current rendering state for any context.
     + 
     + Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLuint glCreateProgram() @system @nogc nothrow;

    /++
     + glCreateProgramPipelines: man4/glCreateProgramPipelines.xml
     + 
     + $(D_INLINECODE glCreateProgramPipelines) returns $(D_INLINECODE n) previously unused program pipeline names in $(D_INLINECODE pipelines), each representing a new program pipeline object initialized to the default state.
     + 
     + Params:
     +     n         = Number of program pipeline objects to create.
     +     pipelines = Specifies an array in which names of the new program pipeline objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glCreateShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCompileShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glIsProgramPipeline)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateProgramPipelines(GLsizei n, GLuint* pipelines) @system @nogc nothrow;

    /++
     + glCreateQueries: man4/glCreateQueries.xml
     + 
     + $(D_INLINECODE glCreateQueries) returns $(D_INLINECODE n) previously unused query object names in $(D_INLINECODE ids), each representing a new query object with the specified $(D_INLINECODE target). $(D_INLINECODE target) may be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE), $(D_INLINECODE GL_TIME_ELAPSED), $(D_INLINECODE GL_TIMESTAMP), $(D_INLINECODE GL_PRIMITIVES_GENERATED) or $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN).
     + 
     + Params:
     +     target = Specifies the target of each created query object.
     +     n      = Number of query objects to create.
     +     ids    = Specifies an array in which names of the new query objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glBeginQueryIndexed), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateQueries(GLenum target, GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glCreateRenderbuffers: man4/glCreateRenderbuffers.xml
     + 
     + $(D_INLINECODE glCreateRenderbuffers) returns $(D_INLINECODE n) previously unused renderbuffer object names in $(D_INLINECODE renderbuffers), each representing a new renderbuffer object initialized to the default state.
     + 
     + Params:
     +     n             = Number of renderbuffer objects to create.
     +     renderbuffers = Specifies an array in which names of the new renderbuffer objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glIsRenderbuffer), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glRenderbufferStorageMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateRenderbuffers(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;

    /++
     + glCreateSamplers: man4/glCreateSamplers.xml
     + 
     + $(D_INLINECODE glCreateSamplers) returns $(D_INLINECODE n) previously unused sampler names in $(D_INLINECODE samplers), each representing a new sampler object initialized to the default state.
     + 
     + Params:
     +     n        = Number of sampler objects to create.
     +     samplers = Specifies an array in which names of the new sampler objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindSampler), $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenSamplers), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetSamplerParameter), $(D_INLINECODE glSamplerParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateSamplers(GLsizei n, GLuint* samplers) @system @nogc nothrow;

    /++
     + glCreateShader: man4/glCreateShader.xml
     + 
     + $(D_INLINECODE glCreateShader) creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object is used to maintain the source code strings that define a shader. $(D_INLINECODE shaderType) indicates the type of shader to be created. Five types of shader are supported. A shader of type $(D_INLINECODE GL_COMPUTE_SHADER) is a shader that is intended to run on the programmable compute processor. A shader of type $(D_INLINECODE GL_VERTEX_SHADER) is a shader that is intended to run on the programmable vertex processor. A shader of type $(D_INLINECODE GL_TESS_CONTROL_SHADER) is a shader that is intended to run on the programmable tessellation processor in the control stage. A shader of type $(D_INLINECODE GL_TESS_EVALUATION_SHADER) is a shader that is intended to run on the programmable tessellation processor in the evaluation stage. A shader of type $(D_INLINECODE GL_GEOMETRY_SHADER) is a shader that is intended to run on the programmable geometry processor. A shader of type $(D_INLINECODE GL_FRAGMENT_SHADER) is a shader that is intended to run on the programmable fragment processor. When created, a shader object's $(D_INLINECODE GL_SHADER_TYPE) parameter is set to either $(D_INLINECODE GL_COMPUTE_SHADER), $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER), depending on the value of $(D_INLINECODE shaderType).
     + 
     + Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads. $(D_INLINECODE GL_COMPUTE_SHADER) is available only if the GL version is 4.3 or higher.
     + 
     + Params:
     +     shaderType = Specifies the type of shader to be created. Must be one of $(D_INLINECODE GL_COMPUTE_SHADER), $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER), or $(D_INLINECODE GL_FRAGMENT_SHADER).
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCompileShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLuint glCreateShader(GLenum shaderType) @system @nogc nothrow;

    /++
     + glCreateShaderProgram: man4/glCreateShaderProgram.xml
     + 
     + $(D_INLINECODE glCreateShaderProgram) creates a program object containing compiled and linked shaders for a single stage specified by $(D_INLINECODE type). $(D_INLINECODE strings) refers to an array of $(D_INLINECODE count) strings from which to create the shader executables. $(D_INLINECODE glCreateShaderProgram) is equivalent (assuming no errors are generated) to:
     + 
     + ---
     + const GLuint shader = glCreateShader(type);
     + if (shader) {
     +     glShaderSource(shader, count, strings, NULL);
     +     glCompileShader(shader);
     +     const GLuint program = glCreateProgram();
     +     if (program) {
     +         GLint compiled = GL_FALSE;
     +         glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);
     +         glProgramParameteri(program, GL_PROGRAM_SEPARABLE, GL_TRUE);
     +         if (compiled) {
     +             glAttachShader(program, shader);
     +             glLinkProgram(program);
     +             glDetachShader(program, shader);
     +         }
     +         /* append-shader-info-log-to-program-info-log */
     +     }
     +     glDeleteShader(shader);
     +     return program;
     + } else {
     +     return 0;
     + }
     + ---
     +  The program object created by $(D_INLINECODE glCreateShaderProgram) has its $(D_INLINECODE GL_PROGRAM_SEPARABLE) status set to $(D_INLINECODE GL_TRUE).
     + 
     + Params:
     +     type    = Specifies the type of shader to create.
     +     count   = Specifies the number of source code strings in the array $(D_INLINECODE strings).
     +     strings = Specifies the address of an array of pointers to source code strings from which to create the program object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCompileShader), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char** strings) @system @nogc nothrow;

    /++
     + glCreateTextures: man4/glCreateTextures.xml
     + 
     + $(D_INLINECODE glCreateTextures) returns $(D_INLINECODE n) previously unused texture names in $(D_INLINECODE textures), each representing a new texture object of the dimensionality and type specified by $(D_INLINECODE target) and initialized to the default values for that texture type. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
     + 
     + Params:
     +     target   = Specifies the effective texture target of each created texture.
     +     n        = Number of texture objects to create.
     +     textures = Specifies an array in which names of the new texture objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateTextures(GLenum target, GLsizei n, GLuint* textures) @system @nogc nothrow;

    /++
     + glCreateTransformFeedbacks: man4/glCreateTransformFeedbacks.xml
     + 
     + $(D_INLINECODE glCreateTransformFeedbacks) returns $(D_INLINECODE n) previously unused transform feedback object names in $(D_INLINECODE ids), each representing a new transform feedback object initialized to the default state.
     + 
     + Params:
     +     n   = Number of transform feedback objects to create.
     +     ids = Specifies an array in which names of the new transform feedback objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glDeleteTransformFeedbacks), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glIsTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glResumeTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateTransformFeedbacks(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glCreateVertexArrays: man4/glCreateVertexArrays.xml
     + 
     + $(D_INLINECODE glCreateVertexArrays) returns $(D_INLINECODE n) previously unused vertex array object names in $(D_INLINECODE arrays), each representing a new vertex array object initialized to the default state.
     + 
     + Params:
     +     n      = Number of vertex array objects to create.
     +     arrays = Specifies an array in which names of the new vertex array objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexArray), $(D_INLINECODE glDeleteVertexArrays) $(D_INLINECODE glEnableVertexAttribArray) $(D_INLINECODE glGenVertexArrays), $(D_INLINECODE glIsVertexArray), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateVertexArrays(GLsizei n, GLuint* arrays) @system @nogc nothrow;

    /++
     + glCullFace: man4/glCullFace.xml
     + 
     + $(D_INLINECODE glCullFace) specifies whether front- or back-facing facets are culled (as specified by ) when facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling, call the $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) commands with the argument $(D_INLINECODE GL_CULL_FACE). Facets include triangles, quadrilaterals, polygons, and rectangles. $(D_INLINECODE glFrontFace) specifies which of the clockwise and counterclockwise facets are front-facing and back-facing. See $(D_INLINECODE glFrontFace).
     + 
     + If $(D_INLINECODE mode) is $(D_INLINECODE GL_FRONT_AND_BACK), no facets are drawn, but other primitives such as points and lines are drawn.
     + 
     + Params:
     +     mode = Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), and $(D_INLINECODE GL_FRONT_AND_BACK) are accepted. The initial value is $(D_INLINECODE GL_BACK).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glFrontFace)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glCullFace(GLenum mode) @system @nogc nothrow;

    /++
     + glDebugMessageCallback: man4/glDebugMessageCallback.xml
     + 
     + $(D_INLINECODE glDebugMessageCallback) sets the current debug output callback function to the function whose address is given in $(D_INLINECODE callback). The callback function should have the following prototype (in C), or be otherwise compatible with such a prototype:
     + 
     + ---
     + typedef void (APIENTRY *DEBUGPROC)(GLenum source,
     +         GLenum type,
     +         GLuint id,
     +         GLenum severity,
     +         GLsizei length,
     +         const GLchar *message,
     +         void *userParam);
     + ---
     +  This function is defined to have the same calling convention as the GL API functions. In most cases this is defined as $(D_INLINECODE APIENTRY), although it will vary depending on platform, language and compiler. Each time a debug message is generated the debug callback function will be invoked with $(D_INLINECODE source), $(D_INLINECODE type), $(D_INLINECODE id), and $(D_INLINECODE severity) associated with the message, and $(D_INLINECODE length) set to the length of debug message whose character string is in the array pointed to by $(D_INLINECODE message) $(D_INLINECODE userParam) will be set to the value passed in the $(D_INLINECODE userParam) parameter to the most recent call to $(D_INLINECODE glDebugMessageCallback).
     + 
     + When the GL is in use remotely, the server may not be able to call functions in the client's address space. In such cases, the callback function may not be invoked and the user should retrieve debug messages from the context's debug message log by calling $(D_INLINECODE glGetDebugMessageLog).
     + 
     + Params:
     +     callback  = The address of a callback function that will be called when a debug message is generated.
     +     userParam = A user supplied pointer that will be passed on each invocation of $(D_INLINECODE callback).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageControl), $(D_INLINECODE glDebugMessageInsert), $(D_INLINECODE glGetDebugMessageLog).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageCallback(GLDEBUGPROC callback, void* userParam) @system @nogc nothrow;

    /++
     + glDebugMessageControl: man4/glDebugMessageControl.xml
     + 
     + $(D_INLINECODE glDebugMessageControl) controls the reporting of debug messages generated by a debug context. The parameters $(D_INLINECODE source), $(D_INLINECODE type) and $(D_INLINECODE severity) form a filter to select messages from the pool of potential messages generated by the GL. $(D_INLINECODE source) may be $(D_INLINECODE GL_DEBUG_SOURCE_API), $(D_INLINECODE GL_DEBUG_SOURCE_WINDOW_SYSTEM_), $(D_INLINECODE GL_DEBUG_SOURCE_SHADER_COMPILER), $(D_INLINECODE GL_DEBUG_SOURCE_THIRD_PARTY), $(D_INLINECODE GL_DEBUG_SOURCE_APPLICATION), $(D_INLINECODE GL_DEBUG_SOURCE_OTHER) to select messages generated by usage of the GL API, the window system, the shader compiler, third party tools or libraries, explicitly by the application or by some other source, respectively. It may also take the value $(D_INLINECODE GL_DONT_CARE). If $(D_INLINECODE source) is not $(D_INLINECODE GL_DONT_CARE) then only messages whose source matches $(D_INLINECODE source) will be referenced. $(D_INLINECODE type) may be one of $(D_INLINECODE GL_DEBUG_TYPE_ERROR), $(D_INLINECODE GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR), $(D_INLINECODE GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR), $(D_INLINECODE GL_DEBUG_TYPE_PORTABILITY), $(D_INLINECODE GL_DEBUG_TYPE_PERFORMANCE), $(D_INLINECODE GL_DEBUG_TYPE_MARKER), $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP), or $(D_INLINECODE GL_DEBUG_TYPE_OTHER) to indicate the type of messages describing GL errors, attempted use of deprecated features, triggering of undefined behavior, portability issues, performance notifications, markers, group push and pop events, and other types of messages, respectively. It may also take the value $(D_INLINECODE GL_DONT_CARE). If $(D_INLINECODE type) is not $(D_INLINECODE GL_DONT_CARE) then only messages whose type matches $(D_INLINECODE type) will be referenced. $(D_INLINECODE severity) may be one of $(D_INLINECODE GL_DEBUG_SEVERITY_LOW), $(D_INLINECODE GL_DEBUG_SEVERITY_MEDIUM), or $(D_INLINECODE GL_DEBUG_SEVERITY_HIGH) to select messages of low, medium or high severity messages or to $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION) for notifications. It may also take the value $(D_INLINECODE GL_DONT_CARE). If $(D_INLINECODE severity) is not $(D_INLINECODE GL_DONT_CARE) then only messages whose severity matches $(D_INLINECODE severity) will be referenced. $(D_INLINECODE ids) contains a list of $(D_INLINECODE count) message identifiers to select specific messages from the pool of available messages. If $(D_INLINECODE count) is zero then the value of $(D_INLINECODE ids) is ignored. Otherwise, only messages appearing in this list are selected. In this case, $(D_INLINECODE source) and $(D_INLINECODE type) may not be $(D_INLINECODE GL_DONT_CARE) and $(D_INLINECODE severity) must be $(D_INLINECODE GL_DONT_CARE). If $(D_INLINECODE enabled) is $(D_INLINECODE GL_TRUE) then messages that match the filter formed by $(D_INLINECODE source), $(D_INLINECODE type), $(D_INLINECODE severity) and $(D_INLINECODE ids) are enabled. Otherwise, those messages are disabled.
     + 
     + Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug context may produce no messages at all. $(D_INLINECODE GL_DEBUG_TYPE_MARKER), $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP), and $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION) are available only if the GL version is 4.3 or higher.
     + 
     + Params:
     +     source   = The source of debug messages to enable or disable.
     +     type     = The type of debug messages to enable or disable.
     +     severity = The severity of debug messages to enable or disable.
     +     count    = The length of the array $(D_INLINECODE ids).
     +     ids      = The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
     +     enabled  = A Boolean flag determining whether the selected messages should be enabled or disabled.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageInsert), $(D_INLINECODE glDebugMessageCallback), $(D_INLINECODE glGetDebugMessageLog).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled) @system @nogc nothrow;

    /++
     + glDebugMessageInsert: man4/glDebugMessageInsert.xml
     + 
     + $(D_INLINECODE glDebugMessageInsert) inserts a user-supplied message into the debug output queue. $(D_INLINECODE source) specifies the source that will be used to classify the message and must be $(D_INLINECODE GL_DEBUG_SOURCE_APPLICATION) or $(D_INLINECODE GL_DEBUG_SOURCE_THIRD_PARTY). All other sources are reserved for use by the GL implementation. $(D_INLINECODE type) indicates the type of the message to be inserted and may be one of $(D_INLINECODE GL_DEBUG_TYPE_ERROR), $(D_INLINECODE GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR), $(D_INLINECODE GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR), $(D_INLINECODE GL_DEBUG_TYPE_PORTABILITY), $(D_INLINECODE GL_DEBUG_TYPE_PERFORMANCE), $(D_INLINECODE GL_DEBUG_TYPE_MARKER), $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP), or $(D_INLINECODE GL_DEBUG_TYPE_OTHER). $(D_INLINECODE severity) indicates the severity of the message and may be $(D_INLINECODE GL_DEBUG_SEVERITY_LOW), $(D_INLINECODE GL_DEBUG_SEVERITY_MEDIUM), $(D_INLINECODE GL_DEBUG_SEVERITY_HIGH) or $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION). $(D_INLINECODE id) is available for application defined use and may be any value. This value will be recorded and used to identify the message. $(D_INLINECODE length) contains a count of the characters in the character array whose address is given in $(D_INLINECODE message). If $(D_INLINECODE length) is negative then $(D_INLINECODE message) is treated as a null-terminated string. The length of the message, whether specified explicitly or implicitly, must be less than or equal to the implementation defined constant $(D_INLINECODE GL_MAX_DEBUG_MESSAGE_LENGTH).
     + 
     + $(D_INLINECODE GL_DEBUG_TYPE_MARKER), $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP), and $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION) are available only if the GL version is 4.3 or higher.
     + 
     + Params:
     +     source   = The source of the debug message to insert.
     +     type     = The type of the debug message insert.
     +     id       = The user-supplied identifier of the message to insert.
     +     severity = The severity of the debug messages to insert.
     +     length   = The length string contained in the character array whose address is given by $(D_INLINECODE message).
     +     message  = The address of a character array containing the message to insert.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageControl), $(D_INLINECODE glDebugMessageCallback), $(D_INLINECODE glGetDebugMessageLog).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char* message) @system @nogc nothrow;

    /++
     + glDeleteBuffers: man4/glDeleteBuffers.xml
     + 
     + $(D_INLINECODE glDeleteBuffers) deletes $(D_INLINECODE n) buffer objects named by the elements of the array $(D_INLINECODE buffers). After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by $(D_INLINECODE glGenBuffers) ). If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any buffer object). $(D_INLINECODE glDeleteBuffers) silently ignores 0's and names that do not correspond to existing buffer objects.
     + 
     + Params:
     +     n       = Specifies the number of buffer objects to be deleted.
     +     buffers = Specifies an array of buffer objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glGenBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glDeleteBuffers(GLsizei n, const GLuint* buffers) @system @nogc nothrow;

    /++
     + glDeleteFramebuffers: man4/glDeleteFramebuffers.xml
     + 
     + $(D_INLINECODE glDeleteFramebuffers) deletes the $(D_INLINECODE n) framebuffer objects whose names are stored in the array addressed by $(D_INLINECODE framebuffers). The name zero is reserved by the GL and is silently ignored, should it occur in $(D_INLINECODE framebuffers), as are other unused names. Once a framebuffer object is deleted, its name is again unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets $(D_INLINECODE GL_DRAW_FRAMEBUFFER) or $(D_INLINECODE GL_READ_FRAMEBUFFER) is deleted, it is as though $(D_INLINECODE glBindFramebuffer) had been executed with the corresponding $(D_INLINECODE target) and $(D_INLINECODE framebuffer) zero.
     + 
     + Params:
     +     n            = Specifies the number of framebuffer objects to be deleted.
     +     framebuffers = A pointer to an array containing $(D_INLINECODE n) framebuffer objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glCheckFramebufferStatus)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glDeleteFramebuffers(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;

    /++
     + glDeleteProgram: man4/glDeleteProgram.xml
     + 
     + $(D_INLINECODE glDeleteProgram) frees the memory and invalidates the name associated with the program object specified by $(D_INLINECODE program.) This command effectively undoes the effects of a call to $(D_INLINECODE glCreateProgram). If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to $(D_INLINECODE glDeleteShader). A value of 0 for $(D_INLINECODE program) will be silently ignored. To determine whether a program object has been flagged for deletion, call $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_DELETE_STATUS).
     + 
     + Params:
     +     program = Specifies the program object to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDeleteProgram(GLuint program) @system @nogc nothrow;

    /++
     + glDeleteProgramPipelines: man4/glDeleteProgramPipelines.xml
     + 
     + $(D_INLINECODE glDeleteProgramPipelines) deletes the $(D_INLINECODE n) program pipeline objects whose names are stored in the array $(D_INLINECODE pipelines). Unused names in $(D_INLINECODE pipelines) are ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to zero and no program pipeline object becomes current.
     + 
     + Params:
     +     n         = Specifies the number of program pipeline objects to delete.
     +     pipelines = Specifies an array of names of program pipeline objects to delete.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glIsProgramPipeline), $(D_INLINECODE glUseProgramStages), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glDeleteProgramPipelines(GLsizei n, const GLuint* pipelines) @system @nogc nothrow;

    /++
     + glDeleteQueries: man4/glDeleteQueries.xml
     + 
     + $(D_INLINECODE glDeleteQueries) deletes $(D_INLINECODE n) query objects named by the elements of the array $(D_INLINECODE ids). After a query object is deleted, it has no contents, and its name is free for reuse (for example by $(D_INLINECODE glGenQueries) ). $(D_INLINECODE glDeleteQueries) silently ignores 0's and names that do not correspond to existing query objects.
     + 
     + Params:
     +     n   = Specifies the number of query objects to be deleted.
     +     ids = Specifies an array of query objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGetQueryObject)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glDeleteQueries(GLsizei n, const GLuint* ids) @system @nogc nothrow;

    /++
     + glDeleteRenderbuffers: man4/glDeleteRenderbuffers.xml
     + 
     + $(D_INLINECODE glDeleteRenderbuffers) deletes the $(D_INLINECODE n) renderbuffer objects whose names are stored in the array addressed by $(D_INLINECODE renderbuffers). The name zero is reserved by the GL and is silently ignored, should it occur in $(D_INLINECODE renderbuffers), as are other unused names. Once a renderbuffer object is deleted, its name is again unused and it has no contents. If a renderbuffer that is currently bound to the target $(D_INLINECODE GL_RENDERBUFFER) is deleted, it is as though $(D_INLINECODE glBindRenderbuffer) had been executed with a $(D_INLINECODE target) of $(D_INLINECODE GL_RENDERBUFFER) and a $(D_INLINECODE name) of zero. If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if $(D_INLINECODE glFramebufferRenderbuffer) had been called, with a $(D_INLINECODE renderbuffer) of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words, this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer image is specifically detached from any non-bound framebuffers.
     + 
     + Params:
     +     n             = Specifies the number of renderbuffer objects to be deleted.
     +     renderbuffers = A pointer to an array containing $(D_INLINECODE n) renderbuffer objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glRenderbufferStorageMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glDeleteRenderbuffers(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;

    /++
     + glDeleteSamplers: man4/glDeleteSamplers.xml
     + 
     + $(D_INLINECODE glDeleteSamplers) deletes $(D_INLINECODE n) sampler objects named by the elements of the array $(D_INLINECODE samplers). After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as though $(D_INLINECODE glBindSampler) is called with unit set to the unit the sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.
     + 
     + $(D_INLINECODE glDeleteSamplers) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     n        = Specifies the number of sampler objects to be deleted.
     +     samplers = Specifies an array of sampler objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glBindSampler), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glIsSampler)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glDeleteSamplers(GLsizei n, const GLuint* samplers) @system @nogc nothrow;

    /++
     + glDeleteShader: man4/glDeleteShader.xml
     + 
     + $(D_INLINECODE glDeleteShader) frees the memory and invalidates the name associated with the shader object specified by $(D_INLINECODE shader). This command effectively undoes the effects of a call to $(D_INLINECODE glCreateShader). If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted). A value of 0 for $(D_INLINECODE shader) will be silently ignored. To determine whether an object has been flagged for deletion, call $(D_INLINECODE glGetShader) with arguments $(D_INLINECODE shader) and $(D_INLINECODE GL_DELETE_STATUS).
     + 
     + Params:
     +     shader = Specifies the shader object to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDeleteShader(GLuint shader) @system @nogc nothrow;

    /++
     + glDeleteSync: man4/glDeleteSync.xml
     + 
     + $(D_INLINECODE glDeleteSync) deletes the sync object specified by $(D_INLINECODE sync). If the fence command corresponding to the specified sync object has completed, or if no $(D_INLINECODE glWaitSync) or $(D_INLINECODE glClientWaitSync) commands are blocking on $(D_INLINECODE sync), the object is deleted immediately. Otherwise, $(D_INLINECODE sync) is flagged for deletion and will be deleted when it is no longer associated with any fence command and is no longer blocking any $(D_INLINECODE glWaitSync) or $(D_INLINECODE glClientWaitSync) command. In either case, after $(D_INLINECODE glDeleteSync) returns, the name $(D_INLINECODE sync) is invalid and can no longer be used to refer to the sync object. $(D_INLINECODE glDeleteSync) will silently ignore a $(D_INLINECODE sync) value of zero.
     + 
     + $(D_INLINECODE glSync) is only supported if the GL version is 3.2 or greater, or if the $(D_INLINECODE ARB_sync) extension is supported.
     + 
     + Params:
     +     sync = The sync object to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    void glDeleteSync(GLsync sync) @system @nogc nothrow;

    /++
     + glDeleteTextures: man4/glDeleteTextures.xml
     + 
     + $(D_INLINECODE glDeleteTextures) deletes $(D_INLINECODE n) textures named by the elements of the array $(D_INLINECODE textures). After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by $(D_INLINECODE glGenTextures) ). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture). $(D_INLINECODE glDeleteTextures) silently ignores 0's and names that do not correspond to existing textures.
     + 
     + Params:
     +     n        = Specifies the number of textures to be deleted.
     +     textures = Specifies an array of textures to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glDeleteTextures(GLsizei n, const GLuint* textures) @system @nogc nothrow;

    /++
     + glDeleteTransformFeedbacks: man4/glDeleteTransformFeedbacks.xml
     + 
     + $(D_INLINECODE glDeleteTransformFeedbacks) deletes the $(D_INLINECODE n) transform feedback objects whose names are stored in the array $(D_INLINECODE ids). Unused names in $(D_INLINECODE ids) are ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but the underlying object is not deleted until it is no longer active.
     + 
     + Params:
     +     n   = Specifies the number of transform feedback objects to delete.
     +     ids = Specifies an array of names of transform feedback objects to delete.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glIsTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glResumeTransformFeedback), $(D_INLINECODE glEndTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glDeleteTransformFeedbacks(GLsizei n, const GLuint* ids) @system @nogc nothrow;

    /++
     + glDeleteVertexArrays: man4/glDeleteVertexArrays.xml
     + 
     + $(D_INLINECODE glDeleteVertexArrays) deletes $(D_INLINECODE n) vertex array objects whose names are stored in the array addressed by $(D_INLINECODE arrays). Once a vertex array object is deleted it has no contents and its name is again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero and the default vertex array becomes current. Unused names in $(D_INLINECODE arrays) are silently ignored, as is the value zero.
     + 
     + Params:
     +     n      = Specifies the number of vertex array objects to be deleted.
     +     arrays = Specifies the address of an array containing the $(D_INLINECODE n) names of the objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenVertexArrays), $(D_INLINECODE glIsVertexArray), $(D_INLINECODE glBindVertexArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    void glDeleteVertexArrays(GLsizei n, const GLuint* arrays) @system @nogc nothrow;

    /++
     + glDepthFunc: man4/glDepthFunc.xml
     + 
     + $(D_INLINECODE glDepthFunc) specifies the function used to compare each incoming pixel depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) of $(D_INLINECODE GL_DEPTH_TEST).) $(D_INLINECODE func) specifies the conditions under which the pixel will be drawn. The comparison functions are as follows: The initial value of $(D_INLINECODE func) is $(D_INLINECODE GL_LESS). Initially, depth testing is disabled.  If depth testing is disabled or if no depth buffer exists, it is as if the depth test always passes.
     + 
     + Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to $(D_INLINECODE GL_ALWAYS).
     + 
     + Params:
     +     func = Specifies the depth comparison function. Symbolic constants $(D_INLINECODE GL_NEVER), $(D_INLINECODE GL_LESS), $(D_INLINECODE GL_EQUAL), $(D_INLINECODE GL_LEQUAL), $(D_INLINECODE GL_GREATER), $(D_INLINECODE GL_NOTEQUAL), $(D_INLINECODE GL_GEQUAL), and $(D_INLINECODE GL_ALWAYS) are accepted. The initial value is $(D_INLINECODE GL_LESS).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange), $(D_INLINECODE glEnable), $(D_INLINECODE glPolygonOffset)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDepthFunc(GLenum func) @system @nogc nothrow;

    /++
     + glDepthMask: man4/glDepthMask.xml
     + 
     + $(D_INLINECODE glDepthMask) specifies whether the depth buffer is enabled for writing. If $(D_INLINECODE flag) is $(D_INLINECODE GL_FALSE), depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
     + 
     + Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to $(D_INLINECODE GL_ALWAYS) (see $(D_INLINECODE glDepthFunc) ).
     + 
     + Params:
     +     flag = Specifies whether the depth buffer is enabled for writing. If $(D_INLINECODE flag) is $(D_INLINECODE GL_FALSE), depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDepthMask(GLboolean flag) @system @nogc nothrow;

    /++
     + glDepthRange: man4/glDepthRange.xml
     + 
     + After clipping and division by, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. $(D_INLINECODE glDepthRange) specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by $(D_INLINECODE glDepthRange) are both clamped to this range before they are accepted. The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
     + 
     + It is not necessary that $(D_INLINECODE nearVal) be less than $(D_INLINECODE farVal). Reverse mappings such as nearVal = 1, and farVal = 0 are acceptable. The type of the $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) parameters was changed from GLclampf to GLfloat for $(D_INLINECODE glDepthRangef) and from GLclampd to GLdouble for $(D_INLINECODE glDepthRange). This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     nearVal = Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
     +     farVal  = Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glViewport), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDepthRange(GLdouble nearVal, GLdouble farVal) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glDepthRangef(GLfloat nearVal, GLfloat farVal) @system @nogc nothrow;

    /++
     + glDepthRangeArray: man4/glDepthRangeArray.xml
     + 
     + After clipping and division by, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). $(D_INLINECODE glDepthRangeArray) specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates for each viewport in the range [ $(D_INLINECODE first), $(D_INLINECODE first) + $(D_INLINECODE count) ). Thus, the values accepted by $(D_INLINECODE glDepthRangeArray) are both clamped to this range before they are accepted. The $(D_INLINECODE first) parameter specifies the index of the first viewport whose depth range to modify and must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS). $(D_INLINECODE count) specifies the number of viewports whose depth range to modify. $(D_INLINECODE first) + $(D_INLINECODE count) must be less than or equal to the value of $(D_INLINECODE GL_MAX_VIEWPORTS). $(D_INLINECODE v) specifies the address of an array of pairs of double precision floating point values representing the near and far values of the depth range for each viewport, in that order. The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
     + 
     + It is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as near = 1, and far = 0 are acceptable. The type of the $(D_INLINECODE v) parameter was changed from GLclampd to GLdouble. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     first = Specifies the index of the first viewport whose depth range to update.
     +     count = Specifies the number of viewports whose depth range to update.
     +     v     = Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glDepthRangeIndexed), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glViewportArray), $(D_INLINECODE glViewport), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble* v) @system @nogc nothrow;

    /++
     + glDepthRangeIndexed: man4/glDepthRangeIndexed.xml
     + 
     + After clipping and division by, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). $(D_INLINECODE glDepthRangeIndexed) specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates for a specified viewport. Thus, the values accepted by $(D_INLINECODE glDepthRangeIndexed) are both clamped to this range before they are accepted. The $(D_INLINECODE index) parameter specifies the index of first viewport whose depth range to modify and must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS). $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) specify near and far values of the depth range for the specified viewport, respectively. The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
     + 
     + It is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as nearVal = 1, and farVal = 0 are acceptable. The type of the $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) parameters was changed from GLclampd to GLdouble. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     index   = Specifies the index of the viewport whose depth range to update.
     +     nearVal = Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
     +     farVal  = Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glDepthRangeArray), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glViewportArray), $(D_INLINECODE glViewport), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal) @system @nogc nothrow;

    /++
     + glDetachShader: man4/glDetachShader.xml
     + 
     + $(D_INLINECODE glDetachShader) detaches the shader object specified by $(D_INLINECODE shader) from the program object specified by $(D_INLINECODE program). This command can be used to undo the effect of the command $(D_INLINECODE glAttachShader). If $(D_INLINECODE shader) has already been flagged for deletion by a call to $(D_INLINECODE glDeleteShader) and it is not attached to any other program object, it will be deleted after it has been detached.
     + 
     + Params:
     +     program = Specifies the program object from which to detach the shader object.
     +     shader  = Specifies the shader object to be detached.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDetachShader(GLuint program, GLuint shader) @system @nogc nothrow;

    /++
     + glDisable: man4/glEnable.xml
     + 
     + $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) enable and disable various capabilities. Use $(D_INLINECODE glIsEnabled) or $(D_INLINECODE glGet) to determine the current setting of any capability. The initial value for each capability with the exception of $(D_INLINECODE GL_DITHER) and $(D_INLINECODE GL_MULTISAMPLE) is $(D_INLINECODE GL_FALSE). The initial value for $(D_INLINECODE GL_DITHER) and $(D_INLINECODE GL_MULTISAMPLE) is $(D_INLINECODE GL_TRUE). Both $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) take a single argument, $(D_INLINECODE cap), which can assume one of the following values: Some of the GL's capabilities are indexed. $(D_INLINECODE glEnablei) and $(D_INLINECODE glDisablei) enable and disable indexed capabilities.
     + 
     + $(D_INLINECODE GL_PRIMITIVE_RESTART) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_TEXTURE_CUBE_MAP_SEAMLESS) is available only if the GL version is 3.2 or greater. $(D_INLINECODE GL_PRIMITIVE_RESTART_FIXED_INDEX) is available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_DEBUG_OUTPUT) and $(D_INLINECODE GL_DEBUG_OUTPUT_SYNCHRONOUS) are available only if the GL version is 4.3 or greater. Any token accepted by $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable) is also accepted by $(D_INLINECODE glEnablei) and $(D_INLINECODE glDisablei), but if the capability is not indexed, the maximum value that $(D_INLINECODE index) may take is zero. In general, passing an indexed capability to $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable) will enable or disable that capability for all indices, resepectively.
     + 
     + Params:
     +     cap   = Specifies a symbolic constant indicating a GL capability.
     +     index = Specifies the index of the switch to disable (for $(D_INLINECODE glEnablei) and $(D_INLINECODE glDisablei) only).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glCullFace), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glGet), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glLineWidth), $(D_INLINECODE glLogicOp), $(D_INLINECODE glPointSize), $(D_INLINECODE glPolygonMode), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glSampleCoverage), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilOp), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEnable(GLenum cap) @system @nogc nothrow;

    /++
     + glDisableVertexArrayAttrib: man4/glEnableVertexAttribArray.xml
     + 
     + $(D_INLINECODE glEnableVertexAttribArray) and $(D_INLINECODE glEnableVertexArrayAttrib) enable the generic vertex attribute array specified by $(D_INLINECODE index). $(D_INLINECODE glEnableVertexAttribArray) uses currently bound vertex array object for the operation, whereas $(D_INLINECODE glEnableVertexArrayAttrib) updates state of the vertex array object with ID $(D_INLINECODE vaobj). $(D_INLINECODE glDisableVertexAttribArray) and $(D_INLINECODE glDisableVertexArrayAttrib) disable the generic vertex attribute array specified by $(D_INLINECODE index). $(D_INLINECODE glDisableVertexAttribArray) uses currently bound vertex array object for the operation, whereas $(D_INLINECODE glDisableVertexArrayAttrib) updates state of the vertex array object with ID $(D_INLINECODE vaobj). By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glMultiDrawArrays).
     + 
     + Params:
     +     vaobj = Specifies the name of the vertex array object for $(D_INLINECODE glDisableVertexArrayAttrib) and $(D_INLINECODE glEnableVertexArrayAttrib) functions.
     +     index = Specifies the index of the generic vertex attribute to be enabled or disabled.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glEnableVertexAttribArray(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDisableVertexAttribArray(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index) @system @nogc nothrow;

    /++
     + glDispatchCompute: man4/glDispatchCompute.xml
     + 
     + $(D_INLINECODE glDispatchCompute) launches one or more compute work groups. Each work group is processed by the active program object for the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are executed completely independently and in unspecified order. $(D_INLINECODE num_groups_x), $(D_INLINECODE num_groups_y) and $(D_INLINECODE num_groups_z) specify the number of local work groups that will be dispatched in the X, Y and Z dimensions, respectively.
     + 
     + Params:
     +     num_groups_x = The number of work groups to be launched in the X dimension.
     +     num_groups_y = The number of work groups to be launched in the Y dimension.
     +     num_groups_z = The number of work groups to be launched in the Z dimension.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDispatchComputeIndirect).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_compute_shader")
    void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) @system @nogc nothrow;

    /++
     + glDispatchComputeIndirect: man4/glDispatchComputeIndirect.xml
     + 
     + $(D_INLINECODE glDispatchComputeIndirect) launches one or more compute work groups using parameters stored in the buffer object currently bound to the $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) target. Each work group is processed by the active program object for the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are executed completely independently and in unspecified order. $(D_INLINECODE indirect) contains the offset into the data store of the buffer object bound to the $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) target at which the parameters are stored. The parameters addressed by $(D_INLINECODE indirect) are packed a structure, which takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  num_groups_x;
     +     uint  num_groups_y;
     +     uint  num_groups_z;
     + } DispatchIndirectCommand;
     + ---
     +  A call to $(D_INLINECODE glDispatchComputeIndirect) is equivalent, assuming no errors are generated, to:
     + 
     + ---
     + cmd = (const DispatchIndirectCommand  *)indirect;
     + glDispatchComputeIndirect(cmd-&gt;num_groups_x, cmd-&gt;num_groups_y, cmd-&gt;num_groups_z);
     + ---
     +  Unlike $(D_INLINECODE glDispatchCompute), no error is generated if any of the $(D_INLINECODE num_groups_x), $(D_INLINECODE num_groups_y) or $(D_INLINECODE num_groups_z) members of the $(D_INLINECODE DispatchIndirectCommand) is larger than the value of $(D_INLINECODE GL_MAX_COMPUTE_WORK_GROUP_COUNT) for the corresponding dimension. In such circumstances, behavior is undefined and may lead to application termination.
     + 
     + Params:
     +     indirect = The offset into the buffer object currently bound to the $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) buffer target at which the dispatch parameters are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDispatchCompute).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_compute_shader")
    void glDispatchComputeIndirect(GLintptr indirect) @system @nogc nothrow;

    /++
     + glDrawArrays: man4/glDrawArrays.xml
     + 
     + $(D_INLINECODE glDrawArrays) specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glDrawArrays). When $(D_INLINECODE glDrawArrays) is called, it uses $(D_INLINECODE count) sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element $(D_INLINECODE first). $(D_INLINECODE mode) specifies what kind of primitives are constructed and how the array elements construct those primitives. Vertex attributes that are modified by $(D_INLINECODE glDrawArrays) have an unspecified value after $(D_INLINECODE glDrawArrays) returns. Attributes that aren't modified remain well defined.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode  = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     first = Specifies the starting index in the enabled arrays.
     +     count = Specifies the number of indices to be rendered.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements),
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glDrawArrays(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;

    /++
     + glDrawArraysIndirect: man4/glDrawArraysIndirect.xml
     + 
     + $(D_INLINECODE glDrawArraysIndirect) specifies multiple geometric primitives with very few subroutine calls. $(D_INLINECODE glDrawArraysIndirect) behaves similarly to $(D_INLINECODE glDrawArraysInstancedBaseInstance), execept that the parameters to $(D_INLINECODE glDrawArraysInstancedBaseInstance) are stored in memory at the address given by $(D_INLINECODE indirect). The parameters addressed by $(D_INLINECODE indirect) are packed into a structure that takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  count;
     +     uint  primCount;
     +     uint  first;
     +     uint  baseInstance;
     + } DrawArraysIndirectCommand;
     + 
     + const DrawArraysIndirectCommand *cmd = (const DrawArraysIndirectCommand *)indirect;
     + glDrawArraysInstancedBaseInstance(mode, cmd-&gt;first, cmd-&gt;count, cmd-&gt;primCount, cmd-&gt;baseInstance);
     + ---
     +  If a buffer is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) binding at the time of a call to $(D_INLINECODE glDrawArraysIndirect), $(D_INLINECODE indirect) is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory. In contrast to $(D_INLINECODE glDrawArraysInstancedBaseInstance), the $(D_INLINECODE first) member of the parameter structure is unsigned, and out-of-range indices do not generate an error. Vertex attributes that are modified by $(D_INLINECODE glDrawArraysIndirect) have an unspecified value after $(D_INLINECODE glDrawArraysIndirect) returns. Attributes that aren't modified remain well defined.
     + 
     + The $(D_INLINECODE baseInstance) member of the $(D_INLINECODE DrawArraysIndirectCommand) structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
     + 
     + Params:
     +     mode     = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     indirect = Specifies the address of a structure containing the draw parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements),
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_draw_indirect")
    void glDrawArraysIndirect(GLenum mode, const void* indirect) @system @nogc nothrow;

    /++
     + glDrawArraysInstanced: man4/glDrawArraysInstanced.xml
     + 
     + $(D_INLINECODE glDrawArraysInstanced) behaves identically to $(D_INLINECODE glDrawArrays) except that $(D_INLINECODE primcount) instances of the range of elements are executed and the value of the internal counter $(D_INLINECODE instanceID) advances for each iteration. $(D_INLINECODE instanceID) is an internal 32-bit integer counter that may be read by a vertex shader as $(D_INLINECODE gl_InstanceID). $(D_INLINECODE glDrawArraysInstanced) has the same effect as:
     + 
     + ---
     + if ( mode or count is invalid )
     +     generate appropriate error
     + else {
     +     for (int i = 0; i &lt; primcount ; i++) {
     +         instanceID = i;
     +         glDrawArrays(mode, first, count);
     +     }
     +     instanceID = 0;
     + }
     + ---
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES) $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     first     = Specifies the starting index in the enabled arrays.
     +     count     = Specifies the number of indices to be rendered.
     +     primcount = Specifies the number of instances of the specified range of indices to be rendered.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElementsInstanced)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;

    /++
     + glDrawArraysInstancedBaseInstance: man4/glDrawArraysInstancedBaseInstance.xml
     + 
     + $(D_INLINECODE glDrawArraysInstancedBaseInstance) behaves identically to $(D_INLINECODE glDrawArrays) except that $(D_INLINECODE primcount) instances of the range of elements are executed and the value of the internal counter $(D_INLINECODE instanceID) advances for each iteration. $(D_INLINECODE instanceID) is an internal 32-bit integer counter that may be read by a vertex shader as $(D_INLINECODE gl_InstanceID). $(D_INLINECODE glDrawArraysInstancedBaseInstance) has the same effect as:
     + 
     + ---
     + if ( mode or count is invalid )
     +     generate appropriate error
     + else {
     +     for (int i = 0; i &lt; primcount ; i++) {
     +         instanceID = i;
     +         glDrawArrays(mode, first, count);
     +     }
     +     instanceID = 0;
     + }
     + ---
     +  Specific vertex attributes may be classified as through the use of $(D_INLINECODE glVertexAttribDivisor). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as: gl _ InstanceID divisor &plus; baseInstance. Note that $(D_INLINECODE baseinstance) does not affect the shader-visible value of $(D_INLINECODE gl_InstanceID).
     + 
     + Params:
     +     mode         = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES) $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     first        = Specifies the starting index in the enabled arrays.
     +     count        = Specifies the number of indices to be rendered.
     +     primcount    = Specifies the number of instances of the specified range of indices to be rendered.
     +     baseinstance = Specifies the base instance for use in fetching instanced vertex attributes.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElementsInstanced)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance) @system @nogc nothrow;

    /++
     + glDrawBuffer: man4/glDrawBuffer.xml
     + 
     + When colors are written to the frame buffer, they are written into the color buffers specified by $(D_INLINECODE glDrawBuffer). One of the following values can be used for default framebuffer: If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer. Monoscopic contexts include only buffers, and stereoscopic contexts include both and buffers. Likewise, single-buffered contexts include only buffers, and double-buffered contexts include both and buffers. The context is selected at GL initialization. For framebuffer objects, $(D_INLINECODE GL_COLOR_ATTACHMENT$m$) and $(D_INLINECODE GL_NONE) enums are accepted, where $(D_INLINECODE $m$) is a value between 0 and $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS). glDrawBuffer will set the draw buffer for fragment colors other than zero to $(D_INLINECODE GL_NONE).
     + 
     + Params:
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferDrawBuffer) function. Must be zero or the name of a framebuffer object.
     +     buf         = For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants $(D_INLINECODE GL_NONE), $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), $(D_INLINECODE GL_LEFT), $(D_INLINECODE GL_RIGHT), and $(D_INLINECODE GL_FRONT_AND_BACK) are accepted. The initial value is $(D_INLINECODE GL_FRONT) for single-buffered contexts, and $(D_INLINECODE GL_BACK) for double-buffered contexts. For framebuffer objects, $(D_INLINECODE GL_COLOR_ATTACHMENT$m$) and $(D_INLINECODE GL_NONE) enums are accepted, where $(D_INLINECODE $m$) is a value between 0 and $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glColorMask), $(D_INLINECODE glDrawBuffers), $(D_INLINECODE glLogicOp), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDrawBuffer(GLenum buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf) @system @nogc nothrow;

    /++
     + glDrawBuffers: man4/glDrawBuffers.xml
     + 
     + $(D_INLINECODE glDrawBuffers) and $(D_INLINECODE glNamedFramebufferDrawBuffers) define an array of buffers into which outputs from the fragment shader data will be written. If a fragment shader writes a value to one or more user defined output variables, then the value of each variable will be written into the buffer specified at a location within $(D_INLINECODE bufs) corresponding to the location assigned to that user defined output. The draw buffer used for user defined outputs assigned to locations greater than or equal to $(D_INLINECODE n) is implicitly set to $(D_INLINECODE GL_NONE) and any data written to such an output is discarded. For $(D_INLINECODE glDrawBuffers), the framebuffer object that is bound to the $(D_INLINECODE GL_DRAW_FRAMEBUFFER) binding will be used. For $(D_INLINECODE glNamedFramebufferDrawBuffers), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, then the default framebuffer is affected. The symbolic constants contained in $(D_INLINECODE bufs) may be any of the following: Except for $(D_INLINECODE GL_NONE), the preceding symbolic constants may not appear more than once in $(D_INLINECODE bufs). The maximum number of draw buffers supported is implementation dependent and can be queried by calling $(D_INLINECODE glGet) with the argument $(D_INLINECODE GL_MAX_DRAW_BUFFERS).
     + 
     + The symbolic constants $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), $(D_INLINECODE GL_LEFT), $(D_INLINECODE GL_RIGHT), and $(D_INLINECODE GL_FRONT_AND_BACK) are not allowed in the $(D_INLINECODE bufs) array since they may refer to multiple buffers. If a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader execution are undefined. For each fragment generated in this situation, a different value may be written into each of the buffers specified by $(D_INLINECODE bufs).
     + 
     + Params:
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferDrawBuffers).
     +     n           = Specifies the number of buffers in $(D_INLINECODE bufs).
     +     bufs        = Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glColorMask), $(D_INLINECODE glDrawBuffers), $(D_INLINECODE glLogicOp), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDrawBuffers(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum* bufs) @system @nogc nothrow;

    /++
     + glDrawElements: man4/glDrawElements.xml
     + 
     + $(D_INLINECODE glDrawElements) specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glDrawElements). When $(D_INLINECODE glDrawElements) is called, it uses $(D_INLINECODE count) sequential elements from an enabled array, starting at $(D_INLINECODE indices) to construct a sequence of geometric primitives. $(D_INLINECODE mode) specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used. Vertex attributes that are modified by $(D_INLINECODE glDrawElements) have an unspecified value after $(D_INLINECODE glDrawElements) returns.  Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode    = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count   = Specifies the number of elements to be rendered.
     +     type    = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices = Specifies a pointer to the location where the indices are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawRangeElements)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices) @system @nogc nothrow;

    /++
     + glDrawElementsBaseVertex: man4/glDrawElementsBaseVertex.xml
     + 
     + $(D_INLINECODE glDrawElementsBaseVertex) behaves identically to $(D_INLINECODE glDrawElements) except that the th element transferred by the corresponding draw call will be taken from element $(D_INLINECODE indices) [i] + $(D_INLINECODE basevertex) of each enabled array. If the resulting value is larger than the maximum value representable by $(D_INLINECODE type), it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
     + 
     + $(D_INLINECODE glDrawElementsBaseVertex) is only supported if the GL version is 3.2 or greater, or if the $(D_INLINECODE ARB_draw_elements_base_vertex) extension is supported.
     + 
     + Params:
     +     mode       = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count      = Specifies the number of elements to be rendered.
     +     type       = Specifies the type of the values in indices. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices    = Specifies a pointer to the location where the indices are stored.
     +     basevertex = Specifies a constant that should be added to each element of $(D_INLINECODE indices) when chosing elements from the enabled vertex arrays.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawRangeElementsBaseVertex), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLint basevertex) @system @nogc nothrow;

    /++
     + glDrawElementsIndirect: man4/glDrawElementsIndirect.xml
     + 
     + $(D_INLINECODE glDrawElementsIndirect) specifies multiple indexed geometric primitives with very few subroutine calls. $(D_INLINECODE glDrawElementsIndirect) behaves similarly to $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance), execpt that the parameters to $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance) are stored in memory at the address given by $(D_INLINECODE indirect). The parameters addressed by $(D_INLINECODE indirect) are packed into a structure that takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  count;
     +     uint  primCount;
     +     uint  firstIndex;
     +     uint  baseVertex;
     +     uint  baseInstance;
     + } DrawElementsIndirectCommand;
     + ---
     +  $(D_INLINECODE glDrawElementsIndirect) is equivalent to:
     + 
     + ---
     + void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect) {
     +     const DrawElementsIndirectCommand *cmd  = (const DrawElementsIndirectCommand *)indirect;
     +     glDrawElementsInstancedBaseVertexBaseInstance(mode,
     +                                                   cmd-&gt;count,
     +                                                   type,
     +                                                   cmd-&gt;firstIndex + size-of-type,
     +                                                   cmd-&gt;primCount,
     +                                                   cmd-&gt;baseVertex,
     +                                                   cmd-&gt;baseInstance);
     + }
     + ---
     +  If a buffer is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) binding at the time of a call to $(D_INLINECODE glDrawElementsIndirect), $(D_INLINECODE indirect) is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory. Note that indices stored in client memory are not supported. If no buffer is bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding, an error will be generated. The results of the operation are undefined if the $(D_INLINECODE reservedMustBeZero) member of the parameter structure is non-zero. However, no error is generated in this case. Vertex attributes that are modified by $(D_INLINECODE glDrawElementsIndirect) have an unspecified value after $(D_INLINECODE glDrawElementsIndirect) returns. Attributes that aren't modified remain well defined.
     + 
     + The $(D_INLINECODE baseInstance) member of the $(D_INLINECODE DrawElementsIndirectCommand) structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
     + 
     + Params:
     +     mode     = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     type     = Specifies the type of data in the buffer bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding.
     +     indirect = Specifies the address of a structure containing the draw parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawArraysIndirect), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements),
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_draw_indirect")
    void glDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect) @system @nogc nothrow;

    /++
     + glDrawElementsInstanced: man4/glDrawElementsInstanced.xml
     + 
     + $(D_INLINECODE glDrawElementsInstanced) behaves identically to $(D_INLINECODE glDrawElements) except that $(D_INLINECODE primcount) instances of the set of elements are executed and the value of the internal counter $(D_INLINECODE instanceID) advances for each iteration. $(D_INLINECODE instanceID) is an internal 32-bit integer counter that may be read by a vertex shader as $(D_INLINECODE gl_InstanceID). $(D_INLINECODE glDrawElementsInstanced) has the same effect as:
     + 
     + ---
     + if (mode, count, or type is invalid )
     +     generate appropriate error
     + else {
     +     for (int i = 0; i &lt; primcount ; i++) {
     +         instanceID = i;
     +         glDrawElements(mode, count, type, indices);
     +     }
     +     instanceID = 0;
     + }
     + ---
     + 
     + 
     + $(D_INLINECODE glDrawElementsInstanced) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count     = Specifies the number of elements to be rendered.
     +     type      = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices   = Specifies a pointer to the location where the indices are stored.
     +     primcount = Specifies the number of instances of the specified range of indices to be rendered.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawArraysInstanced)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;

    /++
     + glDrawElementsInstancedBaseInstance: man4/glDrawElementsInstancedBaseInstance.xml
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseInstance) behaves identically to $(D_INLINECODE glDrawElements) except that $(D_INLINECODE primcount) instances of the set of elements are executed and the value of the internal counter $(D_INLINECODE instanceID) advances for each iteration. $(D_INLINECODE instanceID) is an internal 32-bit integer counter that may be read by a vertex shader as $(D_INLINECODE gl_InstanceID). $(D_INLINECODE glDrawElementsInstancedBaseInstance) has the same effect as:
     + 
     + ---
     + if (mode, count, or type is invalid )
     +     generate appropriate error
     + else {
     +     for (int i = 0; i &lt; primcount ; i++) {
     +         instanceID = i;
     +         glDrawElements(mode, count, type, indices);
     +     }
     +     instanceID = 0;
     + }
     + ---
     +  Specific vertex attributes may be classified as through the use of $(D_INLINECODE glVertexAttribDivisor). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as gl _ InstanceID divisor &plus; baseInstance. Note that $(D_INLINECODE baseinstance) does not affect the shader-visible value of $(D_INLINECODE gl_InstanceID).
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseInstance) is available only if the GL version is 4.2 or greater. $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode         = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count        = Specifies the number of elements to be rendered.
     +     type         = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices      = Specifies a pointer to the location where the indices are stored.
     +     primcount    = Specifies the number of instances of the specified range of indices to be rendered.
     +     baseinstance = Specifies the base instance for use in fetching instanced vertex attributes.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawArraysInstanced)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLuint baseinstance) @system @nogc nothrow;

    /++
     + glDrawElementsInstancedBaseVertex: man4/glDrawElementsInstancedBaseVertex.xml
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseVertex) behaves identically to $(D_INLINECODE glDrawElementsInstanced) except that the th element transferred by the corresponding draw call will be taken from element $(D_INLINECODE indices) [i] + $(D_INLINECODE basevertex) of each enabled array. If the resulting value is larger than the maximum value representable by $(D_INLINECODE type), it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseVertex) is only supported if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode       = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count      = Specifies the number of elements to be rendered.
     +     type       = Specifies the type of the values in indices. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices    = Specifies a pointer to the location where the indices are stored.
     +     primcount  = Specifies the number of instances of the indexed geometry that should be drawn.
     +     basevertex = Specifies a constant that should be added to each element of $(D_INLINECODE indices) when chosing elements from the enabled vertex arrays.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawRangeElementsBaseVertex), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLsizei primcount, GLint basevertex) @system @nogc nothrow;

    /++
     + glDrawElementsInstancedBaseVertexBaseInstance: man4/glDrawElementsInstancedBaseVertexBaseInstance.xml
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance) behaves identically to $(D_INLINECODE glDrawElementsInstanced) except that the th element transferred by the corresponding draw call will be taken from element $(D_INLINECODE indices) [i] + $(D_INLINECODE basevertex) of each enabled array. If the resulting value is larger than the maximum value representable by $(D_INLINECODE type), it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative. The $(D_INLINECODE basevertex) has no effect on the shader-visible value of $(D_INLINECODE gl_VertexID). Specific vertex attributes may be classified as through the use of $(D_INLINECODE glVertexAttribDivisor). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as gl _ InstanceID divisor &plus; baseInstance. Note that $(D_INLINECODE baseinstance) does not affect the shader-visible value of $(D_INLINECODE gl_InstanceID).
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseVertex) is only supported if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode         = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count        = Specifies the number of elements to be rendered.
     +     type         = Specifies the type of the values in indices. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices      = Specifies a pointer to the location where the indices are stored.
     +     primcount    = Specifies the number of instances of the indexed geometry that should be drawn.
     +     basevertex   = Specifies a constant that should be added to each element of $(D_INLINECODE indices) when chosing elements from the enabled vertex arrays.
     +     baseinstance = Specifies the base instance for use in fetching instanced vertex attributes.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawRangeElementsBaseVertex), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLsizei primcount, GLint basevertex, GLuint baseinstance) @system @nogc nothrow;

    /++
     + glDrawRangeElements: man4/glDrawRangeElements.xml
     + 
     + $(D_INLINECODE glDrawRangeElements) is a restricted form of $(D_INLINECODE glDrawElements). $(D_INLINECODE mode), $(D_INLINECODE start), $(D_INLINECODE end), and $(D_INLINECODE count) match the corresponding arguments to $(D_INLINECODE glDrawElements), with the additional constraint that all values in the arrays $(D_INLINECODE count) must lie between $(D_INLINECODE start) and $(D_INLINECODE end), inclusive. Implementations denote recommended maximum amounts of vertex and index data, which may be queried by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_ELEMENTS_VERTICES) and $(D_INLINECODE GL_MAX_ELEMENTS_INDICES). If end - start + 1 is greater than the value of $(D_INLINECODE GL_MAX_ELEMENTS_VERTICES), or if $(D_INLINECODE count) is greater than the value of $(D_INLINECODE GL_MAX_ELEMENTS_INDICES), then the call may operate at reduced performance.  There is no requirement that all vertices in the range start end be referenced.  However, the implementation may partially process unused vertices, reducing performance from what could be achieved with an optimal index set. When $(D_INLINECODE glDrawRangeElements) is called, it uses $(D_INLINECODE count) sequential elements from an enabled array, starting at $(D_INLINECODE start) to construct a sequence of geometric primitives. $(D_INLINECODE mode) specifies what kind of primitives are constructed, and how the array elements construct these primitives. If more than one array is enabled, each is used. Vertex attributes that are modified by $(D_INLINECODE glDrawRangeElements) have an unspecified value after $(D_INLINECODE glDrawRangeElements) returns. Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode    = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     start   = Specifies the minimum array index contained in $(D_INLINECODE indices).
     +     end     = Specifies the maximum array index contained in $(D_INLINECODE indices).
     +     count   = Specifies the number of elements to be rendered.
     +     type    = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices = Specifies a pointer to the location where the indices are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawElementsBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices) @system @nogc nothrow;

    /++
     + glDrawRangeElementsBaseVertex: man4/glDrawRangeElementsBaseVertex.xml
     + 
     + $(D_INLINECODE glDrawRangeElementsBaseVertex) is a restricted form of $(D_INLINECODE glDrawElementsBaseVertex). $(D_INLINECODE mode), $(D_INLINECODE start), $(D_INLINECODE end), $(D_INLINECODE count) and $(D_INLINECODE basevertex) match the corresponding arguments to $(D_INLINECODE glDrawElementsBaseVertex), with the additional constraint that all values in the array $(D_INLINECODE indices) must lie between $(D_INLINECODE start) and $(D_INLINECODE end), inclusive, prior to adding $(D_INLINECODE basevertex). Index values lying outside the range [ $(D_INLINECODE start), $(D_INLINECODE end) ] are treated in the same way as $(D_INLINECODE glDrawElementsBaseVertex). The th element transferred by the corresponding draw call will be taken from element $(D_INLINECODE indices) [i] + $(D_INLINECODE basevertex) of each enabled array. If the resulting value is larger than the maximum value representable by $(D_INLINECODE type), it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
     + 
     + Params:
     +     mode       = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     start      = Specifies the minimum array index contained in $(D_INLINECODE indices).
     +     end        = Specifies the maximum array index contained in $(D_INLINECODE indices).
     +     count      = Specifies the number of elements to be rendered.
     +     type       = Specifies the type of the values in indices. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices    = Specifies a pointer to the location where the indices are stored.
     +     basevertex = Specifies a constant that should be added to each element of $(D_INLINECODE indices) when chosing elements from the enabled vertex arrays.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid* indices, GLint basevertex) @system @nogc nothrow;

    /++
     + glDrawTransformFeedback: man4/glDrawTransformFeedback.xml
     + 
     + $(D_INLINECODE glDrawTransformFeedback) draws primitives of a type specified by $(D_INLINECODE mode) using a count retrieved from the transform feedback specified by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedback) is equivalent to calling $(D_INLINECODE glDrawArrays) with $(D_INLINECODE mode) as specified, $(D_INLINECODE first) set to zero, and $(D_INLINECODE count) set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by $(D_INLINECODE id).
     + 
     + Params:
     +     mode = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     id   = Specifies the name of a transform feedback object from which to retrieve a primitive count.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawTransformFeedbackStream)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glDrawTransformFeedback(GLenum mode, GLuint id) @system @nogc nothrow;

    /++
     + glDrawTransformFeedbackInstanced: man4/glDrawTransformFeedbackInstanced.xml
     + 
     + $(D_INLINECODE glDrawTransformFeedbackInstanced) draws multiple copies of a range of primitives of a type specified by $(D_INLINECODE mode) using a count retrieved from the transform feedback stream specified by $(D_INLINECODE stream) of the transform feedback object specified by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackInstanced) is equivalent to calling $(D_INLINECODE glDrawArraysInstanced) with $(D_INLINECODE mode) and $(D_INLINECODE primcount) as specified, $(D_INLINECODE first) set to zero, and $(D_INLINECODE count) set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackInstanced) is equivalent to calling $(D_INLINECODE glDrawTransformFeedbackStreamInstanced) with $(D_INLINECODE stream) set to zero.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     id        = Specifies the name of a transform feedback object from which to retrieve a primitive count.
     +     primcount = Specifies the number of instances of the geometry to render.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawTransformFeedback), $(D_INLINECODE glDrawTransformFeedbackStreamInstanced).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_transform_feedback_instanced")
    void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount) @system @nogc nothrow;

    /++
     + glDrawTransformFeedbackStream: man4/glDrawTransformFeedbackStream.xml
     + 
     + $(D_INLINECODE glDrawTransformFeedbackStream) draws primitives of a type specified by $(D_INLINECODE mode) using a count retrieved from the transform feedback stream specified by $(D_INLINECODE stream) of the transform feedback object specified by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackStream) is equivalent to calling $(D_INLINECODE glDrawArrays) with $(D_INLINECODE mode) as specified, $(D_INLINECODE first) set to zero, and $(D_INLINECODE count) set to the number of vertices captured on vertex stream $(D_INLINECODE stream) the last time transform feedback was active on the transform feedback object named by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedback) is equivalent to calling $(D_INLINECODE glDrawTransformFeedbackStream) with $(D_INLINECODE stream) set to zero.
     + 
     + Params:
     +     mode   = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     id     = Specifies the name of a transform feedback object from which to retrieve a primitive count.
     +     stream = Specifies the index of the transform feedback stream from which to retrieve a primitive count.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream) @system @nogc nothrow;

    /++
     + glDrawTransformFeedbackStreamInstanced: man4/glDrawTransformFeedbackStreamInstanced.xml
     + 
     + $(D_INLINECODE glDrawTransformFeedbackStreamInstanced) draws multiple copies of a range of primitives of a type specified by $(D_INLINECODE mode) using a count retrieved from the transform feedback stream specified by $(D_INLINECODE stream) of the transform feedback object specified by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackStreamInstanced) is equivalent to calling $(D_INLINECODE glDrawArraysInstanced) with $(D_INLINECODE mode) and $(D_INLINECODE primcount) as specified, $(D_INLINECODE first) set to zero, and $(D_INLINECODE count) set to the number of vertices captured on vertex stream $(D_INLINECODE stream) the last time transform feedback was active on the transform feedback object named by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackInstanced) is equivalent to calling $(D_INLINECODE glDrawTransformFeedbackStreamInstanced) with $(D_INLINECODE stream) set to zero.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     id        = Specifies the name of a transform feedback object from which to retrieve a primitive count.
     +     stream    = Specifies the index of the transform feedback stream from which to retrieve a primitive count.
     +     primcount = Specifies the number of instances of the geometry to render.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawTransformFeedback), $(D_INLINECODE glDrawTransformFeedbackStream).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_transform_feedback_instanced")
    void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount) @system @nogc nothrow;

    /++
     + glFenceSync: man4/glFenceSync.xml
     + 
     + $(D_INLINECODE glFenceSync) creates a new fence sync object, inserts a fence command into the GL command stream and associates it with that sync object, and returns a non-zero name corresponding to the sync object. When the specified $(D_INLINECODE condition) of the sync object is satisfied by the fence command, the sync object is signaled by the GL, causing any $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync) commands blocking in $(D_INLINECODE sync) to. No other state is affected by $(D_INLINECODE glFenceSync) or by the execution of the associated fence command. $(D_INLINECODE condition) must be $(D_INLINECODE GL_SYNC_GPU_COMMANDS_COMPLETE). This condition is satisfied by completion of the fence command corresponding to the sync object and all preceding commands in the same command stream. The sync object will not be signaled until all effects from these commands on GL client and server state and the framebuffer are fully realized. Note that completion of the fence command occurs once the state of the corresponding sync object has been changed, but commands waiting on that sync object may not be unblocked until after the fence command completes.
     + 
     + $(D_INLINECODE glFenceSync) is only supported if the GL version is 3.2 or greater, or if the $(D_INLINECODE ARB_sync) extension is supported.
     + 
     + Params:
     +     condition = Specifies the condition that must be met to set the sync object's state to signaled. $(D_INLINECODE condition) must be $(D_INLINECODE GL_SYNC_GPU_COMMANDS_COMPLETE).
     +     flags     = Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and $(D_INLINECODE flags) must be zero. $(D_INLINECODE flags) is a placeholder for anticipated future extensions of fence sync object capabilities.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteSync), $(D_INLINECODE glGetSync), $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    GLsync glFenceSync(GLenum condition, GLbitfield flags) @system @nogc nothrow;

    /++
     + glFinish: man4/glFinish.xml
     + 
     + $(D_INLINECODE glFinish) does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.
     + 
     + $(D_INLINECODE glFinish) requires a round trip to the server.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFlush)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFinish() @system @nogc nothrow;

    /++
     + glFlush: man4/glFlush.xml
     + 
     + Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. $(D_INLINECODE glFlush) empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time. Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call $(D_INLINECODE glFlush) whenever they count on having all of their previously issued commands completed. For example, call $(D_INLINECODE glFlush) before waiting for user input that depends on the generated image.
     + 
     + $(D_INLINECODE glFlush) can return at any time. It does not wait until the execution of all previously issued GL commands is complete.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFinish)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFlush() @system @nogc nothrow;

    /++
     + glFlushMappedBufferRange: man4/glFlushMappedBufferRange.xml
     + 
     + $(D_INLINECODE glFlushMappedBufferRange) indicates that modifications have been made to a range of a mapped buffer object. The buffer object must previously have been mapped with the $(D_INLINECODE GL_MAP_FLUSH_EXPLICIT_BIT) flag. $(D_INLINECODE offset) and $(D_INLINECODE length) indicate the modified subrange of the mapping, in basic machine units. The specified subrange to flush is relative to the start of the currently mapped range of the buffer. These commands may be called multiple times to indicate distinct subranges of the mapping which require flushing. If a buffer range is mapped with both $(D_INLINECODE GL_MAP_PERSISTENT_BIT) and $(D_INLINECODE GL_MAP_FLUSH_EXPLICIT_BIT) set, then these commands may be called to ensure that data written by the client into the flushed region becomes visible to the server. Data written to a coherent store will always become visible to the server after an unspecified period of time.
     + 
     + The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glFlushMappedBufferRange), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glFlushMappedNamedBufferRange).
     +     offset = Specifies the start of the buffer subrange, in basic machine units.
     +     length = Specifies the length of the buffer subrange, in basic machine units.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMapBufferRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_map_buffer_range")
    void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizei length) @system @nogc nothrow;

    /++
     + glFramebufferParameteri: man4/glFramebufferParameteri.xml
     + 
     + $(D_INLINECODE glFramebufferParameteri) and $(D_INLINECODE glNamedFramebufferParameteri) modify the value of the parameter named $(D_INLINECODE pname) in the specified framebuffer object. There are no modifiable parameters of the default draw and read framebuffer, so they are not valid targets of these commands. For $(D_INLINECODE glFramebufferParameteri), the framebuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferParameteri), $(D_INLINECODE framebuffer) is the name of the framebuffer object. $(D_INLINECODE pname) specifies the parameter to be modified. The following values are accepted:
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer is bound for $(D_INLINECODE glFramebufferParameteri).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferParameteri).
     +     pname       = Specifies the framebuffer parameter to be modified.
     +     param       = The new value for the parameter named $(D_INLINECODE pname).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glCreateFramebuffers), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glGetFramebufferParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_framebuffer_no_attachments")
    void glFramebufferParameteri(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param) @system @nogc nothrow;

    /++
     + glFramebufferRenderbuffer: man4/glFramebufferRenderbuffer.xml
     + 
     + $(D_INLINECODE glFramebufferRenderbuffer) and $(D_INLINECODE glNamedFramebufferRenderbuffer) attaches a renderbuffer as one of the logical buffers of the specified framebuffer object. Renderbuffers cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands. For $(D_INLINECODE glFramebufferRenderbuffer), the framebuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferRenderbuffer), $(D_INLINECODE framebuffer) is the name of the framebuffer object. $(D_INLINECODE renderbuffertarget) must be $(D_INLINECODE GL_RENDERBUFFER). $(D_INLINECODE renderbuffer) must be zero or the name of an existing renderbuffer object of type $(D_INLINECODE renderbuffertarget). If $(D_INLINECODE renderbuffer) is not zero, then the specified renderbuffer will be used as the logical buffer identified by $(D_INLINECODE attachment) of the specified framebuffer object. If $(D_INLINECODE renderbuffer) is zero, then the value of $(D_INLINECODE renderbuffertarget) is ignored. $(D_INLINECODE attachment) specifies the logical attachment of the framebuffer and must be $(D_INLINECODE GL_COLOR_ATTACHMENT), $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) or $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT). in may range from zero to the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. Setting $(D_INLINECODE attachment) to the value $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT) is a special case causing both the depth and stencil attachments of the specified framebuffer object to be set to $(D_INLINECODE renderbuffer), which should have the base internal format $(D_INLINECODE GL_DEPTH_STENCIL). The value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) for the specified attachment point is set to $(D_INLINECODE GL_RENDERBUFFER) and the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) is set to $(D_INLINECODE renderbuffer). All other state values of specified attachment point are set to their default values. No change is made to the state of the renderbuuffer object and any previous attachment to the $(D_INLINECODE attachment) logical buffer of the specified framebuffer object is broken. If $(D_INLINECODE renderbuffer) is zero, these commands will detach the image, if any, identified by the specified attachment point of the specified framebuffer object. All state values of the attachment point are set to their default values.
     + 
     + Params:
     +     target             = Specifies the target to which the framebuffer is bound for $(D_INLINECODE glFramebufferRenderbuffer).
     +     framebuffer        = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferRenderbuffer).
     +     attachment         = Specifies the attachment point of the framebuffer.
     +     renderbuffertarget = Specifies the renderbuffer target. Must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer       = Specifies the name of an existing renderbuffer object of type $(D_INLINECODE renderbuffertarget) to attach.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), $(D_INLINECODE glFramebufferTexture3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;

    /++
     + glFramebufferTexture: man4/glFramebufferTexture.xml
     + 
     + These commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands. For all commands $(D_INLINECODE glNamedFramebufferTexture), the framebuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER), or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferTexture), $(D_INLINECODE framebuffer) is the name of the framebuffer object. $(D_INLINECODE attachment) specifies the logical attachment of the framebuffer and must be $(D_INLINECODE GL_COLOR_ATTACHMENT), $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) or $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT). in $(D_INLINECODE GL_COLOR_ATTACHMENT) may range from zero to the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. Attaching a level of a texture to $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT) is equivalent to attaching that level to both the $(D_INLINECODE GL_DEPTH_ATTACHMENT) the $(D_INLINECODE GL_STENCIL_ATTACHMENT) attachment points simultaneously. For $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D) and $(D_INLINECODE glFramebufferTexture3D), $(D_INLINECODE textarget) specifies what type of texture is named by $(D_INLINECODE texture), and for cube map textures, specifies the face that is to be attached. If $(D_INLINECODE texture) is not zero, it must be the name of an existing texture object with effective target $(D_INLINECODE textarget) unless it is a cube map texture, in which case $(D_INLINECODE textarget) must be $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X) $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z). If $(D_INLINECODE texture) is non-zero, the specified $(D_INLINECODE level) of the texture object named $(D_INLINECODE texture) is attached to the framebfufer attachment point named by $(D_INLINECODE attachment). For $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), and $(D_INLINECODE glFramebufferTexture3D), $(D_INLINECODE texture) must be zero or the name of an existing texture with an effective target of $(D_INLINECODE textarget), or $(D_INLINECODE texture) must be the name of an existing cube-map texture and $(D_INLINECODE textarget) must be one of $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z). If $(D_INLINECODE textarget) is $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), then $(D_INLINECODE level) must be zero. If $(D_INLINECODE textarget) is $(D_INLINECODE GL_TEXTURE_3D), then $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_3D_TEXTURE_SIZE). If $(D_INLINECODE textarget) is one of $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), then $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_CUBE_MAP_TEXTURE_SIZE). For all other values of $(D_INLINECODE textarget), $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_TEXTURE_SIZE). $(D_INLINECODE layer) specifies the layer of a 2-dimensional image within a 3-dimensional texture. For $(D_INLINECODE glFramebufferTexture1D), if $(D_INLINECODE texture) is not zero, then $(D_INLINECODE textarget) must be $(D_INLINECODE GL_TEXTURE_1D). For $(D_INLINECODE glFramebufferTexture2D), if $(D_INLINECODE texture) is not zero, $(D_INLINECODE textarget) must be one of $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE). For $(D_INLINECODE glFramebufferTexture3D), if $(D_INLINECODE texture) is not zero, then $(D_INLINECODE textarget) must be $(D_INLINECODE GL_TEXTURE_3D). For $(D_INLINECODE glFramebufferTexture) and $(D_INLINECODE glNamedFramebufferTexture), if $(D_INLINECODE texture) is the name of a three-dimensional, cube map array, cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an array of images, and the framebuffer attachment is considered to be.
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer is bound for all commands $(D_INLINECODE glNamedFramebufferTexture).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferTexture).
     +     attachment  = Specifies the attachment point of the framebuffer.
     +     textarget   = For $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D) and $(D_INLINECODE glFramebufferTexture3D), specifies what type of texture is expected in the $(D_INLINECODE texture) parameter, or for cube map textures, which face is to be attached.
     +     texture     = Specifies the name of an existing texture object to attach.
     +     level       = Specifies the mipmap level of the texture object to attach.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), $(D_INLINECODE glFramebufferTexture3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;

    /++
     + glFramebufferTextureLayer: man4/glFramebufferTextureLayer.xml
     + 
     + $(D_INLINECODE glFramebufferTextureLayer) and $(D_INLINECODE glNamedFramebufferTextureLayer) attach a single layer of a three-dimensional or array texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands. For $(D_INLINECODE glFramebufferTextureLayer), the framebuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER), or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferTextureLayer), $(D_INLINECODE framebuffer) is the name of the framebuffer object. $(D_INLINECODE attachment) specifies the logical attachment of the framebuffer and must be $(D_INLINECODE GL_COLOR_ATTACHMENT), $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) or $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT). in $(D_INLINECODE GL_COLOR_ATTACHMENT) may range from zero to the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. Attaching a level of a texture to $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT) is equivalent to attaching that level to both the $(D_INLINECODE GL_DEPTH_ATTACHMENT) the $(D_INLINECODE GL_STENCIL_ATTACHMENT) attachment points simultaneously. If $(D_INLINECODE texture) is not zero, it must be the name of a three-dimensional, two-dimensional multisample array, one- or two-dimensional array, or cube map array texture. If $(D_INLINECODE texture) is a three-dimensional texture, then $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_3D_TEXTURE_SIZE). If $(D_INLINECODE texture) is a two-dimensional array texture, then $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_TEXTURE_SIZE). For cube map textures, $(D_INLINECODE layer) is translated into a cube map face according to $$ face = k \bmod 6. $$ For cube map array textures, $(D_INLINECODE layer) is translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$ and $$ face = k \bmod 6. $$
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer is bound for $(D_INLINECODE glFramebufferTextureLayer).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferTextureLayer).
     +     attachment  = Specifies the attachment point of the framebuffer.
     +     texture     = Specifies the name of an existing texture object to attach.
     +     level       = Specifies the mipmap level of the texture object to attach.
     +     layer       = Specifies the layer of the texture object to attach.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferTexture),
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;

    /++
     + glFrontFace: man4/glFrontFace.xml
     + 
     + In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_CULL_FACE). The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. $(D_INLINECODE glFrontFace) specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing $(D_INLINECODE GL_CCW) to $(D_INLINECODE mode) selects counterclockwise polygons as front-facing; $(D_INLINECODE GL_CW) selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.
     + 
     + Params:
     +     mode = Specifies the orientation of front-facing polygons. $(D_INLINECODE GL_CW) and $(D_INLINECODE GL_CCW) are accepted. The initial value is $(D_INLINECODE GL_CCW).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCullFace),
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFrontFace(GLenum mode) @system @nogc nothrow;

    /++
     + glGenBuffers: man4/glGenBuffers.xml
     + 
     + $(D_INLINECODE glGenBuffers) returns $(D_INLINECODE n) buffer object names in $(D_INLINECODE buffers). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenBuffers). Buffer object names returned by a call to $(D_INLINECODE glGenBuffers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteBuffers). No buffer objects are associated with the returned buffer object names until they are first bound by calling $(D_INLINECODE glBindBuffer).
     + 
     + Params:
     +     n       = Specifies the number of buffer object names to be generated.
     +     buffers = Specifies an array in which the generated buffer object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGenBuffers(GLsizei n, GLuint* buffers) @system @nogc nothrow;

    /++
     + glGenerateMipmap: man4/glGenerateMipmap.xml
     + 
     + $(D_INLINECODE glGenerateMipmap) and $(D_INLINECODE glGenerateTextureMipmap) generates mipmaps for the specified texture object. For $(D_INLINECODE glGenerateMipmap), the texture object is that bound to to $(D_INLINECODE target). For $(D_INLINECODE glGenerateTextureMipmap), $(D_INLINECODE texture) is the name of the texture object. For cube map and cube map array textures, the texture object must be cube complete or cube array complete respectively. Mipmap generation replaces texel image levels $level_{base} + 1$ through $q$ with images derived from the $level_{base}$ image, regardless of their previous contents. All other mimap images, including the $level_{base}+1$ image, are left unchanged by this computation. The internal formats of the derived mipmap images all match those of the $level_{base}$ image. The contents of the derived images are computed by repeated, filtered reduction of the $level_{base} + 1$ image. For one- and two-dimensional array and cube map array textures, each layer is filtered independently.
     + 
     + Cube map array textures are accepted only if the GL version is 4.0 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture object is bound for $(D_INLINECODE glGenerateMipmap). Must be one of $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY).
     +     texture = Specifies the texture object name for $(D_INLINECODE glGenerateTextureMipmap).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage2D), $(D_INLINECODE glBindTexture), $(D_INLINECODE glGenTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGenerateMipmap(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGenerateTextureMipmap(GLuint texture) @system @nogc nothrow;

    /++
     + glGenFramebuffers: man4/glGenFramebuffers.xml
     + 
     + $(D_INLINECODE glGenFramebuffers) returns $(D_INLINECODE n) framebuffer object names in $(D_INLINECODE ids). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenFramebuffers). Framebuffer object names returned by a call to $(D_INLINECODE glGenFramebuffers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteFramebuffers). The names returned in $(D_INLINECODE ids) are marked as used, for the purposes of $(D_INLINECODE glGenFramebuffers) only, but they acquire state and type only when they are first bound.
     + 
     + Params:
     +     n   = Specifies the number of framebuffer object names to generate.
     +     ids = Specifies an array in which the generated framebuffer object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glDeleteFramebuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGenFramebuffers(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glGenProgramPipelines: man4/glGenProgramPipelines.xml
     + 
     + $(D_INLINECODE glGenProgramPipelines) returns $(D_INLINECODE n) previously unused program pipeline object names in $(D_INLINECODE pipelines). These names are marked as used, for the purposes of $(D_INLINECODE glGenProgramPipelines) only, but they acquire program pipeline state only when they are first bound.
     + 
     + Params:
     +     n         = Specifies the number of program pipeline object names to reserve.
     +     pipelines = Specifies an array of into which the reserved names will be written.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glIsProgramPipeline), $(D_INLINECODE glUseProgramStages), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glGenProgramPipelines(GLsizei n, GLuint* pipelines) @system @nogc nothrow;

    /++
     + glGenQueries: man4/glGenQueries.xml
     + 
     + $(D_INLINECODE glGenQueries) returns $(D_INLINECODE n) query object names in $(D_INLINECODE ids). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenQueries). Query object names returned by a call to $(D_INLINECODE glGenQueries) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteQueries). No query objects are associated with the returned query object names until they are first used by calling $(D_INLINECODE glBeginQuery).
     + 
     + Params:
     +     n   = Specifies the number of query object names to be generated.
     +     ids = Specifies an array in which the generated query object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGenQueries(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glGenRenderbuffers: man4/glGenRenderbuffers.xml
     + 
     + $(D_INLINECODE glGenRenderbuffers) returns $(D_INLINECODE n) renderbuffer object names in $(D_INLINECODE renderbuffers). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenRenderbuffers). Renderbuffer object names returned by a call to $(D_INLINECODE glGenRenderbuffers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteRenderbuffers). The names returned in $(D_INLINECODE renderbuffers) are marked as used, for the purposes of $(D_INLINECODE glGenRenderbuffers) only, but they acquire state and type only when they are first bound.
     + 
     + Params:
     +     n             = Specifies the number of renderbuffer object names to generate.
     +     renderbuffers = Specifies an array in which the generated renderbuffer object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGenRenderbuffers(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;

    /++
     + glGenSamplers: man4/glGenSamplers.xml
     + 
     + $(D_INLINECODE glGenSamplers) returns $(D_INLINECODE n) sampler object names in $(D_INLINECODE samplers). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenSamplers). Sampler object names returned by a call to $(D_INLINECODE glGenSamplers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteSamplers). The names returned in $(D_INLINECODE samplers) are marked as used, for the purposes of $(D_INLINECODE glGenSamplers) only, but they acquire state and type only when they are first bound.
     + 
     + $(D_INLINECODE glGenSamplers) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     n        = Specifies the number of sampler object names to generate.
     +     samplers = Specifies an array in which the generated sampler object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindSampler), $(D_INLINECODE glIsSampler), $(D_INLINECODE glDeleteSamplers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGenSamplers(GLsizei n, GLuint* samplers) @system @nogc nothrow;

    /++
     + glGenTextures: man4/glGenTextures.xml
     + 
     + $(D_INLINECODE glGenTextures) returns $(D_INLINECODE n) texture names in $(D_INLINECODE textures). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenTextures). The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see $(D_INLINECODE glBindTexture) ). Texture names returned by a call to $(D_INLINECODE glGenTextures) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteTextures).
     + 
     + Params:
     +     n        = Specifies the number of texture names to be generated.
     +     textures = Specifies an array in which the generated texture names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glGenTextures(GLsizei n, GLuint* textures) @system @nogc nothrow;

    /++
     + glGenTransformFeedbacks: man4/glGenTransformFeedbacks.xml
     + 
     + $(D_INLINECODE glGenTransformFeedbacks) returns $(D_INLINECODE n) previously unused transform feedback object names in $(D_INLINECODE ids). These names are marked as used, for the purposes of $(D_INLINECODE glGenTransformFeedbacks) only, but they acquire transform feedback state only when they are first bound.
     + 
     + Params:
     +     n   = Specifies the number of transform feedback object names to reserve.
     +     ids = Specifies an array of into which the reserved names will be written.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glIsTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glResumeTransformFeedback), $(D_INLINECODE glEndTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glGenTransformFeedbacks(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glGenVertexArrays: man4/glGenVertexArrays.xml
     + 
     + $(D_INLINECODE glGenVertexArrays) returns $(D_INLINECODE n) vertex array object names in $(D_INLINECODE arrays). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenVertexArrays). Vertex array object names returned by a call to $(D_INLINECODE glGenVertexArrays) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteVertexArrays). The names returned in $(D_INLINECODE arrays) are marked as used, for the purposes of $(D_INLINECODE glGenVertexArrays) only, but they acquire state and type only when they are first bound.
     + 
     + Params:
     +     n      = Specifies the number of vertex array object names to generate.
     +     arrays = Specifies an array in which the generated vertex array object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexArray), $(D_INLINECODE glDeleteVertexArrays)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    void glGenVertexArrays(GLsizei n, GLuint* arrays) @system @nogc nothrow;

    /++
     + glGet: man4/glGet.xml
     + 
     + These commands return values for simple state variables in GL. $(D_INLINECODE pname) is a symbolic constant indicating the state variable to be returned, and $(D_INLINECODE data) is a pointer to an array of the indicated type in which to place the returned data. Type conversion is performed if $(D_INLINECODE data) has a different type than the state variable value being requested. If $(D_INLINECODE glGetBooleanv) is called, a floating-point (or integer) value is converted to $(D_INLINECODE GL_FALSE) if and only if it is 0.0 (or 0). Otherwise, it is converted to $(D_INLINECODE GL_TRUE). If $(D_INLINECODE glGetIntegerv) is called, boolean values are returned as $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE), and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and -1.0 to the most negative representable integer value. If $(D_INLINECODE glGetFloatv) or $(D_INLINECODE glGetDoublev) is called, boolean values are returned as $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE), and integer values are converted to floating-point values. The following symbolic constants are accepted by $(D_INLINECODE pname) : Many of the boolean parameters can also be queried more easily using $(D_INLINECODE glIsEnabled).
     + 
     + The following parameters return the associated value for the active texture unit: $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_BINDING_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_BINDING_2D), $(D_INLINECODE GL_TEXTURE_3D) and $(D_INLINECODE GL_TEXTURE_BINDING_3D). $(D_INLINECODE GL_MAX_VIEWPORTS), $(D_INLINECODE GL_VIEWPORT_SUBPIXEL_BITS), $(D_INLINECODE GL_VIEWPORT_BOUNDS_RANGE), $(D_INLINECODE GL_LAYER_PROVOKING_VERTEX), and $(D_INLINECODE GL_VIEWPORT_INDEX_PROVOKING_VERTEX) are available only if the GL version is 4.1 or greater. $(D_INLINECODE GL_MAX_VERTEX_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_GEOMETRY_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_FRAMGENT_ATOMIC_COUNTERS), and $(D_INLINECODE GL_MIN_MAP_BUFFER_ALIGNMENT) are accepted by $(D_INLINECODE pname) only if the GL version is 4.2 or greater. $(D_INLINECODE GL_MAX_ELEMENT_INDEX) is accepted by $(D_INLINECODE pname) only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_COMPUTE_UNIFORM_BLOCKS), $(D_INLINECODE GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS), $(D_INLINECODE GL_MAX_COMPUTE_UNIFORM_COMPONENTS), $(D_INLINECODE GL_MAX_COMPUTE_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS), $(D_INLINECODE GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS), $(D_INLINECODE GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS), $(D_INLINECODE GL_MAX_COMPUTE_WORK_GROUP_COUNT), and $(D_INLINECODE GL_MAX_COMPUTE_WORK_GROUP_SIZE) and $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER_BINDING) are available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_DEBUG_GROUP_STACK_DEPTH), $(D_INLINECODE GL_DEBUG_GROUP_STACK_DEPTH) and $(D_INLINECODE GL_MAX_LABEL_LENGTH) are accepted only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_UNIFORM_LOCATIONS) is accepted only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_FRAMEBUFFER_WIDTH), $(D_INLINECODE GL_MAX_FRAMEBUFFER_HEIGHT), $(D_INLINECODE GL_MAX_FRAMEBUFFER_LAYERS), and $(D_INLINECODE GL_MAX_FRAMEBUFFER_SAMPLES) are available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS), $(D_INLINECODE GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS), $(D_INLINECODE GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS), $(D_INLINECODE GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS), $(D_INLINECODE GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS), and $(D_INLINECODE GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS) are available only if the GL version is 4.3 or higher. $(D_INLINECODE GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT) is available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_VERTEX_BINDING_DIVISOR), $(D_INLINECODE GL_VERTEX_BINDING_OFFSET), $(D_INLINECODE GL_VERTEX_BINDING_STRIDE), $(D_INLINECODE GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET) and $(D_INLINECODE GL_MAX_VERTEX_ATTRIB_BINDINGS) are available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     pname  = Specifies the parameter value to be returned for non-indexed versions of $(D_INLINECODE glGet). The symbolic constants in the list below are accepted.
     +     target = Specifies the parameter value to be returned for indexed versions of $(D_INLINECODE glGet). The symbolic constants in the list below are accepted.
     +     index  = Specifies the index of the particular element being queried.
     +     data   = Returns the value or values of the specified parameter.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetAttachedShaders), $(D_INLINECODE glGetAttribLocation), $(D_INLINECODE glGetBufferParameter), $(D_INLINECODE glGetBufferPointerv), $(D_INLINECODE glGetBufferSubData), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glGetError), $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramInfoLog), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetShader), $(D_INLINECODE glGetShaderInfoLog), $(D_INLINECODE glGetShaderSource), $(D_INLINECODE glGetString), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glGetUniform), $(D_INLINECODE glGetUniformLocation), $(D_INLINECODE glGetVertexAttrib), $(D_INLINECODE glGetVertexAttribPointerv), $(D_INLINECODE glIsEnabled)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetBooleanv(GLenum pname, GLboolean* data) @system @nogc nothrow;

    /++
     + glGetActiveAtomicCounterBufferiv: man4/glGetActiveAtomicCounterBufferiv.xml
     + 
     + $(D_INLINECODE glGetActiveAtomicCounterBufferiv) retrieves information about the set of active atomic counter buffers for a program object. $(D_INLINECODE program) is the name of a program object for which the command $(D_INLINECODE glLinkProgram) has been issued in the past. It is not necessary for $(D_INLINECODE program) to have been linked successfully. The link may have failed because the number of active atomic counters exceeded the limits. $(D_INLINECODE bufferIndex) specifies the index of an active atomic counter buffer and must be in the range zero to the value of $(D_INLINECODE GL_ACTIVE_ATOMIC_COUNTER_BUFFERS) minus one. The value of $(D_INLINECODE GL_ACTIVE_ATOMIC_COUNTER_BUFFERS) for $(D_INLINECODE program) indicates the number of active atomic counter buffer and can be queried with $(D_INLINECODE glGetProgram). If no error occurs, the parameter(s) specified by $(D_INLINECODE pname) are returned in $(D_INLINECODE params). If an error is generated, the contents of $(D_INLINECODE params) are not modified. If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_BINDING), then the index of the counter buffer binding point associated with the active atomic counter buffer $(D_INLINECODE bufferIndex) for $(D_INLINECODE program) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE), then the implementation-dependent minimum total buffer object size, in baseic machine units, required to hold all active atomic counters in the atomic counter binding point identified by $(D_INLINECODE bufferIndex) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS), then the number of active atomic counters for the atomic counter buffer identified by $(D_INLINECODE bufferIndex) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES), then a list of the active atomic counter indices for the atomic counter buffer identified by $(D_INLINECODE bufferIndex) is returned. The number of elements that will be written into $(D_INLINECODE params) is the value of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS) for $(D_INLINECODE bufferIndex). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER) then a boolean value indicating whether the atomic counter buffer identified by $(D_INLINECODE bufferIndex) is referenced by the vertex, tessellation control, tessellation evaluation, geometry, fragment or compute processing stages of $(D_INLINECODE program), respectively, is returned.
     + 
     + $(D_INLINECODE glGetActiveAtomicCounterBufferiv) is available only if the GL version is 4.2 or higher. $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER) is available only of the GL version is 4.3 or higher.
     + 
     + Params:
     +     program     = The name of a program object from which to retrieve information.
     +     bufferIndex = Specifies index of an active atomic counter buffer.
     +     pname       = Specifies which parameter of the atomic counter buffer to retrieve.
     +     params      = Specifies the address of a variable into which to write the retrieved information.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetUniformLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_atomic_counters")
    void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetActiveAttrib: man4/glGetActiveAttrib.xml
     + 
     + $(D_INLINECODE glGetActiveAttrib) returns information about an active attribute variable in the program object specified by $(D_INLINECODE program). The number of active attributes can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_ATTRIBUTES). A value of 0 for $(D_INLINECODE index) selects the first active attribute variable. Permissible values for $(D_INLINECODE index) range from zero to the number of active attribute variables minus one. A vertex shader may use either built-in attribute variables, user-defined attribute variables, or both. Built-in attribute variables have a prefix of &quot;gl_&quot; and reference conventional OpenGL vertex attribtes (e.g., $(D_INLINECODE gl_Vertex), $(D_INLINECODE gl_Normal), etc., see the OpenGL Shading Language specification for a complete list.) User-defined attribute variables have arbitrary names and obtain their values through numbered generic vertex attributes. An attribute variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, $(D_INLINECODE program) should have previously been the target of a call to $(D_INLINECODE glLinkProgram), but it is not necessary for it to have been linked successfully. The size of the character buffer required to store the longest attribute variable name in $(D_INLINECODE program) can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_ATTRIBUTE_MAX_LENGTH). This value should be used to allocate a buffer of sufficient size to store the returned attribute name. The size of this character buffer is passed in $(D_INLINECODE bufSize), and a pointer to this character buffer is passed in $(D_INLINECODE name). $(D_INLINECODE glGetActiveAttrib) returns the name of the attribute variable indicated by $(D_INLINECODE index), storing it in the character buffer specified by $(D_INLINECODE name). The string returned will be null terminated. The actual number of characters written into this buffer is returned in $(D_INLINECODE length), and this count does not include the null termination character. If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The $(D_INLINECODE type) argument specifies a pointer to a variable into which the attribute variable's data type will be written. The symbolic constants $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_FLOAT_VEC2), $(D_INLINECODE GL_FLOAT_VEC3), $(D_INLINECODE GL_FLOAT_VEC4), $(D_INLINECODE GL_FLOAT_MAT2), $(D_INLINECODE GL_FLOAT_MAT3), $(D_INLINECODE GL_FLOAT_MAT4), $(D_INLINECODE GL_FLOAT_MAT2x3), $(D_INLINECODE GL_FLOAT_MAT2x4), $(D_INLINECODE GL_FLOAT_MAT3x2), $(D_INLINECODE GL_FLOAT_MAT3x4), $(D_INLINECODE GL_FLOAT_MAT4x2), $(D_INLINECODE GL_FLOAT_MAT4x3), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_INT_VEC2), $(D_INLINECODE GL_INT_VEC3), $(D_INLINECODE GL_INT_VEC4), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_UNSIGNED_INT_VEC2), $(D_INLINECODE GL_UNSIGNED_INT_VEC3), $(D_INLINECODE GL_UNSIGNED_INT_VEC4), $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_DOUBLE_VEC2), $(D_INLINECODE GL_DOUBLE_VEC3), $(D_INLINECODE GL_DOUBLE_VEC4), $(D_INLINECODE GL_DOUBLE_MAT2), $(D_INLINECODE GL_DOUBLE_MAT3), $(D_INLINECODE GL_DOUBLE_MAT4), $(D_INLINECODE GL_DOUBLE_MAT2x3), $(D_INLINECODE GL_DOUBLE_MAT2x4), $(D_INLINECODE GL_DOUBLE_MAT3x2), $(D_INLINECODE GL_DOUBLE_MAT3x4), $(D_INLINECODE GL_DOUBLE_MAT4x2), or $(D_INLINECODE GL_DOUBLE_MAT4x3) may be returned. The $(D_INLINECODE size) argument will return the size of the attribute, in units of the type returned in $(D_INLINECODE type). The list of active attribute variables may include both built-in attribute variables (which begin with the prefix &quot;gl_&quot;) as well as user-defined attribute variable names. This function will return as much information as it can about the specified active attribute variable. If no information is available, $(D_INLINECODE length) will be 0, and $(D_INLINECODE name) will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values $(D_INLINECODE length), $(D_INLINECODE size), $(D_INLINECODE type), and $(D_INLINECODE name) will be unmodified.
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     index   = Specifies the index of the attribute variable to be queried.
     +     bufSize = Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by $(D_INLINECODE name).
     +     length  = Returns the number of characters actually written by OpenGL in the string indicated by $(D_INLINECODE name) (excluding the null terminator) if a value other than $(D_INLINECODE null) is passed.
     +     size    = Returns the size of the attribute variable.
     +     type    = Returns the data type of the attribute variable.
     +     name    = Returns a null terminated string containing the name of the attribute variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) @system @nogc nothrow;

    /++
     + glGetActiveSubroutineName: man4/glGetActiveSubroutineName.xml
     + 
     + $(D_INLINECODE glGetActiveSubroutineName) queries the name of an active shader subroutine uniform from the program object given in $(D_INLINECODE program). $(D_INLINECODE index) specifies the index of the shader subroutine uniform within the shader stage given by $(D_INLINECODE stage), and must between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINES) minus one for the shader stage. The name of the selected subroutine is returned as a null-terminated string in $(D_INLINECODE name). The actual number of characters written into $(D_INLINECODE name), not including the null-terminator, is is returned in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. The maximum number of characters that may be written into $(D_INLINECODE name), including the null-terminator, is given in $(D_INLINECODE bufsize).
     + 
     + Params:
     +     program    = Specifies the name of the program containing the subroutine.
     +     shadertype = Specifies the shader stage from which to query the subroutine name.
     +     index      = Specifies the index of the shader subroutine uniform.
     +     bufsize    = Specifies the size of the buffer whose address is given in $(D_INLINECODE name).
     +     length     = Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.
     +     name       = Specifies the address of an array into which the name of the shader subroutine uniform will be written.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetSubroutineIndex), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetProgramStage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) @system @nogc nothrow;

    /++
     + glGetActiveSubroutineUniform: man4/glGetActiveSubroutineUniform.xml
     + 
     + $(D_INLINECODE glGetActiveSubroutineUniform) queries a parameter of an active shader subroutine uniform. $(D_INLINECODE program) contains the name of the program containing the uniform. $(D_INLINECODE shadertype) specifies the stage which which the uniform location, given by $(D_INLINECODE index), is valid. $(D_INLINECODE index) must be between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORMS) minus one for the shader stage. If $(D_INLINECODE pname) is $(D_INLINECODE GL_NUM_COMPATIBLE_SUBROUTINES), a single integer indicating the number of subroutines that can be assigned to the uniform is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_COMPATIBLE_SUBROUTINES), an array of integers is returned in $(D_INLINECODE values), with each integer specifying the index of an active subroutine that can be assigned to the selected subroutine uniform. The number of integers returned is the same as the value returned for $(D_INLINECODE GL_NUM_COMPATIBLE_SUBROUTINES). If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_SIZE), a single integer is returned in $(D_INLINECODE values). If the selected subroutine uniform is an array, the  declared size of the array is returned; otherwise, one is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_NAME_LENGTH), a single integer specifying the length of the subroutine uniform name (including the terminating null character) is returned in $(D_INLINECODE values).
     + 
     + Params:
     +     program    = Specifies the name of the program containing the subroutine.
     +     shadertype = Specifies the shader stage from which to query for the subroutine parameter. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     index      = Specifies the index of the shader subroutine uniform.
     +     pname      = Specifies the parameter of the shader subroutine uniform to query. $(D_INLINECODE pname) must be $(D_INLINECODE GL_NUM_COMPATIBLE_SUBROUTINES), $(D_INLINECODE GL_COMPATIBLE_SUBROUTINES), $(D_INLINECODE GL_UNIFORM_SIZE) or $(D_INLINECODE GL_UNIFORM_NAME_LENGTH).
     +     values     = Specifies the address of a into which the queried value or values will be placed.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetSubroutineIndex), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetProgramStage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values) @system @nogc nothrow;

    /++
     + glGetActiveSubroutineUniformName: man4/glGetActiveSubroutineUniformName.xml
     + 
     + $(D_INLINECODE glGetActiveSubroutineUniformName) retrieves the name of an active shader subroutine uniform. $(D_INLINECODE program) contains the name of the program containing the uniform. $(D_INLINECODE shadertype) specifies the stage for which which the uniform location, given by $(D_INLINECODE index), is valid. $(D_INLINECODE index) must be between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORMS) minus one for the shader stage. The uniform name is returned as a null-terminated string in $(D_INLINECODE name). The actual number of characters written into $(D_INLINECODE name), excluding the null terminator is returned in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. The maximum number of characters that may be written into $(D_INLINECODE name), including the null terminator, is specified by $(D_INLINECODE bufsize). The length of the longest subroutine uniform name in $(D_INLINECODE program) and $(D_INLINECODE shadertype) is given by the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH), which can be queried with $(D_INLINECODE glGetProgramStage).
     + 
     + Params:
     +     program    = Specifies the name of the program containing the subroutine.
     +     shadertype = Specifies the shader stage from which to query for the subroutine parameter. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     index      = Specifies the index of the shader subroutine uniform.
     +     bufsize    = Specifies the size of the buffer whose address is given in $(D_INLINECODE name).
     +     length     = Specifies the address of a variable into which is written the number of characters copied into $(D_INLINECODE name).
     +     name       = Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetSubroutineIndex), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetProgramStage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) @system @nogc nothrow;

    /++
     + glGetActiveUniform: man4/glGetActiveUniform.xml
     + 
     + $(D_INLINECODE glGetActiveUniform) returns information about an active uniform variable in the program object specified by $(D_INLINECODE program). The number of active uniform variables can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_UNIFORMS). A value of 0 for $(D_INLINECODE index) selects the first active uniform variable. Permissible values for $(D_INLINECODE index) range from zero to the number of active uniform variables minus one. Shaders may use either built-in uniform variables, user-defined uniform variables, or both. Built-in uniform variables have a prefix of &quot;gl_&quot; and reference existing OpenGL state or values derived from such state (e.g., $(D_INLINECODE gl_DepthRangeParameters), see the OpenGL Shading Language specification for a complete list.) User-defined uniform variables have arbitrary names and obtain their values from the application through calls to $(D_INLINECODE glUniform). A uniform variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, $(D_INLINECODE program) should have previously been the target of a call to $(D_INLINECODE glLinkProgram), but it is not necessary for it to have been linked successfully. The size of the character buffer required to store the longest uniform variable name in $(D_INLINECODE program) can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_UNIFORM_MAX_LENGTH). This value should be used to allocate a buffer of sufficient size to store the returned uniform variable name. The size of this character buffer is passed in $(D_INLINECODE bufSize), and a pointer to this character buffer is passed in $(D_INLINECODE name.) $(D_INLINECODE glGetActiveUniform) returns the name of the uniform variable indicated by $(D_INLINECODE index), storing it in the character buffer specified by $(D_INLINECODE name). The string returned will be null terminated. The actual number of characters written into this buffer is returned in $(D_INLINECODE length), and this count does not include the null termination character. If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The $(D_INLINECODE type) argument will return a pointer to the uniform variable's data type. The symbolic constants returned for uniform types are shown in the table below. $(B Returned Symbolic Contant) $(B Shader Uniform Type) $(D_INLINECODE GL_FLOAT) $(D_INLINECODE float) $(D_INLINECODE GL_FLOAT_VEC2) $(D_INLINECODE vec2) $(D_INLINECODE GL_FLOAT_VEC3) $(D_INLINECODE vec3) $(D_INLINECODE GL_FLOAT_VEC4) $(D_INLINECODE vec4) $(D_INLINECODE GL_DOUBLE) $(D_INLINECODE double) $(D_INLINECODE GL_DOUBLE_VEC2) $(D_INLINECODE dvec2) $(D_INLINECODE GL_DOUBLE_VEC3) $(D_INLINECODE dvec3) $(D_INLINECODE GL_DOUBLE_VEC4) $(D_INLINECODE dvec4) $(D_INLINECODE GL_INT) $(D_INLINECODE int) $(D_INLINECODE GL_INT_VEC2) $(D_INLINECODE ivec2) $(D_INLINECODE GL_INT_VEC3) $(D_INLINECODE ivec3) $(D_INLINECODE GL_INT_VEC4) $(D_INLINECODE ivec4) $(D_INLINECODE GL_UNSIGNED_INT) $(D_INLINECODE unsigned int) $(D_INLINECODE GL_UNSIGNED_INT_VEC2) $(D_INLINECODE uvec2) $(D_INLINECODE GL_UNSIGNED_INT_VEC3) $(D_INLINECODE uvec3) $(D_INLINECODE GL_UNSIGNED_INT_VEC4) $(D_INLINECODE uvec4) $(D_INLINECODE GL_BOOL) $(D_INLINECODE bool) $(D_INLINECODE GL_BOOL_VEC2) $(D_INLINECODE bvec2) $(D_INLINECODE GL_BOOL_VEC3) $(D_INLINECODE bvec3) $(D_INLINECODE GL_BOOL_VEC4) $(D_INLINECODE bvec4) $(D_INLINECODE GL_FLOAT_MAT2) $(D_INLINECODE mat2) $(D_INLINECODE GL_FLOAT_MAT3) $(D_INLINECODE mat3) $(D_INLINECODE GL_FLOAT_MAT4) $(D_INLINECODE mat4) $(D_INLINECODE GL_FLOAT_MAT2x3) $(D_INLINECODE mat2x3) $(D_INLINECODE GL_FLOAT_MAT2x4) $(D_INLINECODE mat2x4) $(D_INLINECODE GL_FLOAT_MAT3x2) $(D_INLINECODE mat3x2) $(D_INLINECODE GL_FLOAT_MAT3x4) $(D_INLINECODE mat3x4) $(D_INLINECODE GL_FLOAT_MAT4x2) $(D_INLINECODE mat4x2) $(D_INLINECODE GL_FLOAT_MAT4x3) $(D_INLINECODE mat4x3) $(D_INLINECODE GL_DOUBLE_MAT2) $(D_INLINECODE dmat2) $(D_INLINECODE GL_DOUBLE_MAT3) $(D_INLINECODE dmat3) $(D_INLINECODE GL_DOUBLE_MAT4) $(D_INLINECODE dmat4) $(D_INLINECODE GL_DOUBLE_MAT2x3) $(D_INLINECODE dmat2x3) $(D_INLINECODE GL_DOUBLE_MAT2x4) $(D_INLINECODE dmat2x4) $(D_INLINECODE GL_DOUBLE_MAT3x2) $(D_INLINECODE dmat3x2) $(D_INLINECODE GL_DOUBLE_MAT3x4) $(D_INLINECODE dmat3x4) $(D_INLINECODE GL_DOUBLE_MAT4x2) $(D_INLINECODE dmat4x2) $(D_INLINECODE GL_DOUBLE_MAT4x3) $(D_INLINECODE dmat4x3) $(D_INLINECODE GL_SAMPLER_1D) $(D_INLINECODE sampler1D) $(D_INLINECODE GL_SAMPLER_2D) $(D_INLINECODE sampler2D) $(D_INLINECODE GL_SAMPLER_3D) $(D_INLINECODE sampler3D) $(D_INLINECODE GL_SAMPLER_CUBE) $(D_INLINECODE samplerCube) $(D_INLINECODE GL_SAMPLER_1D_SHADOW) $(D_INLINECODE sampler1DShadow) $(D_INLINECODE GL_SAMPLER_2D_SHADOW) $(D_INLINECODE sampler2DShadow) $(D_INLINECODE GL_SAMPLER_1D_ARRAY) $(D_INLINECODE sampler1DArray) $(D_INLINECODE GL_SAMPLER_2D_ARRAY) $(D_INLINECODE sampler2DArray) $(D_INLINECODE GL_SAMPLER_1D_ARRAY_SHADOW) $(D_INLINECODE sampler1DArrayShadow) $(D_INLINECODE GL_SAMPLER_2D_ARRAY_SHADOW) $(D_INLINECODE sampler2DArrayShadow) $(D_INLINECODE GL_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE sampler2DMS) $(D_INLINECODE GL_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE sampler2DMSArray) $(D_INLINECODE GL_SAMPLER_CUBE_SHADOW) $(D_INLINECODE samplerCubeShadow) $(D_INLINECODE GL_SAMPLER_BUFFER) $(D_INLINECODE samplerBuffer) $(D_INLINECODE GL_SAMPLER_2D_RECT) $(D_INLINECODE sampler2DRect) $(D_INLINECODE GL_SAMPLER_2D_RECT_SHADOW) $(D_INLINECODE sampler2DRectShadow) $(D_INLINECODE GL_INT_SAMPLER_1D) $(D_INLINECODE isampler1D) $(D_INLINECODE GL_INT_SAMPLER_2D) $(D_INLINECODE isampler2D) $(D_INLINECODE GL_INT_SAMPLER_3D) $(D_INLINECODE isampler3D) $(D_INLINECODE GL_INT_SAMPLER_CUBE) $(D_INLINECODE isamplerCube) $(D_INLINECODE GL_INT_SAMPLER_1D_ARRAY) $(D_INLINECODE isampler1DArray) $(D_INLINECODE GL_INT_SAMPLER_2D_ARRAY) $(D_INLINECODE isampler2DArray) $(D_INLINECODE GL_INT_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE isampler2DMS) $(D_INLINECODE GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE isampler2DMSArray) $(D_INLINECODE GL_INT_SAMPLER_BUFFER) $(D_INLINECODE isamplerBuffer) $(D_INLINECODE GL_INT_SAMPLER_2D_RECT) $(D_INLINECODE isampler2DRect) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_1D) $(D_INLINECODE usampler1D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D) $(D_INLINECODE usampler2D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_3D) $(D_INLINECODE usampler3D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_CUBE) $(D_INLINECODE usamplerCube) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_1D_ARRAY) $(D_INLINECODE usampler2DArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_ARRAY) $(D_INLINECODE usampler2DArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE usampler2DMS) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE usampler2DMSArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_BUFFER) $(D_INLINECODE usamplerBuffer) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_RECT) $(D_INLINECODE usampler2DRect) $(D_INLINECODE GL_IMAGE_1D) $(D_INLINECODE image1D) $(D_INLINECODE GL_IMAGE_2D) $(D_INLINECODE image2D) $(D_INLINECODE GL_IMAGE_3D) $(D_INLINECODE image3D) $(D_INLINECODE GL_IMAGE_2D_RECT) $(D_INLINECODE image2DRect) $(D_INLINECODE GL_IMAGE_CUBE) $(D_INLINECODE imageCube) $(D_INLINECODE GL_IMAGE_BUFFER) $(D_INLINECODE imageBuffer) $(D_INLINECODE GL_IMAGE_1D_ARRAY) $(D_INLINECODE image1DArray) $(D_INLINECODE GL_IMAGE_2D_ARRAY) $(D_INLINECODE image2DArray) $(D_INLINECODE GL_IMAGE_2D_MULTISAMPLE) $(D_INLINECODE image2DMS) $(D_INLINECODE GL_IMAGE_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE image2DMSArray) $(D_INLINECODE GL_INT_IMAGE_1D) $(D_INLINECODE iimage1D) $(D_INLINECODE GL_INT_IMAGE_2D) $(D_INLINECODE iimage2D) $(D_INLINECODE GL_INT_IMAGE_3D) $(D_INLINECODE iimage3D) $(D_INLINECODE GL_INT_IMAGE_2D_RECT) $(D_INLINECODE iimage2DRect) $(D_INLINECODE GL_INT_IMAGE_CUBE) $(D_INLINECODE iimageCube) $(D_INLINECODE GL_INT_IMAGE_BUFFER) $(D_INLINECODE iimageBuffer) $(D_INLINECODE GL_INT_IMAGE_1D_ARRAY) $(D_INLINECODE iimage1DArray) $(D_INLINECODE GL_INT_IMAGE_2D_ARRAY) $(D_INLINECODE iimage2DArray) $(D_INLINECODE GL_INT_IMAGE_2D_MULTISAMPLE) $(D_INLINECODE iimage2DMS) $(D_INLINECODE GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE iimage2DMSArray) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_1D) $(D_INLINECODE uimage1D) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D) $(D_INLINECODE uimage2D) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_3D) $(D_INLINECODE uimage3D) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_RECT) $(D_INLINECODE uimage2DRect) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_CUBE) $(D_INLINECODE uimageCube) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_BUFFER) $(D_INLINECODE uimageBuffer) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_1D_ARRAY) $(D_INLINECODE uimage1DArray) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_ARRAY) $(D_INLINECODE uimage2DArray) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE) $(D_INLINECODE uimage2DMS) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE uimage2DMSArray) $(D_INLINECODE GL_UNSIGNED_INT_ATOMIC_COUNTER) $(D_INLINECODE atomic_uint) If one or more elements of an array are active, the name of the array is returned in $(D_INLINECODE name), the type is returned in $(D_INLINECODE type), and the $(D_INLINECODE size) parameter returns the highest array element index used, plus one, as determined by the compiler and/or linker. Only one active uniform variable will be reported for a uniform array. Uniform variables that are declared as structures or arrays of structures will not be returned directly by this function. Instead, each of these uniform variables will be reduced to its fundamental components containing the &quot;.&quot; and &quot;[]&quot; operators such that each of the names is valid as an argument to $(D_INLINECODE glGetUniformLocation). Each of these reduced uniform variables is counted as one active uniform variable and is assigned an index. A valid name cannot be a structure, an array of structures, or a subcomponent of a vector or matrix. The size of the uniform variable will be returned in $(D_INLINECODE size). Uniform variables other than arrays will have a size of 1. Structures and arrays of structures will be reduced as described earlier, such that each of the names returned will be a data type in the earlier list. If this reduction results in an array, the size returned will be as described for uniform arrays; otherwise, the size returned will be 1. The list of active uniform variables may include both built-in uniform variables (which begin with the prefix &quot;gl_&quot;) as well as user-defined uniform variable names. This function will return as much information as it can about the specified active uniform variable. If no information is available, $(D_INLINECODE length) will be 0, and $(D_INLINECODE name) will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values $(D_INLINECODE length), $(D_INLINECODE size), $(D_INLINECODE type), and $(D_INLINECODE name) will be unmodified.
     + 
     + The double types, $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_DOUBLE_VEC2), $(D_INLINECODE GL_DOUBLE_VEC3), $(D_INLINECODE GL_DOUBLE_VEC4), $(D_INLINECODE GL_DOUBLE_MAT2), $(D_INLINECODE GL_DOUBLE_MAT3), $(D_INLINECODE GL_DOUBLE_MAT4), $(D_INLINECODE GL_DOUBLE_MAT2x3), $(D_INLINECODE GL_DOUBLE_MAT2x4), $(D_INLINECODE GL_DOUBLE_MAT3x2), $(D_INLINECODE GL_DOUBLE_MAT3x4), $(D_INLINECODE GL_DOUBLE_MAT4x2), and $(D_INLINECODE GL_DOUBLE_MAT4x3) are only available if the GL version is 4.1 or higher. The image types, $(D_INLINECODE GL_IMAGE_1D), $(D_INLINECODE GL_IMAGE_2D), $(D_INLINECODE GL_IMAGE_3D), $(D_INLINECODE GL_IMAGE_2D_RECT), $(D_INLINECODE GL_IMAGE_CUBE), $(D_INLINECODE GL_IMAGE_BUFFER), $(D_INLINECODE GL_IMAGE_1D_ARRAY), $(D_INLINECODE GL_IMAGE_2D_ARRAY), $(D_INLINECODE GL_IMAGE_2D_MULTISAMPLE), $(D_INLINECODE GL_IMAGE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_INT_IMAGE_1D), $(D_INLINECODE GL_INT_IMAGE_2D), $(D_INLINECODE GL_INT_IMAGE_3D), $(D_INLINECODE GL_INT_IMAGE_2D_RECT), $(D_INLINECODE GL_INT_IMAGE_CUBE), $(D_INLINECODE GL_INT_IMAGE_BUFFER), $(D_INLINECODE GL_INT_IMAGE_1D_ARRAY), $(D_INLINECODE GL_INT_IMAGE_2D_ARRAY), $(D_INLINECODE GL_INT_IMAGE_2D_MULTISAMPLE), $(D_INLINECODE GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_1D), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_3D), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_RECT), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_CUBE), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_BUFFER), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_1D_ARRAY), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_ARRAY), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY), and the atomic counter type, $(D_INLINECODE GL_UNSIGNED_INT_ATOMIC_COUNTER) are only available if the GL version is 4.2 or higher.
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     index   = Specifies the index of the uniform variable to be queried.
     +     bufSize = Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by $(D_INLINECODE name).
     +     length  = Returns the number of characters actually written by OpenGL in the string indicated by $(D_INLINECODE name) (excluding the null terminator) if a value other than $(D_INLINECODE null) is passed.
     +     size    = Returns the size of the uniform variable.
     +     type    = Returns the data type of the uniform variable.
     +     name    = Returns a null terminated string containing the name of the uniform variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetUniform), $(D_INLINECODE glGetUniformLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) @system @nogc nothrow;

    /++
     + glGetActiveUniformBlock: man4/glGetActiveUniformBlock.xml
     + 
     + $(D_INLINECODE glGetActiveUniformBlockiv) retrieves information about an active uniform block within $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program object for which the command $(D_INLINECODE glLinkProgram) must have been called in the past, although it is not required that $(D_INLINECODE glLinkProgram) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformBlockIndex) is an active uniform block index of $(D_INLINECODE program), and must be less than the value of $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCKS). Upon success, the uniform block parameter(s) specified by $(D_INLINECODE pname) are returned in $(D_INLINECODE params). If an error occurs, nothing will be written to $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_BINDING), then the index of the uniform buffer binding point last selected by the uniform block specified by $(D_INLINECODE uniformBlockIndex) for $(D_INLINECODE program) is returned. If no uniform block has been previously specified, zero is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_DATA_SIZE), then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active uniforms in the uniform block identified by $(D_INLINECODE uniformBlockIndex) is returned. It is neither guaranteed nor expected that a given implementation will arrange uniform values as tightly packed in a buffer object. The exception to this is the, which guarantees specific packing behavior and does not require the application to query for offsets and strides. In this case the minimum size may still be queried, even though it is determined in advance based only on the uniform block declaration. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_NAME_LENGTH), then the total length (including the nul terminator) of the name of the uniform block identified by $(D_INLINECODE uniformBlockIndex) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS), then the number of active uniforms in the uniform block identified by $(D_INLINECODE uniformBlockIndex) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES), then a list of the active uniform indices for the uniform block identified by $(D_INLINECODE uniformBlockIndex) is returned. The number of elements that will be written to $(D_INLINECODE params) is the value of $(D_INLINECODE GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS) for $(D_INLINECODE uniformBlockIndex). If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER), $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER), $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER), $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER), or $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER) then a boolean value indicating whether the uniform block identified by $(D_INLINECODE uniformBlockIndex) is referenced by the vertex, tessellation control, tessellation evaluation, geometry, fragment or compute programming stages of program, respectively, is returned.
     + 
     + $(D_INLINECODE glGetActiveUniformBlockiv) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER) is accepted only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     program           = Specifies the name of a program containing the uniform block.
     +     uniformBlockIndex = Specifies the index of the uniform block within $(D_INLINECODE program).
     +     pname             = Specifies the name of the parameter to query.
     +     params            = Specifies the address of a variable to receive the result of the query.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniformBlockName), $(D_INLINECODE glGetUniformBlockIndex), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetActiveUniformBlockName: man4/glGetActiveUniformBlockName.xml
     + 
     + $(D_INLINECODE glGetActiveUniformBlockName) retrieves the name of the active uniform block at $(D_INLINECODE uniformBlockIndex) within $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program object for which the command $(D_INLINECODE glLinkProgram) must have been called in the past, although it is not required that $(D_INLINECODE glLinkProgram) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformBlockIndex) is an active uniform block index of $(D_INLINECODE program), and must be less than the value of $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCKS). Upon success, the name of the uniform block identified by $(D_INLINECODE unifomBlockIndex) is returned into $(D_INLINECODE uniformBlockName). The name is nul-terminated. The actual number of characters written into $(D_INLINECODE uniformBlockName), excluding the nul terminator, is returned in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. $(D_INLINECODE bufSize) contains the maximum number of characters (including the nul terminator) that will be written into $(D_INLINECODE uniformBlockName). If an error occurs, nothing will be written to $(D_INLINECODE uniformBlockName) or $(D_INLINECODE length).
     + 
     + $(D_INLINECODE glGetActiveUniformBlockName) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     program           = Specifies the name of a program containing the uniform block.
     +     uniformBlockIndex = Specifies the index of the uniform block within $(D_INLINECODE program).
     +     bufSize           = Specifies the size of the buffer addressed by $(D_INLINECODE uniformBlockName).
     +     length            = Specifies the address of a variable to receive the number of characters that were written to $(D_INLINECODE uniformBlockName).
     +     uniformBlockName  = Specifies the address an array of characters to receive the name of the uniform block at $(D_INLINECODE uniformBlockIndex).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniformBlock), $(D_INLINECODE glGetUniformBlockIndex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName) @system @nogc nothrow;

    /++
     + glGetActiveUniformName: man4/glGetActiveUniformName.xml
     + 
     + $(D_INLINECODE glGetActiveUniformName) returns the name of the active uniform at $(D_INLINECODE uniformIndex) within $(D_INLINECODE program). If $(D_INLINECODE uniformName) is not $(D_INLINECODE null
     + ), up to $(D_INLINECODE bufSize) characters (including a nul-terminator) will be written into the array whose address is specified by $(D_INLINECODE uniformName). If $(D_INLINECODE length) is not $(D_INLINECODE null
     + ), the number of characters that were (or would have been) written into $(D_INLINECODE uniformName) (not including the nul-terminator) will be placed in the variable whose address is specified in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. The length of the longest uniform name in $(D_INLINECODE program) is given by the value of $(D_INLINECODE GL_ACTIVE_UNIFORM_MAX_LENGTH), which can be queried with $(D_INLINECODE glGetProgram). If $(D_INLINECODE glGetActiveUniformName) is not successful, nothing is written to $(D_INLINECODE length) or $(D_INLINECODE uniformName). $(D_INLINECODE program) must be the name of a program for which the command $(D_INLINECODE glLinkProgram) has been issued in the past. It is not necessary for $(D_INLINECODE program) to have been linked successfully. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformIndex) must be an active uniform index of the program $(D_INLINECODE program), in the range zero to the value of $(D_INLINECODE GL_ACTIVE_UNIFORMS) minus one. The value of $(D_INLINECODE GL_ACTIVE_UNIFORMS) can be queried with $(D_INLINECODE glGetProgram).
     + 
     + Params:
     +     program      = Specifies the program containing the active uniform index $(D_INLINECODE uniformIndex).
     +     uniformIndex = Specifies the index of the active uniform whose name to query.
     +     bufSize      = Specifies the size of the buffer, in units of $(D_INLINECODE GLchar), of the buffer whose address is specified in $(D_INLINECODE uniformName).
     +     length       = Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by $(D_INLINECODE uniformName).
     +     uniformName  = Specifies the address of a buffer into which the GL will place the name of the active uniform at $(D_INLINECODE uniformIndex) within $(D_INLINECODE program).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetUniformIndices), $(D_INLINECODE glGetProgram), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName) @system @nogc nothrow;

    /++
     + glGetActiveUniformsiv: man4/glGetActiveUniformsiv.xml
     + 
     + $(D_INLINECODE glGetActiveUniformsiv) queries the value of the parameter named $(D_INLINECODE pname) for each of the uniforms within $(D_INLINECODE program) whose indices are specified in the array of $(D_INLINECODE uniformCount) unsigned integers $(D_INLINECODE uniformIndices). Upon success, the value of the parameter for each uniform is written into the corresponding entry in the array whose address is given in $(D_INLINECODE params). If an error is generated, nothing is written into $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_TYPE), then an array identifying the types of uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. The returned types can be any of the values from the following table: $(B Returned Symbolic Contant) $(B Shader Uniform Type) $(D_INLINECODE GL_FLOAT) $(D_INLINECODE float) $(D_INLINECODE GL_FLOAT_VEC2) $(D_INLINECODE vec2) $(D_INLINECODE GL_FLOAT_VEC3) $(D_INLINECODE vec3) $(D_INLINECODE GL_FLOAT_VEC4) $(D_INLINECODE vec4) $(D_INLINECODE GL_DOUBLE) $(D_INLINECODE double) $(D_INLINECODE GL_DOUBLE_VEC2) $(D_INLINECODE dvec2) $(D_INLINECODE GL_DOUBLE_VEC3) $(D_INLINECODE dvec3) $(D_INLINECODE GL_DOUBLE_VEC4) $(D_INLINECODE dvec4) $(D_INLINECODE GL_INT) $(D_INLINECODE int) $(D_INLINECODE GL_INT_VEC2) $(D_INLINECODE ivec2) $(D_INLINECODE GL_INT_VEC3) $(D_INLINECODE ivec3) $(D_INLINECODE GL_INT_VEC4) $(D_INLINECODE ivec4) $(D_INLINECODE GL_UNSIGNED_INT) $(D_INLINECODE unsigned int) $(D_INLINECODE GL_UNSIGNED_INT_VEC2) $(D_INLINECODE uvec2) $(D_INLINECODE GL_UNSIGNED_INT_VEC3) $(D_INLINECODE uvec3) $(D_INLINECODE GL_UNSIGNED_INT_VEC4) $(D_INLINECODE uvec4) $(D_INLINECODE GL_BOOL) $(D_INLINECODE bool) $(D_INLINECODE GL_BOOL_VEC2) $(D_INLINECODE bvec2) $(D_INLINECODE GL_BOOL_VEC3) $(D_INLINECODE bvec3) $(D_INLINECODE GL_BOOL_VEC4) $(D_INLINECODE bvec4) $(D_INLINECODE GL_FLOAT_MAT2) $(D_INLINECODE mat2) $(D_INLINECODE GL_FLOAT_MAT3) $(D_INLINECODE mat3) $(D_INLINECODE GL_FLOAT_MAT4) $(D_INLINECODE mat4) $(D_INLINECODE GL_FLOAT_MAT2x3) $(D_INLINECODE mat2x3) $(D_INLINECODE GL_FLOAT_MAT2x4) $(D_INLINECODE mat2x4) $(D_INLINECODE GL_FLOAT_MAT3x2) $(D_INLINECODE mat3x2) $(D_INLINECODE GL_FLOAT_MAT3x4) $(D_INLINECODE mat3x4) $(D_INLINECODE GL_FLOAT_MAT4x2) $(D_INLINECODE mat4x2) $(D_INLINECODE GL_FLOAT_MAT4x3) $(D_INLINECODE mat4x3) $(D_INLINECODE GL_DOUBLE_MAT2) $(D_INLINECODE dmat2) $(D_INLINECODE GL_DOUBLE_MAT3) $(D_INLINECODE dmat3) $(D_INLINECODE GL_DOUBLE_MAT4) $(D_INLINECODE dmat4) $(D_INLINECODE GL_DOUBLE_MAT2x3) $(D_INLINECODE dmat2x3) $(D_INLINECODE GL_DOUBLE_MAT2x4) $(D_INLINECODE dmat2x4) $(D_INLINECODE GL_DOUBLE_MAT3x2) $(D_INLINECODE dmat3x2) $(D_INLINECODE GL_DOUBLE_MAT3x4) $(D_INLINECODE dmat3x4) $(D_INLINECODE GL_DOUBLE_MAT4x2) $(D_INLINECODE dmat4x2) $(D_INLINECODE GL_DOUBLE_MAT4x3) $(D_INLINECODE dmat4x3) $(D_INLINECODE GL_SAMPLER_1D) $(D_INLINECODE sampler1D) $(D_INLINECODE GL_SAMPLER_2D) $(D_INLINECODE sampler2D) $(D_INLINECODE GL_SAMPLER_3D) $(D_INLINECODE sampler3D) $(D_INLINECODE GL_SAMPLER_CUBE) $(D_INLINECODE samplerCube) $(D_INLINECODE GL_SAMPLER_1D_SHADOW) $(D_INLINECODE sampler1DShadow) $(D_INLINECODE GL_SAMPLER_2D_SHADOW) $(D_INLINECODE sampler2DShadow) $(D_INLINECODE GL_SAMPLER_1D_ARRAY) $(D_INLINECODE sampler1DArray) $(D_INLINECODE GL_SAMPLER_2D_ARRAY) $(D_INLINECODE sampler2DArray) $(D_INLINECODE GL_SAMPLER_1D_ARRAY_SHADOW) $(D_INLINECODE sampler1DArrayShadow) $(D_INLINECODE GL_SAMPLER_2D_ARRAY_SHADOW) $(D_INLINECODE sampler2DArrayShadow) $(D_INLINECODE GL_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE sampler2DMS) $(D_INLINECODE GL_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE sampler2DMSArray) $(D_INLINECODE GL_SAMPLER_CUBE_SHADOW) $(D_INLINECODE samplerCubeShadow) $(D_INLINECODE GL_SAMPLER_BUFFER) $(D_INLINECODE samplerBuffer) $(D_INLINECODE GL_SAMPLER_2D_RECT) $(D_INLINECODE sampler2DRect) $(D_INLINECODE GL_SAMPLER_2D_RECT_SHADOW) $(D_INLINECODE sampler2DRectShadow) $(D_INLINECODE GL_INT_SAMPLER_1D) $(D_INLINECODE isampler1D) $(D_INLINECODE GL_INT_SAMPLER_2D) $(D_INLINECODE isampler2D) $(D_INLINECODE GL_INT_SAMPLER_3D) $(D_INLINECODE isampler3D) $(D_INLINECODE GL_INT_SAMPLER_CUBE) $(D_INLINECODE isamplerCube) $(D_INLINECODE GL_INT_SAMPLER_1D_ARRAY) $(D_INLINECODE isampler1DArray) $(D_INLINECODE GL_INT_SAMPLER_2D_ARRAY) $(D_INLINECODE isampler2DArray) $(D_INLINECODE GL_INT_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE isampler2DMS) $(D_INLINECODE GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE isampler2DMSArray) $(D_INLINECODE GL_INT_SAMPLER_BUFFER) $(D_INLINECODE isamplerBuffer) $(D_INLINECODE GL_INT_SAMPLER_2D_RECT) $(D_INLINECODE isampler2DRect) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_1D) $(D_INLINECODE usampler1D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D) $(D_INLINECODE usampler2D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_3D) $(D_INLINECODE usampler3D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_CUBE) $(D_INLINECODE usamplerCube) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_1D_ARRAY) $(D_INLINECODE usampler2DArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_ARRAY) $(D_INLINECODE usampler2DArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE usampler2DMS) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE usampler2DMSArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_BUFFER) $(D_INLINECODE usamplerBuffer) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_RECT) $(D_INLINECODE usampler2DRect) If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_SIZE), then an array identifying the size of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. The sizes returned are in units of the type returned by a query of $(D_INLINECODE GL_UNIFORM_TYPE). For active uniforms that are arrays, the size is the number of active elements in the array; for all other uniforms, the size is one. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_NAME_LENGTH), then an array identifying the length, including the terminating null character, of the uniform name strings specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_INDEX), then an array identifying the the uniform block index of each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. The uniform block index of a uniform associated with the default uniform block is -1. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_OFFSET), then an array of uniform buffer offsets is returned. For uniforms in a named uniform block, the returned value will be its offset, in basic machine units, relative to the beginning of the uniform block in the buffer object data store. For atomic counter uniforms, the returned value will be its offset relative to the beginning of its active atomic counter buffer. For all other uniforms, -1 will be returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_ARRAY_STRIDE), then an array identifying the stride between elements of each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. For uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the difference, in basic machine units, of consecutive elements in an array, or zero for uniforms not declared as an array. For all other uniforms, a stride of -1 will be returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_MATRIX_STRIDE), then an array identifying the stride between columns of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. The matrix stride of a uniform associated with the default uniform block is -1. Note that this information only makes sense for uniforms that are matrices. For uniforms that are not matrices, but are declared in a named uniform block, a matrix stride of zero is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_IS_ROW_MAJOR), then an array identifying whether each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is a row-major matrix or not is returned. A value of one indicates a row-major matrix, and a value of zero indicates a column-major matrix, a matrix in the default uniform block, or a non-matrix. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX), then an array identifying the active atomic counter buffer index of each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. For uniforms other than atomic counters, the returned buffer index is -1. The returned indices may be passed to $(D_INLINECODE glGetActiveAtomicCounterBufferiv) to query the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.
     + 
     + The double types, $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_DOUBLE_VEC2), $(D_INLINECODE GL_DOUBLE_VEC3), $(D_INLINECODE GL_DOUBLE_VEC4), $(D_INLINECODE GL_DOUBLE_MAT2), $(D_INLINECODE GL_DOUBLE_MAT3), $(D_INLINECODE GL_DOUBLE_MAT4), $(D_INLINECODE GL_DOUBLE_MAT2x3), $(D_INLINECODE GL_DOUBLE_MAT2x4), $(D_INLINECODE GL_DOUBLE_MAT3x2), $(D_INLINECODE GL_DOUBLE_MAT3x4), $(D_INLINECODE GL_DOUBLE_MAT4x2), and $(D_INLINECODE GL_DOUBLE_MAT4x3) are only available if the GL version is 4.1 or higher. $(D_INLINECODE GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX) is only accepted by $(D_INLINECODE pname) if the GL version is 4.2 or higher.
     + 
     + Params:
     +     program        = Specifies the program object to be queried.
     +     uniformCount   = Specifies both the number of elements in the array of indices $(D_INLINECODE uniformIndices) and the number of parameters written to $(D_INLINECODE params) upon successful return.
     +     uniformIndices = Specifies the address of an array of $(D_INLINECODE uniformCount) integers containing the indices of uniforms within $(D_INLINECODE program) whose parameter $(D_INLINECODE pname) should be queried.
     +     pname          = Specifies the property of each uniform in $(D_INLINECODE uniformIndices) that should be written into the corresponding element of $(D_INLINECODE params).
     +     params         = Specifies the address of an array of $(D_INLINECODE uniformCount) integers which are to receive the value of $(D_INLINECODE pname) for each uniform in $(D_INLINECODE uniformIndices).
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetUniform), $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetUniformLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetAttachedShaders: man4/glGetAttachedShaders.xml
     + 
     + $(D_INLINECODE glGetAttachedShaders) returns the names of the shader objects attached to $(D_INLINECODE program). The names of shader objects that are attached to $(D_INLINECODE program) will be returned in $(D_INLINECODE shaders.) The actual number of shader names written into $(D_INLINECODE shaders) is returned in $(D_INLINECODE count.) If no shader objects are attached to $(D_INLINECODE program), $(D_INLINECODE count) is set to 0. The maximum number of shader names that may be returned in $(D_INLINECODE shaders) is specified by $(D_INLINECODE maxCount). If the number of names actually returned is not required (for instance, if it has just been obtained by calling $(D_INLINECODE glGetProgram) ), a value of $(D_INLINECODE null
     + ) may be passed for count. If no shader objects are attached to $(D_INLINECODE program), a value of 0 will be returned in $(D_INLINECODE count). The actual number of attached shaders can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ATTACHED_SHADERS).
     + 
     + Params:
     +     program  = Specifies the program object to be queried.
     +     maxCount = Specifies the size of the array for storing the returned object names.
     +     count    = Returns the number of names actually returned in $(D_INLINECODE shaders).
     +     shaders  = Specifies an array that is used to return the names of attached shader objects.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glDetachShader).
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders) @system @nogc nothrow;

    /++
     + glGetAttribLocation: man4/glGetAttribLocation.xml
     + 
     + $(D_INLINECODE glGetAttribLocation) queries the previously linked program object specified by $(D_INLINECODE program) for the attribute variable specified by $(D_INLINECODE name) and returns the index of the generic vertex attribute that is bound to that attribute variable. If $(D_INLINECODE name) is a matrix attribute variable, the index of the first column of the matrix is returned. If the named attribute variable is not an active attribute in the specified program object or if $(D_INLINECODE name) starts with the reserved prefix &quot;gl_&quot;, a value of -1 is returned. The association between an attribute variable name and a generic attribute index can be specified at any time by calling $(D_INLINECODE glBindAttribLocation). Attribute bindings do not go into effect until $(D_INLINECODE glLinkProgram) is called. After a program object has been linked successfully, the index values for attribute variables remain fixed until the next link command occurs. The attribute values can only be queried after a link if the link was successful. $(D_INLINECODE glGetAttribLocation) returns the binding that actually went into effect the last time $(D_INLINECODE glLinkProgram) was called for the specified program object. Attribute bindings that have been specified since the last link operation are not returned by $(D_INLINECODE glGetAttribLocation).
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     name    = Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLint glGetAttribLocation(GLuint program, const GLchar* name) @system @nogc nothrow;

    /++
     + glGetBufferParameter: man4/glGetBufferParameter.xml
     + 
     + These functions return in $(D_INLINECODE data) a selected parameter of the specified buffer object. $(D_INLINECODE pname) names a specific buffer object parameter, as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE data). The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glGetBufferParameteriv) and $(D_INLINECODE glGetBufferParameteri64v). Must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glGetNamedBufferParameteriv) and $(D_INLINECODE glGetNamedBufferParameteri64v).
     +     value  = Specifies the name of the buffer object parameter to query.
     +     data   = Returns the requested parameter.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glGetBufferPointerv), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetBufferParameteriv(GLenum target, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64* params) @system @nogc nothrow;

    /++
     + glGetBufferPointerv: man4/glGetBufferPointerv.xml
     + 
     + $(D_INLINECODE glGetBufferPointerv) and $(D_INLINECODE glGetNamedBufferPointerv) return the buffer pointer $(D_INLINECODE pname), which must be $(D_INLINECODE GL_BUFFER_MAP_POINTER). The single buffer map pointer is returned in $(D_INLINECODE params). A $(D_INLINECODE null
     + ) pointer is returned if the buffer object's data store is not currently mapped; or if the requesting context did not map the buffer object's data store, and the implementation is unable to support mappings on multiple clients.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). The initial value for the pointer is $(D_INLINECODE null
     + ). The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glGetBufferPointerv), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glGetNamedBufferPointerv).
     +     pname  = Specifies the name of the pointer to be returned. Must be $(D_INLINECODE GL_BUFFER_MAP_POINTER).
     +     params = Returns the pointer value specified by $(D_INLINECODE pname).
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glMapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void** params) @system @nogc nothrow;

    /++
     + glGetBufferSubData: man4/glGetBufferSubData.xml
     + 
     + $(D_INLINECODE glGetBufferSubData) and $(D_INLINECODE glGetNamedBufferSubData) return some or all of the data contents of the data store of the specified buffer object. Data starting at byte offset $(D_INLINECODE offset) and extending for $(D_INLINECODE size) bytes is copied from the buffer object's data store to the memory pointed to by $(D_INLINECODE data). An error is thrown if the buffer object is currently mapped, or if $(D_INLINECODE offset) and $(D_INLINECODE size) together define a range beyond the bounds of the buffer object's data store.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE data). The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glGetBufferSubData), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glGetNamedBufferSubData).
     +     offset = Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
     +     size   = Specifies the size in bytes of the data store region being returned.
     +     data   = Specifies a pointer to the location where buffer object data is returned.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizei size, void* data) @system @nogc nothrow;

    /++
     + glGetCompressedTexImage: man4/glGetCompressedTexImage.xml
     + 
     + $(D_INLINECODE glGetCompressedTexImage) and $(D_INLINECODE glGetnCompressedTexImage) return the compressed texture image associated with $(D_INLINECODE target) and $(D_INLINECODE lod) into $(D_INLINECODE pixels). $(D_INLINECODE glGetCompressedTextureImage) serves the same purpose, but instead of taking a texture target, it takes the ID of the texture object. $(D_INLINECODE pixels) should be an array of $(D_INLINECODE bufSize) bytes for $(D_INLINECODE glGetnCompresedTexImage) and $(D_INLINECODE glGetCompressedTextureImage) functions, and of $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE) bytes in case of $(D_INLINECODE glGetCompressedTexImage). If the actual data takes less space than $(D_INLINECODE bufSize), the remaining bytes will not be touched. $(D_INLINECODE target) specifies the texture target, to which the texture the data the function should extract the data from is bound to. $(D_INLINECODE lod) specifies the level-of-detail number of the desired image. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is requested, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store. To minimize errors, first verify that the texture is compressed by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_COMPRESSED). If the texture is compressed, you can determine the amount of memory required to store the compressed texture by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE). Finally, retrieve the internal format of the texture by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_INTERNAL_FORMAT). To store the texture for later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective texture or subtexture loading routine used for loading $(D_INLINECODE target) textures.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glGetCompressedTexImage) and $(D_INLINECODE glGetnCompressedTexImage) functions. $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), and $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), $(D_INLINECODE GL_TEXTURE_RECTANGLE) are accepted.
     +     texture = Specifies the texture object name for $(D_INLINECODE glGetCompressedTextureImage) function.
     +     level   = Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.
     +     bufSize = Specifies the size of the buffer $(D_INLINECODE pixels) for $(D_INLINECODE glGetCompressedTextureImage) and $(D_INLINECODE glGetnCompressedTexImage) functions.
     +     pixels  = Returns the compressed texture image.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glGetCompressedTexImage(GLenum target, GLint level, GLvoid* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void* pixels) @system @nogc nothrow;

    /++
     + glGetCompressedTextureSubImage: man4/glGetCompressedTextureSubImage.xml
     + 
     + $(D_INLINECODE glGetCompressedTextureSubImage) can be used to obtain a sub-region of a compressed texture image instead of the whole image, as long as the compressed data are arranged into fixed-size blocks of texels. $(D_INLINECODE texture) is the name of the texture object, and must not be a buffer or multisample texture. The effective $(D_INLINECODE target) is the value of $(D_INLINECODE GL_TEXTURE_TARGET) for texture. $(D_INLINECODE level) and $(D_INLINECODE pixels) have the same meaning as the corresponding arguments of $(D_INLINECODE glCompressedTexSubImage3D). $(D_INLINECODE bufSize) indicates the size of the buffer to receive the retrieved pixel data. For cube map textures, the behavior is as though $(D_INLINECODE glGetCompressedTexImage) were called once for each requested face (selected by $(D_INLINECODE zoffset) and $(D_INLINECODE depth), as described below) with target corresponding to the requested texture cube map face as indicated by the table presented below. $(D_INLINECODE pixels) is offset appropriately for each successive image. Layer number Cube Map Face 0 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X) 1 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X) 2 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y) 3 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y) 4 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z) 5 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z) $(D_INLINECODE xoffset), $(D_INLINECODE yoffset) and $(D_INLINECODE zoffset) indicate the position of the subregion to return. $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) indicate the size of the region to return. These arguments have the same meaning as for $(D_INLINECODE glCompressedTexSubImage3D), though there are extra restrictions, described in the errors section below. The mapping between the $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset), $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) parameters and the faces, layers, and layer-faces for cube map, array, and cube map array textures is the same as for glGetTextureSubImage. The $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset) offsets and $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) sizes must be multiples of the values of $(D_INLINECODE GL_PACK_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_PACK_COMPRESSED_BLOCK_HEIGHT), and $(D_INLINECODE GL_PACK_COMPRESSED_BLOCK_DEPTH) respectively, unless $(D_INLINECODE offset) is zero and the corresponding $(D_INLINECODE size) is the same as the texture size in that dimension. Pixel storage modes are treated as for $(D_INLINECODE glGetCompressedTexSubImage). The texel at ( $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset) ) will be stored at the location indicated by $(D_INLINECODE pixels) and the current pixel packing parameters.
     + 
     + Params:
     +     texture = Specifies the name of the source texture object. Must be $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) or $(D_INLINECODE GL_TEXTURE_RECTANGLE). In specific, buffer and multisample textures are not permitted.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     zoffset = Specifies a texel offset in the z direction within the texture array.
     +     width   = Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the $(D_INLINECODE offset) is zero and the size equals the texture image size.
     +     height  = Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the $(D_INLINECODE offset) is zero and the size equals the texture image size.
     +     depth   = Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the $(D_INLINECODE offset) is zero and the size equals the texture image size.
     +     bufSize = Specifies the size of the buffer to receive the retrieved pixel data.
     +     pixels  = Returns the texture subimage. Should be a pointer to an array of the type specified by type.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glGetCompressedTextureImage), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_get_texture_sub_image")
    void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void* pixels) @system @nogc nothrow;

    /++
     + glGetDebugMessageLog: man4/glGetDebugMessageLog.xml
     + 
     + $(D_INLINECODE glGetDebugMessageLog) retrieves messages from the debug message log. A maximum of $(D_INLINECODE count) messages are retrieved from the log. If $(D_INLINECODE sources) is not null then the source of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. If $(D_INLINECODE types) is not null then the type of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. If $(D_INLINECODE id) is not null then the identifier of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. If $(D_INLINECODE severities) is not null then the severity of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. If $(D_INLINECODE lengths) is not null then the length of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. $(D_INLINECODE messageLog) specifies the address of a character array into which the debug messages will be written. Each message will be concatenated onto the array starting at the first element of $(D_INLINECODE messageLog). $(D_INLINECODE bufSize) specifies the size of the array $(D_INLINECODE messageLog). If a message will not fit into the remaining space in $(D_INLINECODE messageLog) then the function terminates and returns the number of messages written so far, which may be zero. If $(D_INLINECODE glGetDebugMessageLog) returns zero then no messages are present in the debug log, or there was not enough space in $(D_INLINECODE messageLog) to retrieve the first message in the queue. If $(D_INLINECODE messageLog) is null then no messages are written and the value of
     +  $(D_INLINECODE bufSize) is ignored.
     + 
     + Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug context may produce no messages at all.
     + 
     + Params:
     +     count      = The number of debug messages to retrieve from the log.
     +     bufSize    = The size of the buffer whose address is given by $(D_INLINECODE messageLog).
     +     sources    = The address of an array of variables to receive the sources of the retrieved messages.
     +     types      = The address of an array of variables to receive the types of the retrieved messages.
     +     ids        = The address of an array of unsigned integers to receive the ids of the retrieved messages.
     +     severities = The address of an array of variables to receive the severites of the retrieved messages.
     +     lengths    = The address of an array of variables to receive the lengths of the received messages.
     +     messageLog = The address of an array of characters that will receive the messages.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageInsert), $(D_INLINECODE glDebugMessageCallback), $(D_INLINECODE glDebugMessageControl).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;

    /++
     + glGetError: man4/glGetError.xml
     + 
     + $(D_INLINECODE glGetError) returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until $(D_INLINECODE glGetError) is called, the error code is returned, and the flag is reset to $(D_INLINECODE GL_NO_ERROR). If a call to $(D_INLINECODE glGetError) returns $(D_INLINECODE GL_NO_ERROR), there has been no detectable error since the last call to $(D_INLINECODE glGetError), or since the GL was initialized. To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to $(D_INLINECODE GL_NO_ERROR) when $(D_INLINECODE glGetError) is called. If more than one flag has recorded an error, $(D_INLINECODE glGetError) returns and clears an arbitrary error flag value. Thus, $(D_INLINECODE glGetError) should always be called in a loop, until it returns $(D_INLINECODE GL_NO_ERROR), if all error flags are to be reset. Initially, all error flags are set to $(D_INLINECODE GL_NO_ERROR). The following errors are currently defined: When an error flag is set, results of a GL operation are undefined only if $(D_INLINECODE GL_OUT_OF_MEMORY) has occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating command returns a value, it returns 0. If $(D_INLINECODE glGetError) itself generates an error, it returns 0.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLenum glGetError() @system @nogc nothrow;

    /++
     + glGetFragDataIndex: man4/glGetFragDataIndex.xml
     + 
     + $(D_INLINECODE glGetFragDataIndex) returns the index of the fragment color to which the variable $(D_INLINECODE name) was bound when the program object $(D_INLINECODE program) was last linked. If $(D_INLINECODE name) is not a varying out variable of $(D_INLINECODE program), or if an error occurs, -1 will be returned.
     + 
     + $(D_INLINECODE glGetFragDataIndex) is available only if the GL version is 3.3 or greater.
     + 
     + Params:
     +     program = The name of the program containing varying out variable whose binding to query
     +     name    = The name of the user-defined varying out variable whose index to query
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glBindFragDataLocation), $(D_INLINECODE glBindFragDataLocationIndexed), $(D_INLINECODE glGetFragDataLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_blend_func_extended")
    GLint glGetFragDataIndex(GLuint program, const char* name) @system @nogc nothrow;

    /++
     + glGetFragDataLocation: man4/glGetFragDataLocation.xml
     + 
     + $(D_INLINECODE glGetFragDataLocation) retrieves the assigned color number binding for the user-defined varying out variable $(D_INLINECODE name) for program $(D_INLINECODE program). $(D_INLINECODE program) must have previously been linked. $(D_INLINECODE name) must be a null-terminated string. If $(D_INLINECODE name) is not the name of an active user-defined varying out fragment shader variable within $(D_INLINECODE program), -1 will be returned.
     + 
     + Params:
     +     program = The name of the program containing varying out variable whose binding to query
     +     name    = The name of the user-defined varying out variable whose binding to query
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glBindFragDataLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    GLint glGetFragDataLocation(GLuint program, const char* name) @system @nogc nothrow;

    /++
     + glGetFramebufferAttachmentParameter: man4/glGetFramebufferAttachmentParameter.xml
     + 
     + $(D_INLINECODE glGetFramebufferAttachmentParameteriv) and $(D_INLINECODE glGetNamedFramebufferAttachmentParameteriv) return parameters of attachments of a specified framebuffer object. For $(D_INLINECODE glGetFramebufferAttachmentParameteriv), the framebuffer object is that bound to $(D_INLINECODE target), which must be one of $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). Buffers of default framebuffers may also be queried if bound to $(D_INLINECODE target). For $(D_INLINECODE glGetNamedFramebufferAttachmentParameteriv), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, the default draw framebuffer is queried. If the specified framebuffer is a framebuffer object, $(D_INLINECODE attachment) must be one of $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT), or $(D_INLINECODE GL_COLOR_ATTACHMENT), where is between zero and the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. If the specified framebuffer is a default framebuffer, $(D_INLINECODE target), $(D_INLINECODE attachment) must be one of $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_DEPTH) or $(D_INLINECODE GL_STENCIL), identifying the corresponding buffer. If $(D_INLINECODE attachment) is $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT), the same object must be bound to both the depth and stencil attachment points of the framebuffer object, and information about that object is returned. Upon successful return, if $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE), then $(D_INLINECODE params) will contain one of $(D_INLINECODE GL_NONE), $(D_INLINECODE GL_FRAMEBUFFER_DEFAULT), $(D_INLINECODE GL_TEXTURE), or $(D_INLINECODE GL_RENDERBUFFER), identifying the type of object which contains the attached image. Other values accepted for $(D_INLINECODE pname) depend on the type of object, as described below. If the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_NONE), then either no framebuffer is bound to $(D_INLINECODE target); or a default framebuffer is queried, $(D_INLINECODE attachment) is $(D_INLINECODE GL_DEPTH) or $(D_INLINECODE GL_STENCIL), and the number of depth or stencil bits, respectively, is zero. In this case querying $(D_INLINECODE pname) $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) will return zero, and all other queries will generate an error. If the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is not $(D_INLINECODE GL_NONE), these queries apply to all other framebuffer types: $(OL $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE), $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE), $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE), $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE), $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE) or $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE), then $(D_INLINECODE params) will contain the number of bits in the corresponding red, green, blue, alpha, depth, or stencil component of the specified attachment. If the requested component is not present in the attachment, or if no data storage or texture image has been specified for the attachment, then $(D_INLINECODE params) will contain zero.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE), then $(D_INLINECODE params) will contain the format of components of the specified attachment, one of $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_SIGNED_NORMALIZED), or $(D_INLINECODE GL_UNSIGNED_NORMALIZED) for floating-point, signed integer, unsigned integer, signed normalized fixed-point, or unsigned normalized fixed-point components respectively. Only color buffers may have integer components. If no data storage or texture image has been specified for the attachment, then $(D_INLINECODE params) will contain $(D_INLINECODE GL_NONE). This query cannot be performed for a combined depth+stencil attachment, since it does not have a single format.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING), then $(D_INLINECODE params) will contain the encoding of components of the specified attachment, one of $(D_INLINECODE GL_LINEAR) or $(D_INLINECODE GL_SRGB) for linear or sRGB-encoded components, respectively. Only color buffer components may be sRGB-encoded; such components are treated as described in the OpenGL Specification. For a default framebuffer, color encoding is determined by the implementation. For framebuffer objects, components are sRGB-encoded if the internal format of a color attachment is one of the color-renderable SRGB formats. If the attachment is not a color attachment, or if no data storage or texture image has been specified for the attachment, then $(D_INLINECODE params) will contain $(D_INLINECODE GL_LINEAR).)) If the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_RENDERBUFFER), then $(OL $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME), $(D_INLINECODE params) will contain the name of the renderbuffer object which contains the attached image.)) If the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_TEXTURE), then $(OL $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME), then $(D_INLINECODE params) will contain the name of the texture object which contains the attached image.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL), then $(D_INLINECODE params) will contain the mipmap level of the texture object which contains the attached image.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE) and the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) is the name of a cube map texture object, then $(D_INLINECODE params) will contain the cube map face of the cubemap texture object which contains the attached image. Otherwise $(D_INLINECODE params) will contain zero.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_LAYERED), then $(D_INLINECODE params) will contain $(D_INLINECODE GL_TRUE) if an entire level of a three-dimensional texture, cube map texture, or one-or two-dimensional array texture is attached. Otherwise, $(D_INLINECODE params) will contain $(D_INLINECODE GL_FALSE).) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER); the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) is the name of a three-dimensional, or a one- or two-dimensional array texture; and the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_LAYERED) is $(D_INLINECODE GL_FALSE), then $(D_INLINECODE params) will contain the texture layer which contains the attached image. Otherwise $(D_INLINECODE params) will contain zero.))
     + 
     + The $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_LAYERED) query is supported only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer object is bound for $(D_INLINECODE glGetFramebufferAttachmentParameteriv).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glGetNamedFramebufferAttachmentParameteriv).
     +     attachment  = Specifies the attachment of the framebuffer object to query.
     +     pname       = Specifies the parameter of $(D_INLINECODE attachment) to query.
     +     params      = Returns the value of parameter $(D_INLINECODE pname) for $(D_INLINECODE attachment).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer) $(D_INLINECODE glGetFramebufferParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetFramebufferParameter: man4/glGetFramebufferParameter.xml
     + 
     + $(D_INLINECODE glGetFramebufferParameteriv) and $(D_INLINECODE glGetNamedFramebufferParameteriv) query parameters of a specified framebuffer object. For $(D_INLINECODE glGetFramebufferParameteriv), the framebuffer object is that bound to $(D_INLINECODE target), which must be one of $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). Default framebuffers may also be queried if bound to $(D_INLINECODE target). For $(D_INLINECODE glGetNamedFramebufferParameteriv), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, the default draw framebuffer is queried. Upon successful return, $(D_INLINECODE param) will contain the value of the framebuffer parameter specified by $(D_INLINECODE pname), as described below. The following parameters can only be queried for framebuffer objects: The following parameters can be queried for both default framebuffers and framebuffer objects:
     + 
     + Queries of default framebuffers are supported only if the GL version is 4.5 or higher. Otherwise, an $(D_INLINECODE GL_INVALID_OPERATION) error is generated. Queries of the framebuffer-dependent parameters $(D_INLINECODE GL_DOUBLEBUFFER), $(D_INLINECODE GL_IMPLEMENTATION_COLOR_READ_FORMAT), $(D_INLINECODE GL_IMPLEMENTATION_COLOR_READ_TYPE), $(D_INLINECODE GL_SAMPLES), $(D_INLINECODE GL_SAMPLE_BUFFERS) and $(D_INLINECODE GL_STEREO) are supported only if the GL version is 4.5 or higher. The framebuffer-dependent state $(D_INLINECODE GL_SAMPLE_POSITION) cannot be queried with these commands.
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer object is bound for $(D_INLINECODE glGetFramebufferParameteriv).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glGetNamedFramebufferParameteriv).
     +     pname       = Specifies the parameter of the framebuffer object to query.
     +     params      = Returns the value of parameter $(D_INLINECODE pname) for the framebuffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFramebufferParameteri), $(D_INLINECODE glGetFramebufferAttachmentParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_framebuffer_no_attachments")
    void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint* param) @system @nogc nothrow;

    /++
     + glGetGraphicsResetStatus: man4/glGetGraphicsResetStatus.xml
     + 
     + Certain events can result in a reset of the GL context. Such a reset causes all context state to be lost and requires the application to recreate all objects in the affected context. $(D_INLINECODE glGetGraphicsResetStatus) can return one of the following constants: If a reset status other than $(D_INLINECODE GL_NO_ERROR) is returned and subsequent calls return $(D_INLINECODE GL_NO_ERROR), the context reset was encountered and completed. If a reset status is repeatedly returned, the context may be in the process of resetting. Reset notification behavior is determined at context creation time, and may be queried by calling $(D_INLINECODE GetIntegerv) with the symbolic constant $(D_INLINECODE GL_RESET_NOTIFICATION_STRATEGY). If the reset notification behavior is $(D_INLINECODE GL_NO_RESET_NOTIFICATION), then the implementation will never deliver notification of reset events, and $(D_INLINECODE glGetGraphicsResetStatus) will always return $(D_INLINECODE GL_NO_ERROR). If the behavior is $(D_INLINECODE GL_LOSE_CONTEXT_ON_RESET), a graphics reset will result in the loss of all context state, requiring the recreation of all associated objects. In this case $(D_INLINECODE glGetGraphicsResetStatus) may return any of the values described above. If a graphics reset notification occurs in a context, a notification must also occur in all other contexts which share objects with that context. After a graphics reset has occurred on a context, subsequent GL commands on that context (or any context which shares with that context) will generate a $(D_INLINECODE GL_CONTEXT_LOST) error. Such commands will not have side effects (in particular, they will not modify memory passed by pointer for query results), and will not block indefinitely or cause termination of the application. There are two important exceptions to this behavior: $(OL $(LI $(D_INLINECODE glGetError) and $(D_INLINECODE glGetGraphicsResetStatus) behave normally following a graphics reset, so that the application can determine a reset has occurred, and when it is safe to destroy and re-create the context.) $(LI Any commands which might cause a polling application to block indefinitely will generate a $(D_INLINECODE GL_CONTEXT_LOST) error, but will also return a value indicating completion to the application. Such commands include: $(OL $(LI $(D_INLINECODE glGetSynciv) with pname $(D_INLINECODE GL_SYNC_STATUS) ignores the other parameters and returns $(D_INLINECODE GL_SIGNALED) in $(D_INLINECODE values).) $(LI $(D_INLINECODE glGetQueryObjectuiv) with pname $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE) ignores the other parameters and returns $(D_INLINECODE TRUE) in $(D_INLINECODE params).))))
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetError) $(D_INLINECODE glGetIntegerv), $(D_INLINECODE glGetQueryObjectuiv) $(D_INLINECODE glGetSynciv)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    GLenum glGetGraphicsResetStatus() @system @nogc nothrow;

    /++
     + glGetInternalformat: man4/glGetInternalformat.xml
     + 
     + $(D_INLINECODE glGetInternalformativ) and $(D_INLINECODE glGetInternalformati64v) retrieve information about implementation-dependent support for internal formats. $(D_INLINECODE target) indicates the target with which the internal format will be used and must be one of $(D_INLINECODE GL_RENDERBUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), corresponding to usage as a renderbuffer, two-dimensional multisample texture or two-dimensional multisample array texture, respectively. $(D_INLINECODE internalformat) specifies the internal format about which to retrieve information and must be a color-renderable, depth-renderable or stencil-renderable format. The information retrieved will be written to memory addressed by the pointer specified in $(D_INLINECODE params). No more than $(D_INLINECODE bufSize) basic machine units will be written to this memory. If $(D_INLINECODE pname) is $(D_INLINECODE GL_NUM_SAMPLE_COUNTS), the number of sample counts that would be returned by querying $(D_INLINECODE GL_SAMPLES) will be returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_SAMPLES), the sample counts supported for $(D_INLINECODE internalformat) and $(D_INLINECODE target) are written into $(D_INLINECODE params) in descending numeric order. Only positive values are returned. Querying $(D_INLINECODE GL_SAMPLES) with $(D_INLINECODE bufSize) of one will return just the maximum supported number of samples for this format. The maximum value in $(D_INLINECODE GL_SAMPLES) is guaranteed to be at least the lowest of the following: $(OL $(LI The value of $(D_INLINECODE GL_MAX_INTEGER_SAMPLES) if $(D_INLINECODE internalformat) is a signed or unsigned integer format.) $(LI The value of $(D_INLINECODE GL_MAX_DEPTH_TEXTURE_SAMPLES) if $(D_INLINECODE internalformat) is a depth- or stencil-renderable format and $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).) $(LI The value of $(D_INLINECODE GL_MAX_COLOR_TEXTURE_SAMPLES) if $(D_INLINECODE internalformat) is a color-renderable format and $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).) $(LI The value of $(D_INLINECODE GL_MAX_SAMPLES).)) If $(D_INLINECODE pname) is $(D_INLINECODE GL_INTERNALFORMAT_SUPPORTED), $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) if $(D_INLINECODE internalFormat) is a supported internal format for $(D_INLINECODE target) and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_INTERNALFORMAT_PREFERRED), $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) if $(D_INLINECODE internalFormat) is an format for $(D_INLINECODE target) that is preferred by the implementation and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_INTERNALFORMAT_RED_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_GREEN_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_BLUE_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_ALPHA_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_DEPTH_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_STENCIL_SIZE), or $(D_INLINECODE GL_INTERNALFORMAT_SHARED_SIZE) then $(D_INLINECODE params) is set to the actual resolutions that would be used for storing image array components for the resource for the red, green, blue, alpha, depth, stencil and shared channels respectively. If $(D_INLINECODE internalFormat) is a compressed internal format, then $(D_INLINECODE params) is set to the component resolution of an uncompressed internal format that produces an image of roughly the same quality as the compressed algorithm. If the internal format is unsupported, or if a particular component is not present in the format, 0 is written to $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_INTERNALFORMAT_RED_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_GREEN_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_BLUE_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_ALPHA_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_DEPTH_TYPE), or $(D_INLINECODE GL_INTERNALFORMAT_STENCIL_TYPE) then $(D_INLINECODE params) is set to a token identifying the data type used to store the respective component. If the $(D_INLINECODE internalFormat) represents a compressed internal format then the types returned specify how components are interpreted after decompression. If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_WIDTH), $(D_INLINECODE GL_MAX_HEIGHT), $(D_INLINECODE GL_MAX_DEPTH), or $(D_INLINECODE GL_MAX_LAYERS) then $(D_INLINECODE pname) is filled with the maximum width, height, depth or layer count for textures with internal format $(D_INLINECODE internalFormat), respectively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_COMBINED_DIMENSIONS) then $(D_INLINECODE pname) is filled with the maximum combined dimensions of a texture of the specified internal format. If $(D_INLINECODE pname) is $(D_INLINECODE GL_COLOR_COMPONENTS) then $(D_INLINECODE params) is set to the value $(D_INLINECODE GL_TRUE) if the internal format contains any color component (i.e., red, green, blue or alpha) and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_DEPTH_COMPONENTS) or $(D_INLINECODE GL_STENCIL_COMPONENTS) then $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) if the internal format contains a depth or stencil component, respectively, and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_COLOR_RENDERABLE), $(D_INLINECODE GL_DEPTH_RENDERABLE) or $(D_INLINECODE GL_STENCIL_RENDERABLE) then $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) if the specified internal format is color, depth or stencil renderable, respectively, and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE) or $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE_LAYERED) then $(D_INLINECODE params) is set to one of $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to indicate that framebuffer attachments (layered attachments in the case of $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE_LAYERED) ) with that internal format are either renderable with no restrictions, renderable with some restrictions or not renderable at all. If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_BLEND), $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) to indicate that the internal format is supported for blending operations when attached to a framebuffer, and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_READ_PIXELS) then $(D_INLINECODE params) is set to $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to that either full support, limited support or no support at all is supplied for reading pixels from framebuffer attachments in the specified internal format. If $(D_INLINECODE pname) is $(D_INLINECODE GL_READ_PIXELS_FORMAT) or $(D_INLINECODE GL_READ_PIXELS_TYPE) then $(D_INLINECODE params) is filled with the format or type, respectively, most recommended to obtain the highest image quality and performance. For $(D_INLINECODE GL_READ_PIXELS_FORMAT), the value returned in $(D_INLINECODE params) is a token that is accepted for the $(D_INLINECODE format) argument to $(D_INLINECODE glReadPixels). For $(D_INLINECODE GL_READ_PIXELS_TYPE), the value returned in $(D_INLINECODE params) is a token that is accepted for the $(D_INLINECODE type) argument to $(D_INLINECODE glReadPixels). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_IMAGE_FORMAT) or $(D_INLINECODE GL_TEXTURE_IMAGE_TYPE) then $(D_INLINECODE params) is filled with the implementation-recommended format or type to be used in calls to $(D_INLINECODE glTexImage2D) and other similar functions. For $(D_INLINECODE GL_TEXTURE_IMAGE_FORMAT), $(D_INLINECODE params) is filled with a token suitable for use as the $(D_INLINECODE format) argument to $(D_INLINECODE glTexImage2D). For $(D_INLINECODE GL_TEXTURE_IMAGE_TYPE), $(D_INLINECODE params) is filled with a token suitable for use as the $(D_INLINECODE type) argument to $(D_INLINECODE glTexImage2D). If $(D_INLINECODE pname) is $(D_INLINECODE GL_GET_TEXTURE_IMAGE_FORMAT) or $(D_INLINECODE GL_GET_TEXTURE_IMAGE_TYPE) then $(D_INLINECODE params) is filled with the implementation-recommended format or type to be used in calls to $(D_INLINECODE glGetTexImage) and other similar functions. For $(D_INLINECODE GL_GET_TEXTURE_IMAGE_FORMAT), $(D_INLINECODE params) is filled with a token suitable for use as the $(D_INLINECODE format) argument to $(D_INLINECODE glGetTexImage). For $(D_INLINECODE GL_GET_TEXTURE_IMAGE_TYPE), $(D_INLINECODE params) is filled with a token suitable for use as the $(D_INLINECODE type) argument to $(D_INLINECODE glGetTexImage). If $(D_INLINECODE pname) is $(D_INLINECODE GL_MIPMAP) then $(D_INLINECODE pname) is set to $(D_INLINECODE GL_TRUE) to indicate that the specified internal format supports mipmaps and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_GENERATE_MIPMAP) or $(D_INLINECODE GL_AUTO_GENERATE_MIPMAP) then $(D_INLINECODE params) is indicates the level of support for manual or automatic mipmap generation for the specified internal format, respectively. Returned values may be one of $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) and $(D_INLINECODE GL_NONE) to indicate either full support, limited support or no support at all. If $(D_INLINECODE pname) is $(D_INLINECODE GL_COLOR_ENCODING) then the color encoding for the resource is returned in $(D_INLINECODE params). Possible values for color buffers are $(D_INLINECODE GL_LINEAR) or $(D_INLINECODE GL_SRGB), for linear or sRGB-encoded color components, respectively. For non-color formats (such as depth or stencil), or for unsupported resources, the value $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_SRGB_READ), or $(D_INLINECODE GL_SRGB_WRITE) then $(D_INLINECODE params) indicates the level of support for reading and writing to sRGB encoded images, respectively. For $(D_INLINECODE GL_SRGB_READ), support for converting from sRGB colorspace on read operations is returned in $(D_INLINECODE params) and for $(D_INLINECODE GL_SRGB_WRITE), support for converting to sRGB colorspace on write operations to the resource is returned in $(D_INLINECODE params). $(D_INLINECODE params) may be set to $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respecitively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_FILTER) the $(D_INLINECODE params) is set to either $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE) to indicate support or lack thereof for filter modes other than $(D_INLINECODE GL_NEAREST) or $(D_INLINECODE GL_NEAREST_MIPMAP) for the specified internal format. If $(D_INLINECODE pname) is $(D_INLINECODE GL_VERTEX_TEXTURE), $(D_INLINECODE GL_TESS_CONTROL_TEXTURE), $(D_INLINECODE GL_TESS_EVALUATION_TEXTURE), $(D_INLINECODE GL_GEOMETRY_TEXTURE), $(D_INLINECODE GL_FRAGMENT_TEXTURE), or $(D_INLINECODE GL_COMPUTE_TEXTURE), then the value written to $(D_INLINECODE params) indicates support for use of the resource as a source of texturing in the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages, respectively. $(D_INLINECODE params) may be set to $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_SHADOW), $(D_INLINECODE GL_TEXTURE_GATHER) or $(D_INLINECODE GL_TEXTURE_GATHER_SHADOW) then the value written to $(D_INLINECODE params) indicates the level of support for using the resource with a shadow sampler, in gather operations or as a shadow sampler in gather operations, respectively. Returned values may be $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_SHADER_IMAGE_LOAD), $(D_INLINECODE GL_SHADER_IMAGE_STORE) or $(D_INLINECODE GL_SHADER_IMAGE_ATOMIC) then the value returned in $(D_INLINECODE params) indicates the level of support for image loads, stores and atomics for resources of the specified internal format. Returned values may be $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_IMAGE_TEXEL_SIZE) then the size of a texel when the resource when used as an image texture is returned in $(D_INLINECODE params). If the resource is not supported for image textures zero is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_IMAGE_COMPATIBILITY_CLASS) then the compatibility class of the resource when used as an image texture is returned in $(D_INLINECODE params). The possible values returned are $(D_INLINECODE GL_IMAGE_CLASS_4_X_32), $(D_INLINECODE GL_IMAGE_CLASS_2_X_32), $(D_INLINECODE GL_IMAGE_CLASS_1_X_32), $(D_INLINECODE GL_IMAGE_CLASS_4_X_16), $(D_INLINECODE GL_IMAGE_CLASS_2_X_16), $(D_INLINECODE GL_IMAGE_CLASS_1_X_16), $(D_INLINECODE GL_IMAGE_CLASS_4_X_8), $(D_INLINECODE GL_IMAGE_CLASS_2_X_8), $(D_INLINECODE GL_IMAGE_CLASS_1_X_8), $(D_INLINECODE GL_IMAGE_CLASS_11_11_10), and $(D_INLINECODE GL_IMAGE_CLASS_10_10_10_2), which correspond to the 4x32, 2x32, 1x32, 4x16, 2x16, 1x16, 4x8, 2x8, 1x8, the class (a) 11/11/10 packed floating-point format, and the class (b) 10/10/10/2 packed formats, respectively. If the resource is not supported for image textures, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_IMAGE_PIXEL_FORMAT) or $(D_INLINECODE GL_IMAGE_PIXEL_TYPE) then the pixel format or type of the resource when used as an image texture is returned in $(D_INLINECODE params), respectively. In either case, the resource is not supported for image textures $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE), the matching criteria use for the resource when used as an image textures is returned in $(D_INLINECODE params). Possible values returned in $(D_INLINECODE params) are $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE) or $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS). If the resource is not supported for image textures, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST) or $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST), support for using the resource both as a source for texture sampling while it is bound as a buffer for depth or stencil test, respectively, is written to $(D_INLINECODE params). Possible values returned are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE) or $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE), support for using the resource both as a source for texture sampling while performing depth or stencil writes to the resources, respectively, is written to $(D_INLINECODE params). Possible values returned are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_COMPRESSED) then $(D_INLINECODE GL_TRUE) is returned in $(D_INLINECODE params) if $(D_INLINECODE internalformat) is a compressed internal format. $(D_INLINECODE GL_FALSE) is returned in $(D_INLINECODE params) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT) or $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_SIZE) then the width, height or total size, respectively of a block (in basic machine units) is returned in $(D_INLINECODE params). If the internal format is not compressed, or the resource is not supported, 0 is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_CLEAR_BUFFER), the level of support for using the resource with $(D_INLINECODE glClearBufferData) and $(D_INLINECODE glClearBufferSubData) is returned in $(D_INLINECODE params). Possible values returned are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_VIEW), the level of support for using the resource with the $(D_INLINECODE glTextureView) command is returned in $(D_INLINECODE params). Possible values returned are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_VIEW_COMPATIBILITY_CLASS) then the compatibility class of the resource when used as a texture view is returned in $(D_INLINECODE params). The possible values returned are $(D_INLINECODE GL_VIEW_CLASS_128_BITS), $(D_INLINECODE GL_VIEW_CLASS_96_BITS), $(D_INLINECODE GL_VIEW_CLASS_64_BITS), $(D_INLINECODE GL_VIEW_CLASS_48_BITS), $(D_INLINECODE GL_VIEW_CLASS_32_BITS), $(D_INLINECODE GL_VIEW_CLASS_24_BITS), $(D_INLINECODE GL_VIEW_CLASS_16_BITS), $(D_INLINECODE GL_VIEW_CLASS_8_BITS), $(D_INLINECODE GL_VIEW_CLASS_S3TC_DXT1_RGB), $(D_INLINECODE GL_VIEW_CLASS_S3TC_DXT1_RGBA), $(D_INLINECODE GL_VIEW_CLASS_S3TC_DXT3_RGBA), $(D_INLINECODE GL_VIEW_CLASS_S3TC_DXT5_RGBA), $(D_INLINECODE GL_VIEW_CLASS_RGTC1_RED), $(D_INLINECODE GL_VIEW_CLASS_RGTC2_RG), $(D_INLINECODE GL_VIEW_CLASS_BPTC_UNORM), and $(D_INLINECODE GL_VIEW_CLASS_BPTC_FLOAT). If $(D_INLINECODE pname) is $(D_INLINECODE GL_CLEAR_TEXTURE) then the presence of support for using the $(D_INLINECODE glClearTexImage) and $(D_INLINECODE glClearTexSubImage) commands with the resource is written to $(D_INLINECODE params). Possible values written are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned.
     + 
     + $(D_INLINECODE glGetInternalformativ) is available only if the GL version is 4.2 or higher. The tokens $(D_INLINECODE GL_INTERNALFORMAT_SUPPORTED), $(D_INLINECODE GL_INTERNALFORMAT_PREFERRED), $(D_INLINECODE GL_INTERNALFORMAT_RED_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_GREEN_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_BLUE_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_ALPHA_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_DEPTH_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_STENCIL_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_SHARED_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_RED_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_GREEN_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_BLUE_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_ALPHA_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_DEPTH_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_STENCIL_TYPE), $(D_INLINECODE GL_MAX_WIDTH), $(D_INLINECODE GL_MAX_HEIGHT), $(D_INLINECODE GL_MAX_DEPTH), $(D_INLINECODE GL_MAX_LAYERS), $(D_INLINECODE GL_MAX_COMBINED_DIMENSIONS), $(D_INLINECODE GL_COLOR_COMPONENTS), $(D_INLINECODE GL_DEPTH_COMPONENTS), $(D_INLINECODE GL_STENCIL_COMPONENTS), $(D_INLINECODE GL_COLOR_RENDERABLE), $(D_INLINECODE GL_DEPTH_RENDERABLE), $(D_INLINECODE GL_STENCIL_RENDERABLE), $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE), $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE_LAYERED), $(D_INLINECODE GL_FRAMEBUFFER_BLEND), $(D_INLINECODE GL_READ_PIXELS), $(D_INLINECODE GL_READ_PIXELS_FORMAT), $(D_INLINECODE GL_READ_PIXELS_TYPE), $(D_INLINECODE GL_TEXTURE_IMAGE_FORMAT), $(D_INLINECODE GL_TEXTURE_IMAGE_TYPE), $(D_INLINECODE GL_GET_TEXTURE_IMAGE_FORMAT), $(D_INLINECODE GL_GET_TEXTURE_IMAGE_TYPE), $(D_INLINECODE GL_MIPMAP), $(D_INLINECODE GL_GENERATE_MIPMAP), $(D_INLINECODE GL_AUTO_GENERATE_MIPMAP), $(D_INLINECODE GL_COLOR_ENCODING), $(D_INLINECODE GL_SRGB_READ), $(D_INLINECODE GL_SRGB_WRITE), $(D_INLINECODE GL_SRGB_DECODE_ARB), $(D_INLINECODE GL_FILTER), $(D_INLINECODE GL_VERTEX_TEXTURE), $(D_INLINECODE GL_TESS_CONTROL_TEXTURE), $(D_INLINECODE GL_TESS_EVALUATION_TEXTURE), $(D_INLINECODE GL_GEOMETRY_TEXTURE), $(D_INLINECODE GL_FRAGMENT_TEXTURE), $(D_INLINECODE GL_COMPUTE_TEXTURE), $(D_INLINECODE GL_TEXTURE_SHADOW), $(D_INLINECODE GL_TEXTURE_GATHER), $(D_INLINECODE GL_TEXTURE_GATHER_SHADOW), $(D_INLINECODE GL_SHADER_IMAGE_LOAD), $(D_INLINECODE GL_SHADER_IMAGE_STORE), $(D_INLINECODE GL_SHADER_IMAGE_ATOMIC), $(D_INLINECODE GL_IMAGE_TEXEL_SIZE), $(D_INLINECODE GL_IMAGE_COMPATIBILITY_CLASS), $(D_INLINECODE GL_IMAGE_PIXEL_FORMAT), $(D_INLINECODE GL_IMAGE_PIXEL_TYPE), $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE), $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST), $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST), $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE), $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE), $(D_INLINECODE GL_TEXTURE_COMPRESSED), $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT), $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_SIZE), $(D_INLINECODE GL_CLEAR_BUFFER), $(D_INLINECODE GL_TEXTURE_VIEW), and $(D_INLINECODE GL_VIEW_COMPATIBILITY_CLASS) are supported only if the GL version is 4.3 or higher. The $(D_INLINECODE GL_CLEAR_TEXTURE) token is accepted for $(D_INLINECODE pname) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Indicates the usage of the internal format. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_RENDERBUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
     +     internalformat = Specifies the internal format about which to retrieve information.
     +     pname          = Specifies the type of information to query.
     +     bufSize        = Specifies the maximum number of basic machine units that may be written to $(D_INLINECODE params) by the function.
     +     params         = Specifies the address of a variable into which to write the retrieved information.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_internalformat_query")
    void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_internalformat_query2")
    void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params) @system @nogc nothrow;

    /++
     + glGetMultisample: man4/glGetMultisample.xml
     + 
     + $(D_INLINECODE glGetMultisamplefv) queries the location of a given sample. $(D_INLINECODE pname) specifies the sample parameter to retrieve and must be $(D_INLINECODE GL_SAMPLE_POSITION). $(D_INLINECODE index) corresponds to the sample for which the location should be returned. The sample location is returned as two floating-point values in $(D_INLINECODE val[0]) and $(D_INLINECODE val[1]), each between 0 and 1, corresponding to the $(D_INLINECODE x) and $(D_INLINECODE y) locations respectively in the GL pixel space of that sample. (0.5, 0.5) this corresponds to the pixel center. $(D_INLINECODE index) must be between zero and the value of $(D_INLINECODE GL_SAMPLES) minus one. If the multisample mode does not have fixed sample locations, the returned values may only reflect the locations of samples within some pixels.
     + 
     + Params:
     +     pname = Specifies the sample parameter name. $(D_INLINECODE pname) must be $(D_INLINECODE GL_SAMPLE_POSITION).
     +     index = Specifies the index of the sample whose position to query.
     +     val   = Specifies the address of an array to receive the position of the sample.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat* val) @system @nogc nothrow;

    /++
     + glGetNamedRenderbufferParameteriv: man4/glGetRenderbufferParameter.xml
     + 
     + $(D_INLINECODE glGetRenderbufferParameteriv) and $(D_INLINECODE glGetNamedRenderbufferParameteriv) query parameters of a specified renderbuffer object. For $(D_INLINECODE glGetRenderbufferParameteriv), the renderbuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_RENDERBUFFER). For $(D_INLINECODE glGetNamedRenderbufferParameteriv), $(D_INLINECODE renderbuffer) is the name of the renderbuffer object. Upon successful return, $(D_INLINECODE param) will contain the value of the renderbuffer parameter specified by $(D_INLINECODE pname), as described below.
     + 
     + Params:
     +     target       = Specifies the target to which the renderbuffer object is bound for $(D_INLINECODE glGetRenderbufferParameteriv). $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer = Specifies the name of the renderbuffer object for $(D_INLINECODE glGetNamedRenderbufferParameteriv).
     +     pname        = Specifies the parameter of the renderbuffer object to query.
     +     params       = Returns the value of parameter $(D_INLINECODE pname) for the renderbuffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glRenderbufferStorageMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetnTexImage: man4/glGetTexImage.xml
     + 
     + $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetnTexImage) and $(D_INLINECODE glGetTextureImage) functions return a texture image into $(D_INLINECODE pixels). For $(D_INLINECODE glGetTexImage) and $(D_INLINECODE glGetnTexImage), $(D_INLINECODE target) specifies whether the desired texture image is one specified by $(D_INLINECODE glTexImage1D) ( $(D_INLINECODE GL_TEXTURE_1D) ), $(D_INLINECODE glTexImage2D) ( $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_2D) or any of $(D_INLINECODE GL_TEXTURE_CUBE_MAP_*) ), or $(D_INLINECODE glTexImage3D) ( $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) ). For $(D_INLINECODE glGetTextureImage), $(D_INLINECODE texture) specifies the texture object name. In addition to types of textures accepted by $(D_INLINECODE glGetTexImage) and $(D_INLINECODE glGetnTexImage), the function also accepts cube map texture objects (with effective target $(D_INLINECODE GL_TEXTURE_CUBE_MAP) ). $(D_INLINECODE level) specifies the level-of-detail number of the desired image. $(D_INLINECODE format) and $(D_INLINECODE type) specify the format and type of the desired image array. See the reference page for $(D_INLINECODE glTexImage1D) for a description of the acceptable values for the $(D_INLINECODE format) and $(D_INLINECODE type) parameters, respectively. For glGetnTexImage and glGetTextureImage functions, bufSize tells the size of the buffer to receive the retrieved pixel data. $(D_INLINECODE glGetnTexImage) and $(D_INLINECODE glGetTextureImage) do not write more than $(D_INLINECODE bufSize) bytes into $(D_INLINECODE pixels). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is requested, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store. To understand the operation of $(D_INLINECODE glGetTexImage), consider the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of $(D_INLINECODE glGetTexImage) are then identical to those of $(D_INLINECODE glReadPixels), with the exception that no pixel transfer operations are performed, when called with the same $(D_INLINECODE format) and $(D_INLINECODE type), with and set to 0, set to the width of the texture image and set to 1 for 1D images, or to the height of the texture image for 2D images. If the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to 1. To determine the required size of $(D_INLINECODE pixels), use $(D_INLINECODE glGetTexLevelParameter) to determine the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on $(D_INLINECODE format) and $(D_INLINECODE type). Be sure to take the pixel storage parameters into account, especially $(D_INLINECODE GL_PACK_ALIGNMENT). If $(D_INLINECODE glGetTextureImage) is used against a cube map texture object, the texture is treated as a three-dimensional image of a depth of 6, where the cube map faces are ordered as image layers, in an order presented in the table below: Layer number Cube Map Face 0 GL_TEXTURE_CUBE_MAP_POSITIVE_X 1 GL_TEXTURE_CUBE_MAP_NEGATIVE_X 2 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 3 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 4 GL_TEXTURE_CUBE_MAP_POSITIVE_Z 5 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE pixels). $(D_INLINECODE glGetTexImage) and $(D_INLINECODE glGetnTexImage) return the texture image for the active texture unit. $(D_INLINECODE GL_STENCIL_INDEX) is accepted for $(D_INLINECODE format) only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glGetTexImage) and $(D_INLINECODE glGetnTexImage) functions. $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), and $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) are acceptable.
     +     texture = Specifies the texture object name.
     +     level   = Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the n th mipmap reduction image.
     +     format  = Specifies a pixel format for the returned data. The supported formats are $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), $(D_INLINECODE GL_BLUE), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_RED_INTEGER), $(D_INLINECODE GL_GREEN_INTEGER), $(D_INLINECODE GL_BLUE_INTEGER), $(D_INLINECODE GL_RG_INTEGER), $(D_INLINECODE GL_RGB_INTEGER), $(D_INLINECODE GL_RGBA_INTEGER), $(D_INLINECODE GL_BGR_INTEGER), $(D_INLINECODE GL_BGRA_INTEGER).
     +     type    = Specifies a pixel type for the returned data. The supported types are $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_HALF_FLOAT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), $(D_INLINECODE GL_UNSIGNED_INT_24_8), $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV), $(D_INLINECODE GL_UNSIGNED_INT_5_9_9_9_REV), and $(D_INLINECODE GL_FLOAT_32_UNSIGNED_INT_24_8_REV).
     +     bufSize = Specifies the size of the buffer $(D_INLINECODE pixels) for $(D_INLINECODE glGetnTexImage) and $(D_INLINECODE glGetTextureImage) functions.
     +     pixels  = Returns the texture image. Should be a pointer to an array of the type specified by $(D_INLINECODE type).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;

    /++
     + glGetnUniformdv: man4/glGetUniform.xml
     + 
     + $(D_INLINECODE glGetUniform) and $(D_INLINECODE glGetnUniform) return in $(D_INLINECODE params) the value(s) of the specified uniform variable. The type of the uniform variable specified by $(D_INLINECODE location) determines the number of values returned. If the uniform variable is defined in the shader as a boolean, int, or float, a single value will be returned. If it is defined as a vec2, ivec2, or bvec2, two values will be returned. If it is defined as a vec3, ivec3, or bvec3, three values will be returned, and so on. To query values stored in uniform variables declared as arrays, call $(D_INLINECODE glGetUniform) for each element of the array. To query values stored in uniform variables declared as structures, call $(D_INLINECODE glGetUniform) for each field in the structure. The values for uniform variables declared as a matrix will be returned in column major order. The locations assigned to uniform variables are not known until the program object is linked. After linking has occurred, the command $(D_INLINECODE glGetUniformLocation) can be used to obtain the location of a uniform variable. This location value can then be passed to $(D_INLINECODE glGetUniform) or $(D_INLINECODE glGetnUniform) in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. The uniform variable values can only be queried after a link if the link was successful. The only difference between $(D_INLINECODE glGetUniform) and $(D_INLINECODE glGetnUniform) is that $(D_INLINECODE glGetnUniform) will generate an error if size of the $(D_INLINECODE params) buffer,as described by $(D_INLINECODE bufSize), is not large enough to hold the result data.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     program  = Specifies the program object to be queried.
     +     location = Specifies the location of the uniform variable to be queried.
     +     bufSize  = Specifies the size of the buffer $(D_INLINECODE params).
     +     params   = Returns the value of the specified uniform variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetUniformfv(GLuint program, GLint location, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetUniformiv(GLuint program, GLint location, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetUniformuiv(GLuint program, GLint location, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glGetUniformdv(GLuint program, GLint location, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble* params) @system @nogc nothrow;

    /++
     + glGetObjectLabel: man4/glGetObjectLabel.xml
     + 
     + $(D_INLINECODE glGetObjectLabel) retrieves the label of the object identified by $(D_INLINECODE name) within the namespace given by $(D_INLINECODE identifier). $(D_INLINECODE identifier) must be one of $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER), $(D_INLINECODE GL_PROGRAM), $(D_INLINECODE GL_VERTEX_ARRAY), $(D_INLINECODE GL_QUERY), $(D_INLINECODE GL_PROGRAM_PIPELINE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK), $(D_INLINECODE GL_SAMPLER), $(D_INLINECODE GL_TEXTURE), $(D_INLINECODE GL_RENDERBUFFER), $(D_INLINECODE GL_FRAMEBUFFER), to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively. $(D_INLINECODE label) is the address of a string that will be used to store the object label. $(D_INLINECODE bufSize) specifies the number of characters in the array identified by $(D_INLINECODE label). $(D_INLINECODE length) contains the address of a variable which will receive the the number of characters in the object label. If $(D_INLINECODE length) is null, then it is ignored and no data is written. Likewise, if
     +  $(D_INLINECODE label) is null, or if
     +  $(D_INLINECODE bufSize) is zero then no data is written to $(D_INLINECODE label).
     + 
     + Params:
     +     identifier = The namespace from which the name of the object is allocated.
     +     name       = The name of the object whose label to retrieve.
     +     bufSize    = The length of the buffer whose address is in $(D_INLINECODE label).
     +     length     = The address of a variable to receive the length of the object label.
     +     label      = The address of a string that will receive the object label.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glGetObjectPtrLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bifSize, GLsizei* length, char* label) @system @nogc nothrow;

    /++
     + glGetObjectPtrLabel: man4/glGetObjectPtrLabel.xml
     + 
     + $(D_INLINECODE glGetObjectPtrLabel) retrieves the label of the sync object identified by $(D_INLINECODE ptr). $(D_INLINECODE label) is the address of a string that will be used to store the object label. $(D_INLINECODE bufSize) specifies the number of characters in the array identified by $(D_INLINECODE label). $(D_INLINECODE length) contains the address of a variable which will receive the the number of characters in the object label. If $(D_INLINECODE length) is null, then it is ignored and no data is written. Likewise, if
     +  $(D_INLINECODE label) is null, or if
     +  $(D_INLINECODE bufSize) is zero then no data is written to $(D_INLINECODE label).
     + 
     + Params:
     +     ptr     = The name of the sync object whose label to retrieve.
     +     bufSize = The length of the buffer whose address is in $(D_INLINECODE label).
     +     length  = The address of a variable to receive the length of the object label.
     +     label   = The address of a string that will receive the object label.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glGetObjectLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetObjectPtrLabel(void* ptr, GLsizei bifSize, GLsizei* length, char* label) @system @nogc nothrow;

    /++
     + glGetPointerv: man4/glGetPointerv.xml
     + 
     + $(D_INLINECODE glGetPointerv) returns pointer information. $(D_INLINECODE pname) indicates the pointer to be returned, and $(D_INLINECODE params) is a pointer to a location in which to place the returned data. The parameters that may be queried include:
     + 
     + $(D_INLINECODE glGetPointerv) is available in the OpenGL core profile only if the GL version is 4.3 or later. It is available in the compatibility profile for all GL versions, and accepts additional queries. However, these reference pages document only the core profile.
     + 
     + Params:
     +     pname  = Specifies the pointer to be returned. Must be one of $(D_INLINECODE GL_DEBUG_CALLBACK_FUNCTION) or $(D_INLINECODE GL_DEBUG_CALLBACK_USER_PARAM).
     +     params = Returns the pointer value specified by $(D_INLINECODE pname).
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetPointerv(GLenum pname, GLvoid** params) @system @nogc nothrow;

    /++
     + glGetProgram: man4/glGetProgram.xml
     + 
     + $(D_INLINECODE glGetProgram) returns in $(D_INLINECODE params) the value of a parameter for a specific program object. The following parameters are defined:
     + 
     + $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCKS) and $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH) are available only if the GL version 3.1 or greater. $(D_INLINECODE GL_GEOMETRY_VERTICES_OUT), $(D_INLINECODE GL_GEOMETRY_INPUT_TYPE) and $(D_INLINECODE GL_GEOMETRY_OUTPUT_TYPE) are accepted only if the GL version is 3.2 or greater. $(D_INLINECODE GL_COMPUTE_WORK_GROUP_SIZE) is accepted only if the GL version is 4.3 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     pname   = Specifies the object parameter. Accepted symbolic names are $(D_INLINECODE GL_DELETE_STATUS), $(D_INLINECODE GL_LINK_STATUS), $(D_INLINECODE GL_VALIDATE_STATUS), $(D_INLINECODE GL_INFO_LOG_LENGTH), $(D_INLINECODE GL_ATTACHED_SHADERS), $(D_INLINECODE GL_ACTIVE_ATOMIC_COUNTER_BUFFERS), $(D_INLINECODE GL_ACTIVE_ATTRIBUTES), $(D_INLINECODE GL_ACTIVE_ATTRIBUTE_MAX_LENGTH), $(D_INLINECODE GL_ACTIVE_UNIFORMS), $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCKS), $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH), $(D_INLINECODE GL_ACTIVE_UNIFORM_MAX_LENGTH), $(D_INLINECODE GL_COMPUTE_WORK_GROUP_SIZE) $(D_INLINECODE GL_PROGRAM_BINARY_LENGTH), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_MODE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYINGS), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH), $(D_INLINECODE GL_GEOMETRY_VERTICES_OUT), $(D_INLINECODE GL_GEOMETRY_INPUT_TYPE), and $(D_INLINECODE GL_GEOMETRY_OUTPUT_TYPE).
     +     params  = Returns the requested object parameter.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glGetShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetProgramiv(GLuint program, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetProgramBinary: man4/glGetProgramBinary.xml
     + 
     + $(D_INLINECODE glGetProgramBinary) returns a binary representation of the compiled and linked executable for $(D_INLINECODE program) into the array of bytes whose address is specified in $(D_INLINECODE binary). The maximum number of bytes that may be written into $(D_INLINECODE binary) is specified by $(D_INLINECODE bufSize). If the program binary is greater in size than $(D_INLINECODE bufSize) bytes, then an error is generated, otherwise the actual number of bytes written into $(D_INLINECODE binary) is returned in the variable whose address is given by $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), then no length is returned. The format of the program binary written into $(D_INLINECODE binary) is returned in the variable whose address is given by $(D_INLINECODE binaryFormat), and may be implementation dependent. The binary produced by the GL may subsequently be returned to the GL by calling $(D_INLINECODE glProgramBinary), with $(D_INLINECODE binaryFormat) and $(D_INLINECODE length) set to the values returned by $(D_INLINECODE glGetProgramBinary), and passing the returned binary data in the $(D_INLINECODE binary) parameter.
     + 
     + Params:
     +     program      = Specifies the name of a program object whose binary representation to retrieve.
     +     bufSize      = Specifies the size of the buffer whose address is given by $(D_INLINECODE binary).
     +     length       = Specifies the address of a variable to receive the number of bytes written into $(D_INLINECODE binary).
     +     binaryFormat = Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
     +     binary       = Specifies the address an array into which the GL will return $(D_INLINECODE program) 's binary representation.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glProgramBinary)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    void glGetProgramBinary(GLuint program, GLsizei bufsize, GLsizei* length, GLenum* binaryFormat, void* binary) @system @nogc nothrow;

    /++
     + glGetProgramInfoLog: man4/glGetProgramInfoLog.xml
     + 
     + $(D_INLINECODE glGetProgramInfoLog) returns the information log for the specified program object. The information log for a program object is modified when the program object is linked or validated. The string that is returned will be null terminated. $(D_INLINECODE glGetProgramInfoLog) returns in $(D_INLINECODE infoLog) as much of the information log as it can, up to a maximum of $(D_INLINECODE maxLength) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned information log can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_INFO_LOG_LENGTH). The information log for a program object is either an empty string, or a string containing information about the last link operation, or a string containing information about the last validation operation. It may contain diagnostic messages, warning messages, and other information. When a program object is created, its information log will be a string of length 0.
     + 
     + The information log for a program object is the OpenGL implementer's primary mechanism for conveying information about linking and validating. Therefore, the information log can be helpful to application developers during the development process, even when these operations are successful. Application developers should not expect different OpenGL implementations to produce identical information logs.
     + 
     + Params:
     +     program   = Specifies the program object whose information log is to be queried.
     +     maxLength = Specifies the size of the character buffer for storing the returned information log.
     +     length    = Returns the length of the string returned in $(D_INLINECODE infoLog) (excluding the null terminator).
     +     infoLog   = Specifies an array of characters that is used to return the information log.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glGetShaderInfoLog), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;

    /++
     + glGetProgramInterface: man4/glGetProgramInterface.xml
     + 
     + $(D_INLINECODE glGetProgramInterfaceiv) queries the property of the interface identifed by $(D_INLINECODE programInterface) in $(D_INLINECODE program), the property name of which is given by $(D_INLINECODE pname). $(D_INLINECODE program) must be the name of an existing program object. $(D_INLINECODE programInterface) is the name of the interface within $(D_INLINECODE program) to query and must be one of the following values: $(D_INLINECODE pname) identifies the property of $(D_INLINECODE programInterface) to return in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_RESOURCES), the value returned is the number of resources in the active resource list for $(D_INLINECODE programInterface).  If the list of active resources for $(D_INLINECODE programInterface) is empty, zero is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NAME_LENGTH), the value returned is the length of the longest active name string for an active resource in $(D_INLINECODE programInterface). This length includes an extra character for the null terminator.  If the list of active resources for $(D_INLINECODE programInterface) is empty, zero is returned.  It is an error to specify $(D_INLINECODE GL_MAX_NAME_LENGTH) when $(D_INLINECODE programInterface) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), as active atomic counter buffer resources are not assigned name strings. If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NUM_ACTIVE_VARIABLES), the value returned is the number of active variables belonging to the interface block or atomic counter buffer resource in $(D_INLINECODE programInterface) with the most active variables.  If the list of active resources for $(D_INLINECODE programInterface) is empty, zero is returned.  When $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NUM_ACTIVE_VARIABLES), $(D_INLINECODE programInterface) must be $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), or $(D_INLINECODE GL_SHADER_STORAGE_BLOCK). If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NUM_COMPATIBLE_SUBROUTINES), the value returned is the number of compatible subroutines belonging to the active subroutine uniform in $(D_INLINECODE programInterface) with the most compatible subroutines.  If the list of active resources for $(D_INLINECODE programInterface) is empty, zero is returned. When $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NUM_COMPATIBLE_SUBROUTINES), $(D_INLINECODE programInterface) must be one of $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), or $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM).
     + 
     + Params:
     +     program          = The name of a program object whose interface to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) to query.
     +     pname            = The name of the parameter within $(D_INLINECODE programInterface) to query.
     +     params           = The address of a variable to retrieve the value of $(D_INLINECODE pname) for the program interface.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glGetObjectLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetProgramPipeline: man4/glGetProgramPipeline.xml
     + 
     + $(D_INLINECODE glGetProgramPipelineiv) retrieves the value of a property of the program pipeline object $(D_INLINECODE pipeline). $(D_INLINECODE pname) specifies the name of the parameter whose value to retrieve. The value of the parameter is written to the variable whose address is given by $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_PROGRAM), the name of the active program object of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_VERTEX_SHADER), the name of the current program object for the vertex shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TESS_CONTROL_SHADER), the name of the current program object for the tessellation control shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TESS_EVALUATION_SHADER), the name of the current program object for the tessellation evaluation shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_GEOMETRY_SHADER), the name of the current program object for the geometry shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAGMENT_SHADER), the name of the current program object for the fragment shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_INFO_LOG_LENGTH), the length of the info log, including the null terminator, is returned in $(D_INLINECODE params). If there is no info log, zero is returned.
     + 
     + Params:
     +     pipeline = Specifies the name of a program pipeline object whose parameter retrieve.
     +     pname    = Specifies the name of the parameter to retrieve.
     +     params   = Specifies the address of a variable into which will be written the value or values of $(D_INLINECODE pname) for $(D_INLINECODE pipeline).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glDeleteProgramPipelines)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetProgramPipelineInfoLog: man4/glGetProgramPipelineInfoLog.xml
     + 
     + $(D_INLINECODE glGetProgramPipelineInfoLog) retrieves the info log for the program pipeline object $(D_INLINECODE pipeline). The info log, including its null terminator, is written into the array of characters whose address is given by $(D_INLINECODE infoLog). The maximum number of characters that may be written into $(D_INLINECODE infoLog) is given by $(D_INLINECODE bufSize), and the actual number of characters written into $(D_INLINECODE infoLog) is returned in the integer whose address is given by $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. The actual length of the info log for the program pipeline may be determined by calling $(D_INLINECODE glGetProgramPipeline) with $(D_INLINECODE pname) set to $(D_INLINECODE GL_INFO_LOG_LENGTH).
     + 
     + Params:
     +     pipeline = Specifies the name of a program pipeline object from which to retrieve the info log.
     +     bufSize  = Specifies the maximum number of characters, including the null terminator, that may be written into $(D_INLINECODE infoLog).
     +     length   = Specifies the address of a variable into which will be written the number of characters written into $(D_INLINECODE infoLog).
     +     infoLog  = Specifies the address of an array of characters into which will be written the info log for $(D_INLINECODE pipeline).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glGetProgramPipeline)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;

    /++
     + glGetProgramResource: man4/glGetProgramResource.xml
     + 
     + $(D_INLINECODE glGetProgramResourceiv) returns values for multiple properties of a single active resource with an index of $(D_INLINECODE index) in the interface $(D_INLINECODE programInterface) of program object $(D_INLINECODE program).  For each resource, values for $(D_INLINECODE propCount) properties specified by the array $(D_INLINECODE props) are returned. $(D_INLINECODE propCount) may not be zero. An error is generated if any value in $(D_INLINECODE props) is not one of the properties described immediately belowor if any value in $(D_INLINECODE props) is not allowed for $(D_INLINECODE programInterface).  The set of allowed $(D_INLINECODE programInterface) values for each property can be found in the following table: Property Supported Interfaces $(D_INLINECODE GL_NAME_LENGTH) Any except $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) and $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) $(D_INLINECODE GL_TYPE) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_ARRAY_SIZE) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT, VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING) $(D_INLINECODE GL_OFFSET) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING) $(D_INLINECODE GL_BLOCK_INDEX) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_ARRAY_STRIDE) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_MATRIX_STRIDE) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_IS_ROW_MAJOR) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_INDEX) $(D_INLINECODE GL_UNIFORM) $(D_INLINECODE GL_TEXTURE_BUFFER) $(D_INLINECODE GL_BUFFER_BINDING) $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) $(D_INLINECODE GL_BUFFER_DATA_SIZE) $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK) $(D_INLINECODE GL_NUM_ACTIVE_VARIABLES) $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) $(D_INLINECODE GL_ACTIVE_VARIABLES) $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) $(D_INLINECODE GL_REFERENCED_BY_VERTEX_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_TESS_CONTROL_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_TESS_EVALUATION_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_GEOMETRY_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_FRAGMENT_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_COMPUTE_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_NUM_COMPATIBLE_SUBROUTINES) $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM) $(D_INLINECODE GL_COMPATIBLE_SUBROUTINES) $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM) $(D_INLINECODE GL_TOP_LEVEL_ARRAY_SIZE) $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_TOP_LEVEL_ARRAY_STRIDE) $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_LOCATION) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT), $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM) $(D_INLINECODE GL_LOCATION_INDEX) $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_IS_PER_PATCH) $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_LOCATION_COMPONENT) $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_INDEX) $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING) $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE) $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) For the property $(D_INLINECODE GL_NAME_LENGTH), a single integer identifying the length of the name string associated with an active variable, interface block, or subroutine is written to $(D_INLINECODE params).  The name length includes a terminating null character. For the property $(D_INLINECODE GL_TYPE), a single integer identifying the type of an active variable is written to $(D_INLINECODE params).  The integer returned is one of the values found in table 2.16. For the property $(D_INLINECODE GL_ARRAY_SIZE), a single integer identifying the number of active array elements of an active variable is written to $(D_INLINECODE params).  The array size returned is in units of the type associated with the property $(D_INLINECODE GL_TYPE).  For active variables not corresponding to an array of basic types, the value zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_BLOCK_INDEX), a single integer identifying the index of the active interface block containing an active variable is written to $(D_INLINECODE params).  If the variable is not the member of an interface block, the value -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_OFFSET), a single integer identifying the offset of an active variable is written to $(D_INLINECODE params).  For variables in the $(D_INLINECODE GL_UNIFORM) and $(D_INLINECODE GL_BUFFER_VARIABLE) interfaces that are backed by a buffer object, the value written is the offset of that variable relative to the base of the buffer range holding its value.  For variables in the $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING) interface, the value written is the offset in the transform feedback buffer storage assigned to each vertex captured in transform feedback mode where the value of the variable will be stored.  Such offsets are specified via the $(D_INLINECODE xfb_offset) layout qualifier or assigned according to the variables position in the list of strings passed to $(D_INLINECODE glTransformFeedbackVaryings).  Offsets are expressed in basic machine units. For all variables not recorded in transform feedback mode, including the special names $(D_INLINECODE "gl_NextBuffer"), $(D_INLINECODE "gl_SkipComponents1"), $(D_INLINECODE "gl_SkipComponents2"), $(D_INLINECODE "gl_SkipComponents3"), and $(D_INLINECODE "gl_SkipComponents4"), -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_ARRAY_STRIDE), a single integer identifying the stride between array elements in an active variable is written to $(D_INLINECODE params).  For active variables declared as an array of basic types, the value written is the difference, in basic machine units, between the offsets of consecutive elements in an array.  For active variables not declared as an array of basic types, zero is written to $(D_INLINECODE params).  For active variables not backed by a buffer object, -1 is written to $(D_INLINECODE params), regardless of the variable type. For the property $(D_INLINECODE GL_MATRIX_STRIDE), a single integer identifying the stride between columns of a column-major matrix or rows of a row-major matrix is written to $(D_INLINECODE params).  For active variables declared a single matrix or array of matrices, the value written is the difference, in basic machine units, between the offsets of consecutive columns or rows in each matrix. For active variables not declared as a matrix or array of matrices, zero is written to $(D_INLINECODE params).  For active variables not backed by a buffer object, -1 is written to $(D_INLINECODE params), regardless of the variable type. For the property $(D_INLINECODE GL_IS_ROW_MAJOR), a single integer identifying whether an active variable is a row-major matrix is written to $(D_INLINECODE params).  For active variables backed by a buffer object, declared as a single matrix or array of matrices, and stored in row-major order, one is written to $(D_INLINECODE params). For all other active variables, zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_INDEX), a single integer identifying the index of the active atomic counter buffer containing an active variable is written to $(D_INLINECODE params).  If the variable is not an atomic counter uniform, the value -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_BUFFER_BINDING), to index of the buffer binding point associated with the active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_BUFFER_DATA_SIZE), then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active variables associated with an active uniform block, shader storage block, or atomic counter buffer is written to $(D_INLINECODE params).  If the final member of an active shader storage block is array with no declared size, the minimum buffer size is computed assuming the array was declared as an array with one element. For the property $(D_INLINECODE GL_NUM_ACTIVE_VARIABLES), the number of active variables associated with an active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_ACTIVE_VARIABLES), an array of active variable indices associated with an active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to $(D_INLINECODE params).  The number of values written to $(D_INLINECODE params) for an active resource is given by the value of the property $(D_INLINECODE GL_NUM_ACTIVE_VARIABLES) for the resource. For the properties $(D_INLINECODE GL_REFERENCED_BY_VERTEX_SHADER), $(D_INLINECODE GL_REFERENCED_BY_TESS_CONTROL_SHADER), $(D_INLINECODE GL_REFERENCED_BY_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_REFERENCED_BY_GEOMETRY_SHADER), $(D_INLINECODE GL_REFERENCED_BY_FRAGMENT_SHADER), and $(D_INLINECODE GL_REFERENCED_BY_COMPUTE_SHADER), a single integer is written to $(D_INLINECODE params), identifying whether the active resource is referenced by the vertex, tessellation control, tessellation evaluation, geometry, or fragment shaders, respectively, in the program object.  The value one is written to $(D_INLINECODE params) if an active variable is referenced by the corresponding shader, or if an active uniform block, shader storage block, or atomic counter buffer contains at least one variable referenced by the corresponding shader.  Otherwise, the value zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_TOP_LEVEL_ARRAY_SIZE), a single integer identifying the number of active array elements of the top-level shader storage block member containing to the active variable is written to $(D_INLINECODE params).  If the top-level block member is not declared as an array, the value one is written to $(D_INLINECODE params).  If the top-level block member is an array with no declared size, the value zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_TOP_LEVEL_ARRAY_STRIDE), a single integer identifying the stride between array elements of the top-level shader storage block member containing the active variable is written to $(D_INLINECODE params).  For top-level block members declared as arrays, the value written is the difference, in basic machine units, between the offsets of the active variable for consecutive elements in the top-level array.  For top-level block members not declared as an array, zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_LOCATION), a single integer identifying the assigned location for an active uniform, input, output, or subroutine uniform variable is written to $(D_INLINECODE params).  For input, output, or uniform variables with locations specified by a layout qualifier, the specified location is used.  For vertex shader input or fragment shader output variables without a layout qualifier, the location assigned when a program is linked is written to $(D_INLINECODE params).  For all other input and output variables, the value -1 is written to $(D_INLINECODE params).  For uniforms in uniform blocks, the value -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_LOCATION_INDEX), a single integer identifying the fragment color index of an active fragment shader output variable is written to $(D_INLINECODE params).  If the active variable is an output for a non-fragment shader, the value -1 will be written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_IS_PER_PATCH), a single integer identifying whether the input or output is a per-patch attribute.  If the active variable is a per-patch attribute (declared with the $(D_INLINECODE patch) qualifier), the value one is written to $(D_INLINECODE params); otherwise, the value zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_LOCATION_COMPONENT), a single integer indicating the first component of the location assigned to an active input or output variable is written to $(D_INLINECODE params).  For input and output variables with a component specified by a $(D_INLINECODE layout) qualifier, the specified component is written. For all other input and output variables, the value zero is written. For the property $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_INDEX), a single integer identifying the index of the active transform feedback buffer associated with an active variable is written to $(D_INLINECODE params).  For variables corresponding to the special names $(D_INLINECODE "gl_NextBuffer"), $(D_INLINECODE "gl_SkipComponents1"), $(D_INLINECODE "gl_SkipComponents2"), $(D_INLINECODE "gl_SkipComponents3"), and $(D_INLINECODE "gl_SkipComponents4"), -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE), a single integer identifying the stride, in basic machine units, between consecutive vertices written to the transform feedback buffer is written to $(D_INLINECODE params).
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the resource named $(D_INLINECODE name).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceName), $(D_INLINECODE glGetProgramResourceIndex), $(D_INLINECODE glGetProgramResourceLocation), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const(GLenum)* props, GLsizei bufSize, GLsizei* length, GLint* params) @system @nogc nothrow;

    /++
     + glGetProgramResourceIndex: man4/glGetProgramResourceIndex.xml
     + 
     + $(D_INLINECODE glGetProgramResourceIndex) returns the unsigned integer index assigned to a resource named $(D_INLINECODE name) in the interface type $(D_INLINECODE programInterface) of program object $(D_INLINECODE program). $(D_INLINECODE program) must be the name of an existing program object. $(D_INLINECODE programInterface) is the name of the interface within $(D_INLINECODE program) which contains the resource named $(D_INLINECODE name) and must be one of the following values: If $(D_INLINECODE name) exactly matches the name string of one of the active resources for $(D_INLINECODE programInterface), the index of the matched resource is returned. Additionally, if $(D_INLINECODE name) would exactly match the name string of an active resource if "[0]" were appended to $(D_INLINECODE name), the index of the matched resource is returned.  Otherwise, $(D_INLINECODE name) is considered not to be the name of an active resource, and $(D_INLINECODE GL_INVALID_INDEX) is returned. For the interface $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING), the value $(D_INLINECODE GL_INVALID_INDEX) should be returned when querying the index assigned to the special names $(D_INLINECODE gl_NextBuffer), $(D_INLINECODE gl_SkipComponents1), $(D_INLINECODE gl_SkipComponents2), $(D_INLINECODE gl_SkipComponents3), or $(D_INLINECODE gl_SkipComponents4).
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the resource named $(D_INLINECODE name).
     +     name             = The name of the resource to query the index of.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceName), $(D_INLINECODE glGetProgramResource), $(D_INLINECODE glGetProgramResourceLocation), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char* name) @system @nogc nothrow;

    /++
     + glGetProgramResourceLocation: man4/glGetProgramResourceLocation.xml
     + 
     + $(D_INLINECODE glGetProgramResourceLocation) returns the location assigned to the variable named $(D_INLINECODE name) in interface $(D_INLINECODE programInterface) of program object $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program that has been linked successfully. $(D_INLINECODE programInterface) must be one of $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT), $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM), or $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER). The value -1 will be returned if an error occurs, if $(D_INLINECODE name) does not identify an active variable on $(D_INLINECODE programInterface), or if $(D_INLINECODE name) identifies an active variable that does not have a valid location assigned, as described above.  The locations returned by these commands are the same locations returned when querying the $(D_INLINECODE GL_LOCATION) and $(D_INLINECODE GL_LOCATION_INDEX) resource properties. A string provided to $(D_INLINECODE glGetProgramResourceLocation) is considered to match an active variable if: $(OL $(LI the string exactly matches the name of the active variable) $(LI if the string identifies the base name of an active array, where the string would exactly match the name of the variable if the suffix "[0]" were appended to the string) $(LI if the string identifies an active element of the array, where the string ends with the concatenation of the "[" character, an integer identifying an array element, and the "]" character, the integer is less than the number of active elements of the array variable, and where the string would exactly match the enumerated name of the array if the decimal integer were replaced with zero.)) Any other string is considered not to identify an active variable.  If the string specifies an element of an array variable, $(D_INLINECODE glGetProgramResourceLocation) returns the location assigned to that element.  If it specifies the base name of an array, it identifies the resources associated with the first element of the array.
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the resource named $(D_INLINECODE name).
     +     name             = The name of the resource to query the location of.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceName), $(D_INLINECODE glGetProgramResourceIndex), $(D_INLINECODE glGetProgramResource), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char* name) @system @nogc nothrow;

    /++
     + glGetProgramResourceLocationIndex: man4/glGetProgramResourceLocationIndex.xml
     + 
     + $(D_INLINECODE glGetProgramResourceLocationIndex) returns the fragment color index assigned to the variable named $(D_INLINECODE name) in interface $(D_INLINECODE programInterface) of program object $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program that has been linked successfully. $(D_INLINECODE programInterface) must be $(D_INLINECODE GL_PROGRAM_OUTPUT). The value -1 will be returned if an error occurs, if $(D_INLINECODE name) does not identify an active variable on $(D_INLINECODE programInterface), or if $(D_INLINECODE name) identifies an active variable that does not have a valid location assigned, as described above.  The locations returned by these commands are the same locations returned when querying the $(D_INLINECODE GL_LOCATION) and $(D_INLINECODE GL_LOCATION_INDEX) resource properties. A string provided to $(D_INLINECODE glGetProgramResourceLocationIndex) is considered to match an active variable if: $(OL $(LI the string exactly matches the name of the active variable) $(LI if the string identifies the base name of an active array, where the string would exactly match the name of the variable if the suffix "[0]" were appended to the string) $(LI if the string identifies an active element of the array, where the string ends with the concatenation of the "[" character, an integer identifying an array element, and the "]" character, the integer is less than the number of active elements of the array variable, and where the string would exactly match the enumerated name of the array if the decimal integer were replaced with zero.)) Any other string is considered not to identify an active variable.  If the string specifies an element of an array variable, $(D_INLINECODE glGetProgramResourceLocation) returns the location assigned to that element.  If it specifies the base name of an array, it identifies the resources associated with the first element of the array.
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the resource named $(D_INLINECODE name).
     +     name             = The name of the resource to query the location of.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceName), $(D_INLINECODE glGetProgramResourceIndex), $(D_INLINECODE glGetProgramResource), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char* name) @system @nogc nothrow;

    /++
     + glGetProgramResourceName: man4/glGetProgramResourceName.xml
     + 
     + $(D_INLINECODE glGetProgramResourceName) retrieves the name string assigned to the single active resource with an index of $(D_INLINECODE index) in the interface $(D_INLINECODE programInterface) of program object $(D_INLINECODE program). $(D_INLINECODE index) must be less than the number of entries in the active resource list for $(D_INLINECODE programInterface). $(D_INLINECODE program) must be the name of an existing program object. $(D_INLINECODE programInterface) is the name of the interface within $(D_INLINECODE program) which contains the resource and must be one of the following values: The name string assigned to the active resource identified by $(D_INLINECODE index) is returned as a null-terminated string in the character array whose address is given in $(D_INLINECODE name).  The actual number of characters written into $(D_INLINECODE name), excluding the null terminator, is returned in $(D_INLINECODE length).  If $(D_INLINECODE length) is null, no length is returned.  The maximum
     +  number of characters that may be written into
     +  $(D_INLINECODE name), including the null terminator, is specified by $(D_INLINECODE bufSize).  If the length of the name string is greater than $(D_INLINECODE bufSize), the first $(D_INLINECODE bufSize) -1 characters of the name string will be written to $(D_INLINECODE name), followed by a null terminator.  If $(D_INLINECODE bufSize) is zero, no error will be generated but no characters will be written to $(D_INLINECODE name).  The length of the longest name string for $(D_INLINECODE programInterface) &gt;, including a null terminator, can be queried by calling $(D_INLINECODE glGetProgramInterface) with a $(D_INLINECODE pname) of $(D_INLINECODE GL_MAX_NAME_LENGTH).
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the indexed resource.
     +     index            = The index of the resource within $(D_INLINECODE programInterface) of $(D_INLINECODE program).
     +     bufSize          = The size of the character array whose address is given by $(D_INLINECODE name).
     +     length           = The address of a variable which will receive the length of the resource name.
     +     name             = The address of a character array into which will be written the name of the resource.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceIndex), $(D_INLINECODE glGetProgramResource), $(D_INLINECODE glGetProgramResourceLocation), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name) @system @nogc nothrow;

    /++
     + glGetProgramStage: man4/glGetProgramStage.xml
     + 
     + $(D_INLINECODE glGetProgramStage) queries a parameter of a shader stage attached to a program object. $(D_INLINECODE program) contains the name of the program to which the shader is attached. $(D_INLINECODE shadertype) specifies the stage from which to query the parameter. $(D_INLINECODE pname) specifies which parameter should be queried. The value or values of the parameter to be queried is returned in the variable whose address is given in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORMS), the number of active subroutine variables in the stage is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS), the number of active subroutine variable locations in the stage is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINES), the number of active subroutines in the stage is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH), the length of the longest subroutine uniform for the stage is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINE_MAX_LENGTH), the length of the longest subroutine name for the stage is returned in $(D_INLINECODE values). The returned name length includes space for the null-terminator. If there is no shader present of type $(D_INLINECODE shadertype), the returned value will be consistent with a shader containing no subroutines or subroutine uniforms.
     + 
     + Params:
     +     program    = Specifies the name of the program containing shader stage.
     +     shadertype = Specifies the shader stage from which to query for the subroutine parameter. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     pname      = Specifies the parameter of the shader to query. $(D_INLINECODE pname) must be $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORMS), $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS), $(D_INLINECODE GL_ACTIVE_SUBROUTINES), $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH), or $(D_INLINECODE GL_ACTIVE_SUBROUTINE_MAX_LENGTH).
     +     values     = Specifies the address of a variable into which the queried value or values will be placed.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint* values) @system @nogc nothrow;

    /++
     + glGetQueryIndexed: man4/glGetQueryIndexed.xml
     + 
     + $(D_INLINECODE glGetQueryIndexediv) returns in $(D_INLINECODE params) a selected parameter of the indexed query object target specified by $(D_INLINECODE target) and $(D_INLINECODE index). $(D_INLINECODE index) specifies the index of the query object target and must be between zero and a target-specific maxiumum. $(D_INLINECODE pname) names a specific query object target parameter.  When $(D_INLINECODE pname) is $(D_INLINECODE GL_CURRENT_QUERY), the name of the currently active query for the specified $(D_INLINECODE index) of $(D_INLINECODE target), or zero if no query is active, will be placed in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_QUERY_COUNTER_BITS), the implementation-dependent number of bits used to hold the result of queries for $(D_INLINECODE target) is returned in $(D_INLINECODE params).
     + 
     + The target $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) is available only if the GL version is 4.3 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params). Calling $(D_INLINECODE glGetQueryiv) is equivalent to calling $(D_INLINECODE glGetQueryIndexediv) with $(D_INLINECODE index) set to zero.
     + 
     + Params:
     +     target = Specifies a query object target. Must be $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE GL_TIME_ELAPSED), or $(D_INLINECODE GL_TIMESTAMP).
     +     index  = Specifies the index of the query object target.
     +     pname  = Specifies the symbolic name of a query object target parameter. Accepted values are $(D_INLINECODE GL_CURRENT_QUERY) or $(D_INLINECODE GL_QUERY_COUNTER_BITS).
     +     params = Returns the requested data.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetQueryiv: man4/glGetQueryiv.xml
     + 
     + $(D_INLINECODE glGetQueryiv) returns in $(D_INLINECODE params) a selected parameter of the query object target specified by $(D_INLINECODE target). $(D_INLINECODE pname) names a specific query object target parameter.  When $(D_INLINECODE pname) is $(D_INLINECODE GL_CURRENT_QUERY), the name of the currently active query for $(D_INLINECODE target), or zero if no query is active, will be placed in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_QUERY_COUNTER_BITS), the implementation-dependent number of bits used to hold the result of queries for $(D_INLINECODE target) is returned in $(D_INLINECODE params).
     + 
     + The target $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) is available only if the GL version is 4.3 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     target = Specifies a query object target. Must be $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE GL_TIME_ELAPSED), or $(D_INLINECODE GL_TIMESTAMP).
     +     pname  = Specifies the symbolic name of a query object target parameter. Accepted values are $(D_INLINECODE GL_CURRENT_QUERY) or $(D_INLINECODE GL_QUERY_COUNTER_BITS).
     +     params = Returns the requested data.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetQueryiv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetQueryObject: man4/glGetQueryObject.xml
     + 
     + $(D_INLINECODE glGetQueryObject) returns in $(D_INLINECODE params) a selected parameter of the query object specified by $(D_INLINECODE id). $(D_INLINECODE pname) names a specific query object parameter. $(D_INLINECODE pname) can be as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetQueryObject) implicitly flushes the GL pipeline so that any incomplete rendering delimited by the occlusion query completes in finite time. If multiple queries are issued using the same query object $(D_INLINECODE id) before calling $(D_INLINECODE glGetQueryObject), the results of the most recent query will be returned.  In this case, when issuing a new query, the results of the previous query are discarded. $(D_INLINECODE glGetQueryObjecti64v) and $(D_INLINECODE glGetQueryObjectui64v) are available only if the GL version is 3.3 or greater. $(D_INLINECODE GL_QUERY_RESULT_NO_WAIT) is accepted for $(D_INLINECODE pname) only if the GL version is 4.4 or greater. The $(D_INLINECODE GL_QUERY_RESULT_BUFFER) target is available only if the GL version is 4.4 or higher. On earlier versions of the GL, $(D_INLINECODE params) is always an address in client memory.
     + 
     + Params:
     +     id     = Specifies the name of a query object.
     +     pname  = Specifies the symbolic name of a query object parameter. Accepted values are $(D_INLINECODE GL_QUERY_RESULT) or $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE).
     +     params = If a buffer is bound to the $(D_INLINECODE GL_QUERY_RESULT_BUFFER) target, then $(D_INLINECODE params) is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to $(D_INLINECODE GL_QUERY_RESULT_BUFFER), then $(D_INLINECODE params) is treated as an address in client memory of a variable to receive the resulting data.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery), $(D_INLINECODE glQueryCounter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetQueryObjectiv(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetSamplerParameter: man4/glGetSamplerParameter.xml
     + 
     + $(D_INLINECODE glGetSamplerParameter) returns in $(D_INLINECODE params) the value or values of the sampler parameter specified as $(D_INLINECODE pname). $(D_INLINECODE sampler) defines the target sampler, and must be the name of an existing sampler object, returned from a previous call to $(D_INLINECODE glGenSamplers). $(D_INLINECODE pname) accepts the same symbols as $(D_INLINECODE glSamplerParameter), with the same interpretations:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetSamplerParameter) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     sampler = Specifies name of the sampler object from which to retrieve parameters.
     +     pname   = Specifies the symbolic name of a sampler parameter. $(D_INLINECODE GL_TEXTURE_MAG_FILTER), $(D_INLINECODE GL_TEXTURE_MIN_FILTER), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_LOD_BIAS), $(D_INLINECODE GL_TEXTURE_WRAP_S), $(D_INLINECODE GL_TEXTURE_WRAP_T), $(D_INLINECODE GL_TEXTURE_WRAP_R), $(D_INLINECODE GL_TEXTURE_BORDER_COLOR), $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), and $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC) are accepted.
     +     params  = Returns the sampler parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glSamplerParameter), $(D_INLINECODE glGenSamplers), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glSamplerParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetShader: man4/glGetShader.xml
     + 
     + $(D_INLINECODE glGetShader) returns in $(D_INLINECODE params) the value of a parameter for a specific shader object. The following parameters are defined:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     shader = Specifies the shader object to be queried.
     +     pname  = Specifies the object parameter. Accepted symbolic names are $(D_INLINECODE GL_SHADER_TYPE), $(D_INLINECODE GL_DELETE_STATUS), $(D_INLINECODE GL_COMPILE_STATUS), $(D_INLINECODE GL_INFO_LOG_LENGTH), $(D_INLINECODE GL_SHADER_SOURCE_LENGTH).
     +     params = Returns the requested object parameter.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glGetProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetShaderiv(GLuint shader, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetShaderInfoLog: man4/glGetShaderInfoLog.xml
     + 
     + $(D_INLINECODE glGetShaderInfoLog) returns the information log for the specified shader object. The information log for a shader object is modified when the shader is compiled. The string that is returned will be null terminated. $(D_INLINECODE glGetShaderInfoLog) returns in $(D_INLINECODE infoLog) as much of the information log as it can, up to a maximum of $(D_INLINECODE maxLength) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned information log can be obtained by calling $(D_INLINECODE glGetShader) with the value $(D_INLINECODE GL_INFO_LOG_LENGTH). The information log for a shader object is a string that may contain diagnostic messages, warning messages, and other information about the last compile operation. When a shader object is created, its information log will be a string of length 0.
     + 
     + The information log for a shader object is the OpenGL implementer's primary mechanism for conveying information about the compilation process. Therefore, the information log can be helpful to application developers during the development process, even when compilation is successful. Application developers should not expect different OpenGL implementations to produce identical information logs.
     + 
     + Params:
     +     shader    = Specifies the shader object whose information log is to be queried.
     +     maxLength = Specifies the size of the character buffer for storing the returned information log.
     +     length    = Returns the length of the string returned in $(D_INLINECODE infoLog) (excluding the null terminator).
     +     infoLog   = Specifies an array of characters that is used to return the information log.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glGetProgramInfoLog), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;

    /++
     + glGetShaderPrecisionFormat: man4/glGetShaderPrecisionFormat.xml
     + 
     + $(D_INLINECODE glGetShaderPrecisionFormat) retrieves the numeric range and precision for the implementation's representation of quantities in different numeric formats in specified shader type. $(D_INLINECODE shaderType) specifies the type of shader for which the numeric precision and range is to be retrieved and must be one of $(D_INLINECODE GL_VERTEX_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER). $(D_INLINECODE precisionType) specifies the numeric format to query and must be one of $(D_INLINECODE GL_LOW_FLOAT), $(D_INLINECODE GL_MEDIUM_FLOAT) $(D_INLINECODE GL_HIGH_FLOAT), $(D_INLINECODE GL_LOW_INT), $(D_INLINECODE GL_MEDIUM_INT), or $(D_INLINECODE GL_HIGH_INT). $(D_INLINECODE range) points to an array of two integers into which the format's numeric range will be returned. If min and max are the smallest values representable in the format, then the values returned are defined to be: $(D_INLINECODE range) [0] = floor(log2(|min|)) and $(D_INLINECODE range) [1] = floor(log2(|max|)). $(D_INLINECODE precision) specifies the address of an integer into which will be written the log2 value of the number of bits of precision of the format. If the smallest representable value greater than 1 is 1 +, then the integer addressed by $(D_INLINECODE precision) will contain floor(-log2(eps)).
     + 
     + Params:
     +     shaderType    = Specifies the type of shader whose precision to query. $(D_INLINECODE shaderType) must be $(D_INLINECODE GL_VERTEX_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     precisionType = Specifies the numeric format whose precision and range to query.
     +     range         = Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
     +     precision     = Specifies the address of an integer into which the numeric precision of the implementation is written.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint* range, GLint* precision) @system @nogc nothrow;

    /++
     + glGetShaderSource: man4/glGetShaderSource.xml
     + 
     + $(D_INLINECODE glGetShaderSource) returns the concatenation of the source code strings from the shader object specified by $(D_INLINECODE shader). The source code strings for a shader object are the result of a previous call to $(D_INLINECODE glShaderSource). The string returned by the function will be null terminated. $(D_INLINECODE glGetShaderSource) returns in $(D_INLINECODE source) as much of the source code string as it can, up to a maximum of $(D_INLINECODE bufSize) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned source code string can be obtained by calling $(D_INLINECODE glGetShader) with the value $(D_INLINECODE GL_SHADER_SOURCE_LENGTH).
     + 
     + Params:
     +     shader  = Specifies the shader object to be queried.
     +     bufSize = Specifies the size of the character buffer for storing the returned source code string.
     +     length  = Returns the length of the string returned in $(D_INLINECODE source) (excluding the null terminator).
     +     source  = Specifies an array of characters that is used to return the source code string.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source) @system @nogc nothrow;

    /++
     + glGetString: man4/glGetString.xml
     + 
     + $(D_INLINECODE glGetString) returns a pointer to a static string describing some aspect of the current GL connection. $(D_INLINECODE name) can be one of the following: $(D_INLINECODE glGetStringi) returns a pointer to a static string indexed by $(D_INLINECODE index). $(D_INLINECODE name) can be one of the following: Strings $(D_INLINECODE GL_VENDOR) and $(D_INLINECODE GL_RENDERER) together uniquely specify a platform. They do not change from release to release and should be used by platform-recognition algorithms. The $(D_INLINECODE GL_VERSION) and $(D_INLINECODE GL_SHADING_LANGUAGE_VERSION) strings begin with a version number. The version number uses one of these forms: Vendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information. All strings are null-terminated.
     + 
     + If an error is generated, $(D_INLINECODE glGetString) returns 0. The client and server may support different versions. $(D_INLINECODE glGetString) always returns a compatible version number. The release number always describes the server.
     + 
     + Params:
     +     name  = Specifies a symbolic constant, one of $(D_INLINECODE GL_VENDOR), $(D_INLINECODE GL_RENDERER), $(D_INLINECODE GL_VERSION), or $(D_INLINECODE GL_SHADING_LANGUAGE_VERSION). Additionally, $(D_INLINECODE glGetStringi) accepts the $(D_INLINECODE GL_EXTENSIONS) token.
     +     index = For $(D_INLINECODE glGetStringi), specifies the index of the string to return.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    const(GLubyte)* glGetString(GLenum name) @system @nogc nothrow;

    /++
     + glGetSubroutineIndex: man4/glGetSubroutineIndex.xml
     + 
     + $(D_INLINECODE glGetSubroutineIndex) returns the index of a subroutine uniform within a shader stage attached to a program object. $(D_INLINECODE program) contains the name of the program to which the shader is attached. $(D_INLINECODE shadertype) specifies the stage from which to query shader subroutine index. $(D_INLINECODE name) contains the null-terminated name of the subroutine uniform whose name to query. If $(D_INLINECODE name) is not the name of a subroutine uniform in the shader stage, $(D_INLINECODE GL_INVALID_INDEX) is returned, but no error is generated. If $(D_INLINECODE name) is the name of a subroutine uniform in the shader stage, a value between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINES) minus one will be returned. Subroutine indices are assigned using consecutive integers in the range from zero to the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINES) minus one for the shader stage.
     + 
     + Params:
     +     program    = Specifies the name of the program containing shader stage.
     +     shadertype = Specifies the shader stage from which to query for subroutine uniform index. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     name       = Specifies the name of the subroutine uniform whose index to query.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar* name) @system @nogc nothrow;

    /++
     + glGetSubroutineUniformLocation: man4/glGetSubroutineUniformLocation.xml
     + 
     + $(D_INLINECODE glGetSubroutineUniformLocation) returns the location of the subroutine uniform variable $(D_INLINECODE name) in the shader stage of type $(D_INLINECODE shadertype) attached to $(D_INLINECODE program), with behavior otherwise identical to $(D_INLINECODE glGetUniformLocation). If $(D_INLINECODE name) is not the name of a subroutine uniform in the shader stage, -1 is returned, but no error is generated. If $(D_INLINECODE name) is the name of a subroutine uniform in the shader stage, a value between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_LOCATIONS) minus one will be returned. Subroutine locations are assigned using consecutive integers in the range from zero to the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_LOCATIONS) minus one for the shader stage.  For active subroutine uniforms declared as arrays, the declared array elements are assigned consecutive locations.
     + 
     + Params:
     +     program    = Specifies the name of the program containing shader stage.
     +     shadertype = Specifies the shader stage from which to query for subroutine uniform index. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     name       = Specifies the name of the subroutine uniform whose index to query.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetUniformLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar* name) @system @nogc nothrow;

    /++
     + glGetSync: man4/glGetSync.xml
     + 
     + $(D_INLINECODE glGetSynciv) retrieves properties of a sync object. $(D_INLINECODE sync) specifies the name of the sync object whose properties to retrieve. On success, $(D_INLINECODE glGetSynciv) replaces up to $(D_INLINECODE bufSize) integers in $(D_INLINECODE values) with the corresponding property values of the object being queried.  The actual number of integers replaced is returned in the variable whose address is specified in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_OBJECT_TYPE), a single value representing the specific type of the sync object is placed in $(D_INLINECODE values). The only type supported is $(D_INLINECODE GL_SYNC_FENCE). If $(D_INLINECODE pname) is $(D_INLINECODE GL_SYNC_STATUS), a single value representing the status of the sync object ( $(D_INLINECODE GL_SIGNALED) or $(D_INLINECODE GL_UNSIGNALED) ) is placed in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_SYNC_CONDITION), a single value representing the condition of the sync object is placed in $(D_INLINECODE values). The only condition supported is $(D_INLINECODE GL_SYNC_GPU_COMMANDS_COMPLETE). If $(D_INLINECODE pname) is $(D_INLINECODE GL_SYNC_FLAGS), a single value representing the flags with which the sync object was created is placed in $(D_INLINECODE values). No flags are currently supported $(D_INLINECODE flags) is expected to be used in future extensions to the sync objects.. If an error occurs, nothing will be written to $(D_INLINECODE values) or $(D_INLINECODE length).
     + 
     + Params:
     +     sync    = Specifies the sync object whose properties to query.
     +     pname   = Specifies the parameter whose value to retrieve from the sync object specified in $(D_INLINECODE sync).
     +     bufSize = Specifies the size of the buffer whose address is given in $(D_INLINECODE values).
     +     length  = Specifies the address of an variable to receive the number of integers placed in $(D_INLINECODE values).
     +     values  = Specifies the address of an array to receive the values of the queried parameter.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;

    /++
     + glGetTexLevelParameter: man4/glGetTexLevelParameter.xml
     + 
     + $(D_INLINECODE glGetTexLevelParameterfv), $(D_INLINECODE glGetTexLevelParameteriv), $(D_INLINECODE glGetTextureLevelParameterfv) and $(D_INLINECODE glGetTextureLevelParameteriv) return in $(D_INLINECODE params) texture parameter values for a specific level-of-detail value, specified as $(D_INLINECODE level). For the first two functions, $(D_INLINECODE target) defines the target texture, either $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_1D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP). The remaining two take a $(D_INLINECODE texture) argument which specifies the name of the texture object. $(D_INLINECODE GL_MAX_TEXTURE_SIZE), and $(D_INLINECODE GL_MAX_3D_TEXTURE_SIZE) are not really descriptive enough. It has to report the largest square texture image that can be accommodated with mipmaps but a long skinny texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the user to more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot be accommodated, the texture state variables, which may be queried with $(D_INLINECODE glGetTexLevelParameter) and $(D_INLINECODE glGetTextureLevelParameter), are set to 0. If the texture can be accommodated, the texture state values will be set as they would be set for a non-proxy target. $(D_INLINECODE pname) specifies the texture parameter whose value or values will be returned. The accepted parameter names are as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetTexLevelParameter) returns the texture level parameters for the active texture unit. $(D_INLINECODE GL_TEXTURE_BUFFER_OFFSET) and $(D_INLINECODE GL_TEXTURE_BUFFER_SIZE) are available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glGetTexLevelParameterfv) and $(D_INLINECODE glGetTexLevelParameteriv) functions. Must be one of the following values: $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), $(D_INLINECODE GL_PROXY_TEXTURE_1D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), or $(D_INLINECODE GL_TEXTURE_BUFFER).
     +     texture = Specifies the texture object name for $(D_INLINECODE glGetTextureLevelParameterfv) and $(D_INLINECODE glGetTextureLevelParameteriv) functions.
     +     level   = Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the n th mipmap reduction image.
     +     pname   = Specifies the symbolic name of a texture parameter. $(D_INLINECODE GL_TEXTURE_WIDTH), $(D_INLINECODE GL_TEXTURE_HEIGHT), $(D_INLINECODE GL_TEXTURE_DEPTH), $(D_INLINECODE GL_TEXTURE_INTERNAL_FORMAT), $(D_INLINECODE GL_TEXTURE_RED_SIZE), $(D_INLINECODE GL_TEXTURE_GREEN_SIZE), $(D_INLINECODE GL_TEXTURE_BLUE_SIZE), $(D_INLINECODE GL_TEXTURE_ALPHA_SIZE), $(D_INLINECODE GL_TEXTURE_DEPTH_SIZE), $(D_INLINECODE GL_TEXTURE_COMPRESSED), $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE), and $(D_INLINECODE GL_TEXTURE_BUFFER_OFFSET) are accepted.
     +     params  = Returns the requested data.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetTexParameter: man4/glGetTexParameter.xml
     + 
     + $(D_INLINECODE glGetTexParameter) and $(D_INLINECODE glGetTextureParameter) return in $(D_INLINECODE params) the value or values of the texture parameter specified as $(D_INLINECODE pname). $(D_INLINECODE target) defines the target texture. $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional array, rectangle, cube-mapped or cube-mapped array, two-dimensional multisample, or two-dimensional multisample array texturing, respectively. $(D_INLINECODE pname) accepts the same symbols as $(D_INLINECODE glTexParameter), with the same interpretations: In addition to the parameters that may be set with $(D_INLINECODE glTexParameter), $(D_INLINECODE glGetTexParameter) and $(D_INLINECODE glGetTextureParameter) accept the following read-only parameters:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE) is available only if the GL version is 4.2 or greater. $(D_INLINECODE GL_DEPTH_STENCIL_TEXTURE_MODE), $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LEVEL), $(D_INLINECODE GL_TEXTURE_VIEW_NUM_LEVELS), $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LAYER), $(D_INLINECODE GL_TEXTURE_VIEW_NUM_LAYERS) and $(D_INLINECODE GL_TEXTURE_IMMUTABLE_LEVELS) are available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_TEXTURE_TARGET) are available only if the GL version is 4.5 or greater.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glGetTexParameterfv), $(D_INLINECODE glGetTexParameteriv), $(D_INLINECODE glGetTexParameterIiv), and $(D_INLINECODE glGetTexParameterIuiv) functions. $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_RECTANGLE), and $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) are accepted.
     +     texture = Specifies the texture object name for $(D_INLINECODE glGetTextureParameterfv), $(D_INLINECODE glGetTextureParameteriv), $(D_INLINECODE glGetTextureParameterIiv), and $(D_INLINECODE glGetTextureParameterIuiv) functions.
     +     pname   = Specifies the symbolic name of a texture parameter. $(D_INLINECODE GL_DEPTH_STENCIL_TEXTURE_MODE), $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE), $(D_INLINECODE GL_TEXTURE_BASE_LEVEL), $(D_INLINECODE GL_TEXTURE_BORDER_COLOR), $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC), $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT), $(D_INLINECODE GL_TEXTURE_IMMUTABLE_LEVELS), $(D_INLINECODE GL_TEXTURE_LOD_BIAS), $(D_INLINECODE GL_TEXTURE_MAG_FILTER), $(D_INLINECODE GL_TEXTURE_MAX_LEVEL), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_MIN_FILTER), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_SWIZZLE_R), $(D_INLINECODE GL_TEXTURE_SWIZZLE_G), $(D_INLINECODE GL_TEXTURE_SWIZZLE_B), $(D_INLINECODE GL_TEXTURE_SWIZZLE_A), $(D_INLINECODE GL_TEXTURE_SWIZZLE_RGBA), $(D_INLINECODE GL_TEXTURE_TARGET), $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LAYER), $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LEVEL), $(D_INLINECODE GL_TEXTURE_VIEW_NUM_LAYERS), $(D_INLINECODE GL_TEXTURE_VIEW_NUM_LEVELS), $(D_INLINECODE GL_TEXTURE_WRAP_S), $(D_INLINECODE GL_TEXTURE_WRAP_T), and $(D_INLINECODE GL_TEXTURE_WRAP_R) are accepted.
     +     params  = Returns the texture parameters.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexParameter), $(D_INLINECODE glTextureParameter), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glTextureStorage1D), $(D_INLINECODE glTextureStorage2D), $(D_INLINECODE glTextureStorage3D), $(D_INLINECODE glTextureView)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetTexParameterIiv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureParameteriv(GLuint texture, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint* params) @system @nogc nothrow;

    /++
     + glGetTextureSubImage: man4/glGetTextureSubImage.xml
     + 
     + $(D_INLINECODE glGetTextureSubImage) returns a texture subimage into pixels. $(D_INLINECODE texture) is the name of the source texture object and must not be a buffer or multisample texture. The effective $(D_INLINECODE target) parameter is the value of $(D_INLINECODE GL_TEXTURE_TARGET) for texture. $(D_INLINECODE Level), $(D_INLINECODE format), $(D_INLINECODE type) and $(D_INLINECODE pixels) have the same meaning as for $(D_INLINECODE glGetTexImage). $(D_INLINECODE bufSize) is the size of the buffer to receive the retrieved pixel data. For cube map textures, the behavior is as though $(D_INLINECODE GetTextureImage) were called, but only texels from the requested cube map faces (selected by $(D_INLINECODE zoffset) and $(D_INLINECODE depth), as described below) were returned. $(D_INLINECODE xoffset), $(D_INLINECODE yoffset) and $(D_INLINECODE zoffset) values indicate the position of the subregion to return. $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) indicate the size of the region to return. These parameters have the same meaning as for $(D_INLINECODE glTexSubImage3D), though for one- and two-dimensional textures there are extra restrictions, described in the errors section below. For one-dimensional array textures, $(D_INLINECODE yoffset) is interpreted as the first layer to access and $(D_INLINECODE height) is the number of layers to access. For two-dimensional array textures, $(D_INLINECODE zoffset) is interpreted as the first layer to access and $(D_INLINECODE depth) is the number of layers to access. Cube map textures are treated as an array of six slices in the z-dimension, where the value of $(D_INLINECODE zoffset) is interpreted as specifying the cube map face for the corresponding layer (as presented in the table below) and $(D_INLINECODE depth) is the number of faces to access: Layer number Cube Map Face 0 GL_TEXTURE_CUBE_MAP_POSITIVE_X 1 GL_TEXTURE_CUBE_MAP_NEGATIVE_X 2 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 3 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 4 GL_TEXTURE_CUBE_MAP_POSITIVE_Z 5 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z For cube map array textures, $(D_INLINECODE zoffset) is the first layer-face to access, and $(D_INLINECODE depth) is the number of layer-faces to access. A layer-face described by $k$ is translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$ and $$ face = k \bmod 6. $$ Component groups from the specified sub-region are packed and placed into memory as described for $(D_INLINECODE glGetTextureImage), starting with the texel at ( $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset) ).
     + 
     + Params:
     +     texture = Specifies the name of the source texture object. Must be $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) or $(D_INLINECODE GL_TEXTURE_RECTANGLE). In specific, buffer and multisample textures are not permitted.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     zoffset = Specifies a texel offset in the z direction within the texture array.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     +     depth   = Specifies the depth of the texture subimage.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_DEPTH_COMPONENT) and $(D_INLINECODE GL_STENCIL_INDEX).
     +     type    = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     bufSize = Specifies the size of the buffer to receive the retrieved pixel data.
     +     pixels  = Returns the texture subimage. Should be a pointer to an array of the type specified by $(D_INLINECODE type).
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTextureImage), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_get_texture_sub_image")
    void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;

    /++
     + glGetTransformFeedback: man4/glGetTransformFeedback.xml
     + 
     + In order to use the Transform Feedback functionality, you need to configure the Transform Feedback Buffer indexed bindings. This can be achieved by either using $(D_INLINECODE glBindBufferBase) or $(D_INLINECODE glBindBuffersBase) to associate whole buffer object storage to one of the Transform Feedback Binding Points, or by calling $(D_INLINECODE glBindBufferRange) or $(D_INLINECODE glBindBuffersRange) to use a region of a buffer object storage for the binding. You may want to (but are not required to) bind a Transform Feedback Object first, in order to cache the binding configuration. This usually allows you to restore the Transform Feedback configuration faster, than if you were to execute a list of API calls necessary to set up the Transform Feedback state of your liking. This reference page discusses two types of getters that operate on Transform Feedback Objects and their bindings. The first class operates on general Transform Feedback binding point and includes $(D_INLINECODE glGetTransformFeedbackiv) function. $(D_INLINECODE glGetTransformFeedbackiv) can be used to retrieve information about Transform Feedback object bound to the general Transform Feedback binding point, as configured with a $(D_INLINECODE glBindTransformFeedback) call. In this case, you can check: $(OL $(LI What the ID of the currently bound Transform Feedback Object is; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_BINDING) )) $(LI Whether the Transform Feedback process is currently paused; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PAUSED) )) $(LI Whether the Transform Feedback process has been begun and is currently undergoing; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_ACTIVE) ))) The latter class, which includes $(D_INLINECODE glGetTransformFeedbacki_v) and $(D_INLINECODE glGetTransformFeedbacki64_v) functions, can be used to check what the current configuration of each of the buffer object regions bound to Transform Feedback Buffer binding points is. This allows you to query for the following information: $(OL $(LI $(D_INLINECODE glGetTransformFeedbacki_v) only: What the ID of the Buffer Object bound to a Transform Feedback Binding Point of user-specified index is; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_BINDING) ).) $(LI $(D_INLINECODE glGetTransformFeedbacki64_v) only: What the start offset configured for the binding is; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_START) );) $(LI $(D_INLINECODE glGetTransformFeedbacki64_v) only: What the length of the region used for the binding is; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_SIZE) );))
     + 
     + Params:
     +     xfb   = The name of an existing transform feedback object, or zero for the default transform feedback object.
     +     pname = Property to use for the query. Must be one of the values: $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_BINDING), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_START), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_SIZE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PAUSED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_ACTIVE).
     +     index = Index of the transform feedback stream (for indexed state).
     +     param = The address of a buffer into which will be written the requested state information.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBuffersBase), $(D_INLINECODE glBindBuffersRange), $(D_INLINECODE glBindTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint* param) @system @nogc nothrow;

    /++
     + glGetTransformFeedbackVarying: man4/glGetTransformFeedbackVarying.xml
     + 
     + Information about the set of varying variables in a linked program that will be captured during transform feedback may be retrieved by calling $(D_INLINECODE glGetTransformFeedbackVarying). $(D_INLINECODE glGetTransformFeedbackVarying) provides information about the varying variable selected by $(D_INLINECODE index). An $(D_INLINECODE index) of 0 selects the first varying variable specified in the $(D_INLINECODE varyings) array passed to $(D_INLINECODE glTransformFeedbackVaryings), and an $(D_INLINECODE index) of the value of $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYINGS) minus one selects the last such variable. The name of the selected varying is returned as a null-terminated string in $(D_INLINECODE name). The actual number of characters written into $(D_INLINECODE name), excluding the null terminator, is returned in $(D_INLINECODE length). If $(D_INLINECODE length) is null, no length is returned. The maximum number of characters that may be written into
     +  $(D_INLINECODE name), including the null terminator, is specified by $(D_INLINECODE bufSize). The length of the longest varying name in program is given by $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH), which can be queried with $(D_INLINECODE glGetProgram). For the selected varying variable, its type is returned into $(D_INLINECODE type). The size of the varying is returned into $(D_INLINECODE size). The value in $(D_INLINECODE size) is in units of the type returned in $(D_INLINECODE type). The type returned can be any of the scalar, vector, or matrix attribute types returned by $(D_INLINECODE glGetActiveAttrib). If an error occurred, the return parameters $(D_INLINECODE length), $(D_INLINECODE size), $(D_INLINECODE type) and $(D_INLINECODE name) will be unmodified. This command will return as much information about the varying variables as possible. If no information is available, $(D_INLINECODE length) will be set to zero and $(D_INLINECODE name) will be an empty string. This situation could arise if $(D_INLINECODE glGetTransformFeedbackVarying) is called after a failed link.
     + 
     + Params:
     +     program = The name of the target program object.
     +     index   = The index of the varying variable whose information to retrieve.
     +     bufSize = The maximum number of characters, including the null terminator, that may be written into $(D_INLINECODE name).
     +     length  = The address of a variable which will receive the number of characters written into $(D_INLINECODE name), excluding the null-terminator. If $(D_INLINECODE length) is $(D_INLINECODE null) no length is returned.
     +     size    = The address of a variable that will receive the size of the varying.
     +     type    = The address of a variable that will recieve the type of the varying.
     +     name    = The address of a buffer into which will be written the name of the varying.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glTransformFeedbackVaryings), $(D_INLINECODE glGetProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name) @system @nogc nothrow;

    /++
     + glGetUniformBlockIndex: man4/glGetUniformBlockIndex.xml
     + 
     + $(D_INLINECODE glGetUniformBlockIndex) retrieves the index of a uniform block within $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program object for which the command $(D_INLINECODE glLinkProgram) must have been called in the past, although it is not required that $(D_INLINECODE glLinkProgram) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformBlockName) must contain a nul-terminated string specifying the name of the uniform block. $(D_INLINECODE glGetUniformBlockIndex) returns the uniform block index for the uniform block named $(D_INLINECODE uniformBlockName) of $(D_INLINECODE program). If $(D_INLINECODE uniformBlockName) does not identify an active uniform block of $(D_INLINECODE program), $(D_INLINECODE glGetUniformBlockIndex) returns the special identifier, $(D_INLINECODE GL_INVALID_INDEX). Indices of the active uniform blocks of a program are assigned in consecutive order, beginning with zero.
     + 
     + $(D_INLINECODE glGetUniformBlockIndex) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     program          = Specifies the name of a program containing the uniform block.
     +     uniformBlockName = Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniformBlockName), $(D_INLINECODE glGetActiveUniformBlock), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    GLuint glGetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName) @system @nogc nothrow;

    /++
     + glGetUniformIndices: man4/glGetUniformIndices.xml
     + 
     + $(D_INLINECODE glGetUniformIndices) retrieves the indices of a number of uniforms within $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program object for which the command $(D_INLINECODE glLinkProgram) must have been called in the past, although it is not required that $(D_INLINECODE glLinkProgram) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformCount) indicates both the number of elements in the array of names $(D_INLINECODE uniformNames) and the number of indices that may be written to $(D_INLINECODE uniformIndices). $(D_INLINECODE uniformNames) contains a list of $(D_INLINECODE uniformCount) name strings identifying the uniform names to be queried for indices. For each name string in $(D_INLINECODE uniformNames), the index assigned to the active uniform of that name will be written to the corresponding element of $(D_INLINECODE uniformIndices). If a string in $(D_INLINECODE uniformNames) is not the name of an active uniform, the special value $(D_INLINECODE GL_INVALID_INDEX) will be written to the corresponding element of $(D_INLINECODE uniformIndices). If an error occurs, nothing is written to $(D_INLINECODE uniformIndices).
     + 
     + $(D_INLINECODE glGetUniformIndices) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     program        = Specifies the name of a program containing uniforms whose indices to query.
     +     uniformCount   = Specifies the number of uniforms whose indices to query.
     +     uniformNames   = Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
     +     uniformIndices = Specifies the address of an array that will receive the indices of the uniforms.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetActiveUniformName), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices) @system @nogc nothrow;

    /++
     + glGetUniformLocation: man4/glGetUniformLocation.xml
     + 
     + $(D_INLINECODE glGetUniformLocation) returns an integer that represents the location of a specific uniform variable within a program object. $(D_INLINECODE name) must be a null terminated string that contains no white space. $(D_INLINECODE name) must be an active uniform variable name in $(D_INLINECODE program) that is not a structure, an array of structures, or a subcomponent of a vector or a matrix. This function returns -1 if $(D_INLINECODE name) does not correspond to an active uniform variable in $(D_INLINECODE program), if $(D_INLINECODE name) starts with the reserved prefix &quot;gl_&quot;, or if $(D_INLINECODE name) is associated with an atomic counter or a named uniform block. Uniform variables that are structures or arrays of structures may be queried by calling $(D_INLINECODE glGetUniformLocation) for each field within the structure. The array element operator &quot;[]&quot; and the structure field operator &quot;.&quot; may be used in $(D_INLINECODE name) in order to select elements within an array or fields within a structure. The result of using these operators is not allowed to be another structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last part of $(D_INLINECODE name) indicates a uniform variable array, the location of the first element of an array can be retrieved by using the name of the array, or by using the name appended by &quot;[0]&quot;. The actual locations assigned to uniform variables are not known until the program object is linked successfully. After linking has occurred, the command $(D_INLINECODE glGetUniformLocation) can be used to obtain the location of a uniform variable. This location value can then be passed to $(D_INLINECODE glUniform) to set the value of the uniform variable or to $(D_INLINECODE glGetUniform) in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. Uniform variable locations and values can only be queried after a link if the link was successful.
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     name    = Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLint glGetUniformLocation(GLuint program, const GLchar* name) @system @nogc nothrow;

    /++
     + glGetUniformSubroutine: man4/glGetUniformSubroutine.xml
     + 
     + $(D_INLINECODE glGetUniformSubroutine) retrieves the value of the subroutine uniform at location $(D_INLINECODE location) for shader stage $(D_INLINECODE shadertype) of the current program. $(D_INLINECODE location) must be less than the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS) for the shader currently in use at shader stage $(D_INLINECODE shadertype). The value of the subroutine uniform is returned in $(D_INLINECODE values).
     + 
     + Params:
     +     shadertype = Specifies the shader stage from which to query for subroutine uniform index. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     location   = Specifies the location of the subroutine uniform.
     +     values     = Specifies the address of a variable to receive the value or values of the subroutine uniform.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetUniformLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint* values) @system @nogc nothrow;

    /++
     + glGetVertexArrayIndexed: man4/glGetVertexArrayIndexed.xml
     + 
     + $(D_INLINECODE glGetVertexArrayIndexediv) and $(D_INLINECODE glGetVertexArrayIndexed64iv) provide a way of querying parameters of an attribute at an user-specified index of a vertex array object. The vertex array object does not have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this call. The following parameter values can be retrieved with $(D_INLINECODE glGetVertexArrayIndexediv) for each of the attributes defined for a vertex array object: $(OL $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_ENABLED) : $(D_INLINECODE param) returns a value that is non-zero (true) if the vertex attribute array for index is enabled and 0 (false) if it is disabled. The initial value is $(D_INLINECODE GL_FALSE).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_SIZE) : $(D_INLINECODE param) returns a single value, the size of the vertex attribute array for index. The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3 or 4. The initial value is 4.) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_STRIDE) : $(D_INLINECODE param) returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for index. A value of 0 indicates the array elements are stored sequentially in memory. The initial value is 0.) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_TYPE) : $(D_INLINECODE param) returns a single value, a symbolic constant indicating the array type for the vertex attribute array for index. Possible values are $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_FIXED), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_HALF_FLOAT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_INT_2_10_10_10_REV), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), and $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV). The initial value is $(D_INLINECODE GL_FLOAT).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_NORMALIZED) : $(D_INLINECODE param) returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index are normalized when they are converted to floating-point, and 0 (false) otherwise. The initial value is $(D_INLINECODE GL_FALSE).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_INTEGER) : $(D_INLINECODE param) returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index have integer data type, and 0 (false) otherwise. The initial value is 0 ( $(D_INLINECODE GL_FALSE) ).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_LONG) : $(D_INLINECODE param) returns a single value that is non-zero (true) if a vertex attribute is stored as an unconverted double, and 0 (false) otherwise. The initial value is 0 ( $(D_INLINECODE GL_FALSE) ).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_DIVISOR) : $(D_INLINECODE param) returns a single value that is the frequency divisor used for instanced rendering. See glVertexAttribDivisor. The initial value is 0.) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_RELATIVE_OFFSET) : $(D_INLINECODE param) returns a single value that is the byte offset of the first element relative to the start of the vertex buffer binding specified attribute fetches from. The initial value is 0.)) $(D_INLINECODE glGetVertexArrayIndexed64iv) can be used to retrieve $(D_INLINECODE GL_VERTEX_BINDING_OFFSET) parameter value for any of the attributes defined for a vertex array object. When $(D_INLINECODE pname) is set to $(D_INLINECODE GL_VERTEX_BINDING_OFFSET), $(D_INLINECODE param) returns a single value that is the byte offset of the first element in the bound buffer's data store. The initial value for this parameter is 0.
     + 
     + Params:
     +     vaobj = Specifies the name of a vertex array object.
     +     index = Specifies the index of the vertex array object attribute. Must be a number between 0 and ( $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS) - 1).
     +     pname = Specifies the property to be used for the query. For $(D_INLINECODE glGetVertexArrayIndexediv), it must be one of the following values: $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_ENABLED), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_SIZE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_STRIDE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_TYPE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_NORMALIZED), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_INTEGER), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_LONG), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_DIVISOR), or $(D_INLINECODE GL_VERTEX_ATTRIB_RELATIVE_OFFSET). For $(D_INLINECODE glGetVertexArrayIndexed64v), it must be equal to $(D_INLINECODE GL_VERTEX_BINDING_OFFSET).
     +     param = Returns the requested value.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetVertexAttrib), $(D_INLINECODE glVertexAttribBinding), $(D_INLINECODE glVertexAttribIPointer), $(D_INLINECODE glVertexAttribLPointer), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64* param) @system @nogc nothrow;

    /++
     + glGetVertexArrayiv: man4/glGetVertexArrayiv.xml
     + 
     + This function provides a mean of querying properties of an existing vertex array object. The vertex array object does not have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this call. $(D_INLINECODE glGetVertexArrayiv) can be used to retrieve ID of a buffer object that will be bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding point whenever the queried vertex array object is bound to the rendering context. The binding can be changed for an active vertex array object with a $(D_INLINECODE glBindBuffer) call.
     + 
     + Params:
     +     vaobj = specifies the name of the vertex array object to use for the query.
     +     pname = Name of the property to use for the query. Must be $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER_BINDING).
     +     param = Returns the requested value.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindVertexArray), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint* param) @system @nogc nothrow;

    /++
     + glGetVertexAttrib: man4/glGetVertexAttrib.xml
     + 
     + $(D_INLINECODE glGetVertexAttrib) returns in $(D_INLINECODE params) the value of a generic vertex attribute parameter. The generic vertex attribute to be queried is specified by $(D_INLINECODE index), and the parameter to be queried is specified by $(D_INLINECODE pname). The accepted parameter names are as follows: All of the parameters except $(D_INLINECODE GL_CURRENT_VERTEX_ATTRIB) represent state stored in the currently bound vertex array object.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     index  = Specifies the generic vertex attribute parameter to be queried.
     +     pname  = Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_ENABLED), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_SIZE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_STRIDE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_TYPE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_NORMALIZED), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_INTEGER), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_DIVISOR), or $(D_INLINECODE GL_CURRENT_VERTEX_ATTRIB).
     +     params = Returns the requested data.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribDivisor), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;

    /++
     + glGetVertexAttribPointerv: man4/glGetVertexAttribPointerv.xml
     + 
     + $(D_INLINECODE glGetVertexAttribPointerv) returns pointer information. $(D_INLINECODE index) is the generic vertex attribute to be queried, $(D_INLINECODE pname) is a symbolic constant indicating the pointer to be returned, and $(D_INLINECODE params) is a pointer to a location in which to place the returned data. The $(D_INLINECODE pointer) returned is a byte offset into the data store of the buffer object that was bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) when the desired pointer was previously specified.
     + 
     + The state returned is retrieved from the currently bound vertex array object. The initial value for each pointer is 0.
     + 
     + Params:
     +     index   = Specifies the generic vertex attribute parameter to be returned.
     +     pname   = Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_POINTER).
     +     pointer = Returns the pointer value.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer) @system @nogc nothrow;

    /++
     + glHint: man4/glHint.xml
     + 
     + Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified with two arguments. $(D_INLINECODE target) is a symbolic constant indicating the behavior to be controlled, and $(D_INLINECODE mode) is another symbolic constant indicating the desired behavior. The initial value for each $(D_INLINECODE target) is $(D_INLINECODE GL_DONT_CARE). $(D_INLINECODE mode) can be one of the following: Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation. The hint aspects that can be specified with $(D_INLINECODE target), along with suggested semantics, are as follows:
     + 
     + The interpretation of hints depends on the implementation. Some implementations ignore $(D_INLINECODE glHint) settings.
     + 
     + Params:
     +     target = Specifies a symbolic constant indicating the behavior to be controlled. $(D_INLINECODE GL_LINE_SMOOTH_HINT), $(D_INLINECODE GL_POLYGON_SMOOTH_HINT), $(D_INLINECODE GL_TEXTURE_COMPRESSION_HINT), and $(D_INLINECODE GL_FRAGMENT_SHADER_DERIVATIVE_HINT) are accepted.
     +     mode   = Specifies a symbolic constant indicating the desired behavior. $(D_INLINECODE GL_FASTEST), $(D_INLINECODE GL_NICEST), and $(D_INLINECODE GL_DONT_CARE) are accepted.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glHint(GLenum target, GLenum mode) @system @nogc nothrow;

    /++
     + glInvalidateBufferData: man4/glInvalidateBufferData.xml
     + 
     + $(D_INLINECODE glInvalidateBufferData) invalidates all of the content of the data store of a buffer object. After invalidation, the content of the buffer's data store becomes undefined.
     + 
     + Params:
     +     buffer = The name of a buffer object whose data store to invalidate.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage),, $(D_INLINECODE glInvalidateTexImage), $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateFramebuffer), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateBufferData(GLuint buffer) @system @nogc nothrow;

    /++
     + glInvalidateBufferSubData: man4/glInvalidateBufferSubData.xml
     + 
     + $(D_INLINECODE glInvalidateBufferSubData) invalidates all or part of the content of the data store of a buffer object. After invalidation, the content of the specified range of the buffer's data store becomes undefined. The start of the range is given by $(D_INLINECODE offset) and its size is given by $(D_INLINECODE length), both measured in basic machine units.
     + 
     + Params:
     +     buffer = The name of a buffer object, a subrange of whose data store to invalidate.
     +     offset = The offset within the buffer's data store of the start of the range to be invalidated.
     +     length = The length of the range within the buffer's data store to be invalidated.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage),, $(D_INLINECODE glInvalidateTexImage), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateFramebuffer), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;

    /++
     + glInvalidateFramebuffer: man4/glInvalidateFramebuffer.xml
     + 
     + $(D_INLINECODE glInvalidateFramebuffer) and $(D_INLINECODE glInvalidateNamedFramebufferData) invalidate the entire contents of a specified set of attachments of a framebuffer. For $(D_INLINECODE glInvalidateFramebuffer), the framebuffer object is that bound to $(D_INLINECODE target). $(D_INLINECODE target) must be $(D_INLINECODE GL_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_DRAW_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). Default framebuffers may also be invalidated if bound to $(D_INLINECODE target). For $(D_INLINECODE glInvalidateNamedFramebufferData), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, the default draw framebuffer is affected. The set of attachments whose contents are to be invalidated are specified in the $(D_INLINECODE attachments) array, which contains $(D_INLINECODE numAttachments) elements. If the specified framebuffer is a framebuffer object, each element of $(D_INLINECODE attachments) must be one of $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT), or $(D_INLINECODE GL_COLOR_ATTACHMENT), where is between zero and the value of $(D_INLINECODE GL_MAX_FRAMEBUFFER_ATTACHMENTS) minus one. If the specified framebuffer is a default framebuffer, each element of $(D_INLINECODE attachments) must be one of $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_AUX), $(D_INLINECODE GL_ACCUM), $(D_INLINECODE GL_COLOR), $(D_INLINECODE GL_DEPTH), or $(D_INLINECODE GL_STENCIL). $(D_INLINECODE GL_COLOR), is treated as $(D_INLINECODE GL_BACK_LEFT) for a double-buffered context and $(D_INLINECODE GL_FRONT_LEFT) for a single-buffered context. The other attachments identify the corresponding specific buffer. The entire contents of each specified attachment become undefined after execution of $(D_INLINECODE glInvalidateFramebuffer) or $(D_INLINECODE glInvalidateNamedFramebufferData). If the framebuffer object is not complete, $(D_INLINECODE glInvalidateFramebuffer) and $(D_INLINECODE glInvalidateNamedFramebufferData) may be ignored. This is not an error.
     + 
     + Params:
     +     target         = Specifies the target to which the framebuffer object is attached for $(D_INLINECODE glInvalidateFramebuffer).
     +     framebuffer    = Specifies the name of the framebuffer object for $(D_INLINECODE glInvalidateNamedFramebufferData).
     +     numAttachments = Specifies the number of entries in the $(D_INLINECODE attachments) array.
     +     attachments    = Specifies a pointer to an array identifying the attachments to be invalidated.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage), $(D_INLINECODE glInvalidateTexImage), $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments) @system @nogc nothrow;

    /++
     + glInvalidateNamedFramebufferSubData: man4/glInvalidateSubFramebuffer.xml
     + 
     + $(D_INLINECODE glInvalidateSubFramebuffer) and $(D_INLINECODE glInvalidateNamedFramebufferSubData) invalidate the contents of a specified region of a specified set of attachments of a framebuffer. For $(D_INLINECODE glInvalidateSubFramebuffer), the framebuffer object is that bound to $(D_INLINECODE target), which must be one of $(D_INLINECODE GL_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_DRAW_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). Default framebuffers may also be invalidated if bound to $(D_INLINECODE target). For $(D_INLINECODE glInvalidateNamedFramebufferSubData), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, the default draw framebuffer is affected. The set of attachments of which a region is to be invalidated are specified in the $(D_INLINECODE attachments) array, which contains $(D_INLINECODE numAttachments) elements. If the specified framebuffer is a framebuffer object, each element of $(D_INLINECODE attachments) must be one of $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT), or $(D_INLINECODE GL_COLOR_ATTACHMENT), where is between zero and the value of $(D_INLINECODE GL_MAX_FRAMEBUFFER_ATTACHMENTS) minus one. If the specified framebuffer is a default framebuffer, each element of $(D_INLINECODE attachments) must be one of $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_AUX), $(D_INLINECODE GL_ACCUM), $(D_INLINECODE GL_COLOR), $(D_INLINECODE GL_DEPTH), or $(D_INLINECODE GL_STENCIL). $(D_INLINECODE GL_COLOR), is treated as $(D_INLINECODE GL_BACK_LEFT) for a double-buffered context and $(D_INLINECODE GL_FRONT_LEFT) for a single-buffered context. The other attachments identify the corresponding specific buffer. The contents of the specified region of each specified attachment become undefined after execution of $(D_INLINECODE glInvalidateSubFramebuffer) or $(D_INLINECODE glInvalidateNamedFramebufferSubData). The region to be invalidated is specified by $(D_INLINECODE x), $(D_INLINECODE y), $(D_INLINECODE width) and $(D_INLINECODE height) where $(D_INLINECODE x) and $(D_INLINECODE y) give the offset from the origin (with lower-left corner at $(0,0)$) and $(D_INLINECODE width) and $(D_INLINECODE height) are the width and height, respectively, of the region. Any pixels lying outside of the window allocated to the current GL context (for the default framebuffer), or outside of the attachments of the framebuffer object, are ignored. If the framebuffer object is not complete, these commands may be ignored. If the framebuffer object is not complete, $(D_INLINECODE glInvalidateSubFramebuffer) and $(D_INLINECODE glInvalidateNamedFramebufferSubData) may be ignored. This is not an error.
     + 
     + Params:
     +     target         = Specifies the target to which the framebuffer object is attached for $(D_INLINECODE glInvalidateSubFramebuffer).
     +     framebuffer    = Specifies the name of the framebuffer object for $(D_INLINECODE glInvalidateNamedFramebufferSubData).
     +     numAttachments = Specifies the number of entries in the $(D_INLINECODE attachments) array.
     +     attachments    = Specifies a pointer to an array identifying the attachments to be invalidated.
     +     x              = Specifies the X offset of the region to be invalidated.
     +     y              = Specifies the Y offset of the region to be invalidated.
     +     width          = Specifies the width of the region to be invalidated.
     +     height         = Specifies the height of the region to be invalidated.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage), $(D_INLINECODE glInvalidateTexImage), $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLint width, GLint height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glInvalidateTexImage: man4/glInvalidateTexImage.xml
     + 
     + $(D_INLINECODE glInvalidateTexSubImage) invalidates all of a texture image. $(D_INLINECODE texture) and $(D_INLINECODE level) indicated which texture image is being invalidated. After this command, data in the texture image has undefined values. $(D_INLINECODE level) must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height, or depth. For textures of targets $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), level must be zero.
     + 
     + Params:
     +     texture = The name of a texture object to invalidate.
     +     level   = The level of detail of the texture object to invalidate.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage),, $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateFramebuffer), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateTexImage(GLuint texture, GLint level) @system @nogc nothrow;

    /++
     + glInvalidateTexSubImage: man4/glInvalidateTexSubImage.xml
     + 
     + $(D_INLINECODE glInvalidateTexSubImage) invalidates all or part of a texture image. $(D_INLINECODE texture) and $(D_INLINECODE level) indicated which texture image is being invalidated. After this command, data in that subregion have undefined values. $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset), $(D_INLINECODE width), $(D_INLINECODE height), and $(D_INLINECODE depth) are interpreted as they are in $(D_INLINECODE glTexSubImage3D). For texture targets that don't have certain dimensions, this command treats those dimensions as having a size of 1. For example, to invalidate a portion of a two- dimensional texture, the application would use $(D_INLINECODE zoffset) equal to zero and $(D_INLINECODE depth) equal to one. Cube map textures are treated as an array of six slices in the z-dimension, where a value of $(D_INLINECODE zoffset) is interpreted as specifying face $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X) + $(D_INLINECODE zoffset). $(D_INLINECODE level) must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height, or depth. $(D_INLINECODE xoffset), $(D_INLINECODE yoffset) and $(D_INLINECODE zoffset) must be greater than or equal to zero and be less than the width, height or depth of the image, respectively. Furthermore, $(D_INLINECODE xoffset) + $(D_INLINECODE width), $(D_INLINECODE yoffset) + $(D_INLINECODE height), and $(D_INLINECODE zoffset) + $(D_INLINECODE depth) must be less than or equal to the width, height or depth of the image, respectively. For textures of targets $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), level must be zero.
     + 
     + Params:
     +     texture = The name of a texture object a subregion of which to invalidate.
     +     level   = The level of detail of the texture object within which the region resides.
     +     xoffset = The X offset of the region to be invalidated.
     +     yoffset = The Y offset of the region to be invalidated.
     +     zoffset = The Z offset of the region to be invalidated.
     +     width   = The width of the region to be invalidated.
     +     height  = The height of the region to be invalidated.
     +     depth   = The depth of the region to be invalidated.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexImage),, $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateFramebuffer), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;

    /++
     + glIsBuffer: man4/glIsBuffer.xml
     + 
     + $(D_INLINECODE glIsBuffer) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE buffer) is currently the name of a buffer object. If $(D_INLINECODE buffer) is zero, or is a non-zero value that is not currently the name of a buffer object, or if an error occurs, $(D_INLINECODE glIsBuffer) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenBuffers), but not yet associated with a buffer object by calling $(D_INLINECODE glBindBuffer), is not the name of a buffer object.
     + 
     + Params:
     +     buffer = Specifies a value that may be the name of a buffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGenBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    GLboolean glIsBuffer(GLuint buffer) @system @nogc nothrow;

    /++
     + glIsEnabled: man4/glIsEnabled.xml
     + 
     + $(D_INLINECODE glIsEnabled) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE cap) is an enabled capability and returns $(D_INLINECODE GL_FALSE) otherwise. Boolean states that are indexed may be tested with $(D_INLINECODE glIsEnabledi). For $(D_INLINECODE glIsEnabledi), $(D_INLINECODE index) specifies the index of the capability to test. $(D_INLINECODE index) must be between zero and the count of indexed capabilities for $(D_INLINECODE cap). Initially all capabilities except $(D_INLINECODE GL_DITHER) are disabled; $(D_INLINECODE GL_DITHER) is initially enabled. The following capabilities are accepted for $(D_INLINECODE cap) : $(B Constant) $(B See) $(D_INLINECODE GL_BLEND) $(D_INLINECODE glBlendFunc), $(D_INLINECODE glLogicOp) $(D_INLINECODE GL_CLIP_DISTANCE) $(D_INLINECODE glEnable) $(D_INLINECODE GL_COLOR_LOGIC_OP) $(D_INLINECODE glLogicOp) $(D_INLINECODE GL_CULL_FACE) $(D_INLINECODE glCullFace) $(D_INLINECODE GL_DEPTH_CLAMP) $(D_INLINECODE glEnable) $(D_INLINECODE GL_DEBUG_OUTPUT) $(D_INLINECODE glEnable) $(D_INLINECODE GL_DEBUG_OUTPUT_SYNCHRONOUS) $(D_INLINECODE glEnable) $(D_INLINECODE GL_DEPTH_TEST) $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange) $(D_INLINECODE GL_DITHER) $(D_INLINECODE glEnable) $(D_INLINECODE GL_FRAMEBUFFER_SRGB) $(D_INLINECODE glEnable) $(D_INLINECODE GL_LINE_SMOOTH) $(D_INLINECODE glLineWidth) $(D_INLINECODE GL_MULTISAMPLE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_POLYGON_SMOOTH) $(D_INLINECODE glPolygonMode) $(D_INLINECODE GL_POLYGON_OFFSET_FILL) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_POLYGON_OFFSET_LINE) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_POLYGON_OFFSET_POINT) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_PROGRAM_POINT_SIZE) $(D_INLINECODE glEnable) $(D_INLINECODE GL_PRIMITIVE_RESTART) $(D_INLINECODE glEnable), $(D_INLINECODE glPrimitiveRestartIndex) $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SAMPLE_COVERAGE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SAMPLE_MASK) $(D_INLINECODE glEnable) $(D_INLINECODE GL_SCISSOR_TEST) $(D_INLINECODE glScissor) $(D_INLINECODE GL_STENCIL_TEST) $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilOp) $(D_INLINECODE GL_TEXTURE_CUBE_MAP_SEAMLESS) $(D_INLINECODE glEnable)
     + 
     + If an error is generated, $(D_INLINECODE glIsEnabled) and $(D_INLINECODE glIsEnabledi) return $(D_INLINECODE GL_FALSE). $(D_INLINECODE GL_DEBUG_OUTPUT) and $(D_INLINECODE GL_DEBUG_OUTPUT_SYNCHRONOUS) are available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     cap   = Specifies a symbolic constant indicating a GL capability.
     +     index = Specifies the index of the capability.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glDisable), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLboolean glIsEnabled(GLenum cap) @system @nogc nothrow;

    /++
     + glIsFramebuffer: man4/glIsFramebuffer.xml
     + 
     + $(D_INLINECODE glIsFramebuffer) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE framebuffer) is currently the name of a framebuffer object. If $(D_INLINECODE framebuffer) is zero, or if $(D_INLINECODE framebuffer) is not the name of a framebuffer object, or if an error occurs, $(D_INLINECODE glIsFramebuffer) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE framebuffer) is a name returned by $(D_INLINECODE glGenFramebuffers), by that has not yet been bound through a call to $(D_INLINECODE glBindFramebuffer), then the name is not a framebuffer object and $(D_INLINECODE glIsFramebuffer) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     framebuffer = Specifies a value that may be the name of a framebuffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glDeleteFramebuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    GLboolean glIsFramebuffer(GLuint framebuffer) @system @nogc nothrow;

    /++
     + glIsProgram: man4/glIsProgram.xml
     + 
     + $(D_INLINECODE glIsProgram) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE program) is the name of a program object previously created with $(D_INLINECODE glCreateProgram) and not yet deleted with $(D_INLINECODE glDeleteProgram). If $(D_INLINECODE program) is zero or a non-zero value that is not the name of a program object, or if an error occurs, $(D_INLINECODE glIsProgram) returns $(D_INLINECODE GL_FALSE).
     + 
     + No error is generated if $(D_INLINECODE program) is not a valid program object name. A program object marked for deletion with $(D_INLINECODE glDeleteProgram) but still in use as part of current rendering state is still considered a program object and $(D_INLINECODE glIsProgram) will return $(D_INLINECODE GL_TRUE).
     + 
     + Params:
     +     program = Specifies a potential program object.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLboolean glIsProgram(GLuint program) @system @nogc nothrow;

    /++
     + glIsProgramPipeline: man4/glIsProgramPipeline.xml
     + 
     + $(D_INLINECODE glIsProgramPipeline) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE pipeline) is currently the name of a program pipeline object. If $(D_INLINECODE pipeline) is zero, or if $(D_INLINECODE pipeline) is not the name of a program pipeline object, or if an error occurs, $(D_INLINECODE glIsProgramPipeline) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE pipeline) is a name returned by $(D_INLINECODE glGenProgramPipelines), but that has not yet been bound through a call to $(D_INLINECODE glBindProgramPipeline), then the name is not a program pipeline object and $(D_INLINECODE glIsProgramPipeline) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     pipeline = Specifies a value that may be the name of a program pipeline object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glDeleteProgramPipelines)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    GLboolean glIsProgramPipeline(GLuint pipeline) @system @nogc nothrow;

    /++
     + glIsQuery: man4/glIsQuery.xml
     + 
     + $(D_INLINECODE glIsQuery) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE id) is currently the name of a query object. If $(D_INLINECODE id) is zero, or is a non-zero value that is not currently the name of a query object, or if an error occurs, $(D_INLINECODE glIsQuery) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenQueries), but not yet associated with a query object by calling $(D_INLINECODE glBeginQuery), is not the name of a query object.
     + 
     + Params:
     +     id = Specifies a value that may be the name of a query object.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    GLboolean glIsQuery(GLuint id) @system @nogc nothrow;

    /++
     + glIsRenderbuffer: man4/glIsRenderbuffer.xml
     + 
     + $(D_INLINECODE glIsRenderbuffer) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE renderbuffer) is currently the name of a renderbuffer object. If $(D_INLINECODE renderbuffer) is zero, or if $(D_INLINECODE renderbuffer) is not the name of a renderbuffer object, or if an error occurs, $(D_INLINECODE glIsRenderbuffer) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE renderbuffer) is a name returned by $(D_INLINECODE glGenRenderbuffers), by that has not yet been bound through a call to $(D_INLINECODE glBindRenderbuffer) or $(D_INLINECODE glFramebufferRenderbuffer), then the name is not a renderbuffer object and $(D_INLINECODE glIsRenderbuffer) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     renderbuffer = Specifies a value that may be the name of a renderbuffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    GLboolean glIsRenderbuffer(GLuint renderbuffer) @system @nogc nothrow;

    /++
     + glIsSampler: man4/glIsSampler.xml
     + 
     + $(D_INLINECODE glIsSampler) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE id) is currently the name of a sampler object. If $(D_INLINECODE id) is zero, or is a non-zero value that is not currently the name of a sampler object, or if an error occurs, $(D_INLINECODE glIsSampler) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenSamplers), is the name of a sampler object.
     + 
     + $(D_INLINECODE glIsSampler) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     id = Specifies a value that may be the name of a sampler object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glBindSampler), $(D_INLINECODE glDeleteSamplers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    GLboolean glIsSampler(GLuint id) @system @nogc nothrow;

    /++
     + glIsShader: man4/glIsShader.xml
     + 
     + $(D_INLINECODE glIsShader) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE shader) is the name of a shader object previously created with $(D_INLINECODE glCreateShader) and not yet deleted with $(D_INLINECODE glDeleteShader). If $(D_INLINECODE shader) is zero or a non-zero value that is not the name of a shader object, or if an error occurs, $(D_INLINECODE glIsShader) returns $(D_INLINECODE GL_FALSE).
     + 
     + No error is generated if $(D_INLINECODE shader) is not a valid shader object name. A shader object marked for deletion with $(D_INLINECODE glDeleteShader) but still attached to a program object is still considered a shader object and $(D_INLINECODE glIsShader) will return $(D_INLINECODE GL_TRUE).
     + 
     + Params:
     +     shader = Specifies a potential shader object.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLboolean glIsShader(GLuint shader) @system @nogc nothrow;

    /++
     + glIsSync: man4/glIsSync.xml
     + 
     + $(D_INLINECODE glIsSync) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE sync) is currently the name of a sync object. If $(D_INLINECODE sync) is not the name of a sync object, or if an error occurs, $(D_INLINECODE glIsSync) returns $(D_INLINECODE GL_FALSE). Note that zero is not the name of a sync object.
     + 
     + $(D_INLINECODE glIsSync) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     sync = Specifies a value that may be the name of a sync object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync), $(D_INLINECODE glDeleteSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    GLboolean glIsSync(GLsync sync) @system @nogc nothrow;

    /++
     + glIsTexture: man4/glIsTexture.xml
     + 
     + $(D_INLINECODE glIsTexture) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE texture) is currently the name of a texture. If $(D_INLINECODE texture) is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs, $(D_INLINECODE glIsTexture) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenTextures), but not yet associated with a texture by calling $(D_INLINECODE glBindTexture), is not the name of a texture.
     + 
     + Params:
     +     texture = Specifies a value that may be the name of a texture.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    GLboolean glIsTexture(GLuint texture) @system @nogc nothrow;

    /++
     + glIsTransformFeedback: man4/glIsTransformFeedback.xml
     + 
     + $(D_INLINECODE glIsTransformFeedback) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE id) is currently the name of a transform feedback object. If $(D_INLINECODE id) is zero, or if $(D_INLINECODE id) is not the name of a transform feedback object, or if an error occurs, $(D_INLINECODE glIsTransformFeedback) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE id) is a name returned by $(D_INLINECODE glGenTransformFeedbacks), but that has not yet been bound through a call to $(D_INLINECODE glBindTransformFeedback), then the name is not a transform feedback object and $(D_INLINECODE glIsTransformFeedback) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     id = Specifies a value that may be the name of a transform feedback object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glDeleteTransformFeedbacks)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    GLboolean glIsTransformFeedback(GLuint id) @system @nogc nothrow;

    /++
     + glIsVertexArray: man4/glIsVertexArray.xml
     + 
     + $(D_INLINECODE glIsVertexArray) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE array) is currently the name of a vertex array object. If $(D_INLINECODE array) is zero, or if $(D_INLINECODE array) is not the name of a vertex array object, or if an error occurs, $(D_INLINECODE glIsVertexArray) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE array) is a name returned by $(D_INLINECODE glGenVertexArrays), by that has not yet been bound through a call to $(D_INLINECODE glBindVertexArray), then the name is not a vertex array object and $(D_INLINECODE glIsVertexArray) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     array = Specifies a value that may be the name of a vertex array object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenVertexArrays), $(D_INLINECODE glBindVertexArray), $(D_INLINECODE glDeleteVertexArrays)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    GLboolean glIsVertexArray(GLuint array) @system @nogc nothrow;

    /++
     + glLineWidth: man4/glLineWidth.xml
     + 
     + $(D_INLINECODE glLineWidth) specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LINE_SMOOTH). Line antialiasing is initially disabled. If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If &#x394; x &gt;= &#x394; y, pixels are filled in each column that is rasterized, where is the rounded value of $(D_INLINECODE width). Otherwise, pixels are filled in each row that is rasterized. If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step. Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the implementation.  Likewise, there is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported widths within the range, call $(D_INLINECODE glGet) with arguments $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE), $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_RANGE), and $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_GRANULARITY).
     + 
     + The line width specified by $(D_INLINECODE glLineWidth) is always returned when $(D_INLINECODE GL_LINE_WIDTH) is queried. Clamping and rounding for aliased and antialiased lines have no effect on the specified value. Nonantialiased line width may be clamped to an implementation-dependent maximum.  Call $(D_INLINECODE glGet) with $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE) to determine the maximum width. In OpenGL 1.2, the tokens $(D_INLINECODE GL_LINE_WIDTH_RANGE) and $(D_INLINECODE GL_LINE_WIDTH_GRANULARITY) were replaced by $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE), $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_RANGE), and $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_GRANULARITY).  The old names are retained for backward compatibility, but should not be used in new code.
     + 
     + Params:
     +     width = Specifies the width of rasterized lines. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLineWidth(GLfloat width) @system @nogc nothrow;

    /++
     + glLinkProgram: man4/glLinkProgram.xml
     + 
     + $(D_INLINECODE glLinkProgram) links the program object specified by $(D_INLINECODE program). If any shader objects of type $(D_INLINECODE GL_VERTEX_SHADER) are attached to $(D_INLINECODE program), they will be used to create an executable that will run on the programmable vertex processor. If any shader objects of type $(D_INLINECODE GL_GEOMETRY_SHADER) are attached to $(D_INLINECODE program), they will be used to create an executable that will run on the programmable geometry processor. If any shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER) are attached to $(D_INLINECODE program), they will be used to create an executable that will run on the programmable fragment processor. The status of the link operation will be stored as part of the program object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the program object was linked without errors and is ready for use, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_LINK_STATUS). As a result of a successful link operation, all active user-defined uniform variables belonging to $(D_INLINECODE program) will be initialized to 0, and each of the program object's active uniform variables will be assigned a location that can be queried by calling $(D_INLINECODE glGetUniformLocation). Also, any active user-defined attribute variables that have not been bound to a generic vertex attribute index will be bound to one at this time. Linking of a program object can fail for a number of reasons as specified in the. The following lists some of the conditions that will cause a link error. $(OL $(LI The number of active attribute variables supported by the implementation has been exceeded.) $(LI The storage limit for uniform variables has been exceeded.) $(LI The number of active uniform variables supported by the implementation has been exceeded.) $(LI The $(D_INLINECODE main) function is missing for the vertex, geometry or fragment shader.) $(LI A varying variable actually used in the fragment shader is not declared in the same way (or is not declared at all) in the vertex shader, or geometry shader shader if present.) $(LI A reference to a function or variable name is unresolved.) $(LI A shared global is declared with two different types or two different initial values.) $(LI One or more of the attached shader objects has not been successfully compiled.) $(LI Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed maximum of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS).) $(LI Not enough contiguous vertex attribute slots could be found to bind attribute matrices.) $(LI The program object contains objects to form a fragment shader but does not contain objects to form a vertex shader.) $(LI The program object contains objects to form a geometry shader but does not contain objects to form a vertex shader.) $(LI The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is not specified in any compiled geometry shader object.) $(LI The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is specified differently in multiple geometry shader objects.) $(LI The number of active outputs in the fragment shader is greater than the value of $(D_INLINECODE GL_MAX_DRAW_BUFFERS).) $(LI The program has an active output assigned to a location greater than or equal to the value of $(D_INLINECODE GL_MAX_DUAL_SOURCE_DRAW_BUFFERS) and has an active output assigned an index greater than or equal to one.) $(LI More than one varying out variable is bound to the same number and index.) $(LI The explicit binding assigments do not leave enough space for the linker to automatically assign a location for a varying out array, which requires multiple contiguous locations.) $(LI The $(D_INLINECODE count) specified by $(D_INLINECODE glTransformFeedbackVaryings) is non-zero, but the program object has no vertex or geometry shader.) $(LI Any variable name specified to $(D_INLINECODE glTransformFeedbackVaryings) in the $(D_INLINECODE varyings) array is not declared as an output in the vertex shader (or the geometry shader, if active).) $(LI Any two entries in the $(D_INLINECODE varyings) array given $(D_INLINECODE glTransformFeedbackVaryings) specify the same varying variable.) $(LI The total number of components to capture in any transform feedback varying variable is  greater  than  the  constant $(D_INLINECODE GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS) and the buffer mode is $(D_INLINECODE GL_SEPARATE_ATTRIBS).)) When a program object has been successfully linked, the program object can be made part of current state by calling $(D_INLINECODE glUseProgram). Whether or not the link operation was successful, the program object's information log will be overwritten. The information log can be retrieved by calling $(D_INLINECODE glGetProgramInfoLog). $(D_INLINECODE glLinkProgram) will also install the generated executables as part of the current rendering state if the link operation was successful and the specified program object is already currently in use as a result of a previous call to $(D_INLINECODE glUseProgram). If the program object currently in use is relinked unsuccessfully, its link status will be set to $(D_INLINECODE GL_FALSE), but the executables and associated state will remain part of the current state until a subsequent call to $(D_INLINECODE glUseProgram) removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked. If $(D_INLINECODE program) contains shader objects of type $(D_INLINECODE GL_VERTEX_SHADER), and optionally of type $(D_INLINECODE GL_GEOMETRY_SHADER), but does not contain shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER), the vertex shader executable will be installed on the programmable vertex processor, the geometry shader executable, if present, will be installed on the programmable geometry processor, but no executable will be installed on the fragment processor. The results of rasterizing primitives with such a program will be undefined. The program object's information log is updated and the program is generated at the time of the link operation. After the link operation, applications are free to modify attached shader objects, compile attached shader objects, detach shader objects, delete shader objects, and attach additional shader objects. None of these operations affects the information log or the program that is part of the program object.
     + 
     + If the link operation is unsuccessful, any information about a previous link operation on $(D_INLINECODE program) is lost (i.e., a failed link does not restore the old state of $(D_INLINECODE program) ). Certain information can still be retrieved from $(D_INLINECODE program) even after an unsuccessful link operation. See for instance $(D_INLINECODE glGetActiveAttrib) and $(D_INLINECODE glGetActiveUniform).
     + 
     + Params:
     +     program = Specifies the handle of the program object to be linked.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glLinkProgram(GLuint program) @system @nogc nothrow;

    /++
     + glLogicOp: man4/glLogicOp.xml
     + 
     + $(D_INLINECODE glLogicOp) specifies a logical operation that, when enabled, is applied between the incoming RGBA color and the RGBA color at the corresponding location in the frame buffer. To enable or disable the logical operation, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) using the symbolic constant $(D_INLINECODE GL_COLOR_LOGIC_OP). The initial value is disabled. $(B Opcode) $(B Resulting Operation) $(D_INLINECODE GL_CLEAR) 0 $(D_INLINECODE GL_SET) 1 $(D_INLINECODE GL_COPY) s $(D_INLINECODE GL_COPY_INVERTED) ~s $(D_INLINECODE GL_NOOP) d $(D_INLINECODE GL_INVERT) ~d $(D_INLINECODE GL_AND) s &amp; d $(D_INLINECODE GL_NAND) ~(s &amp; d) $(D_INLINECODE GL_OR) s | d $(D_INLINECODE GL_NOR) ~(s | d) $(D_INLINECODE GL_XOR) s ^ d $(D_INLINECODE GL_EQUIV) ~(s ^ d) $(D_INLINECODE GL_AND_REVERSE) s &amp; ~d $(D_INLINECODE GL_AND_INVERTED) ~s &amp; d $(D_INLINECODE GL_OR_REVERSE) s | ~d $(D_INLINECODE GL_OR_INVERTED) ~s | d $(D_INLINECODE opcode) is a symbolic constant chosen from the list above. In the explanation of the logical operations, represents the incoming color and represents the color in the frame buffer. Standard C-language operators are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination colors.
     + 
     + When more than one RGBA color buffer is enabled for drawing, logical operations are performed separately for each enabled buffer, using for the destination value the contents of that buffer (see $(D_INLINECODE glDrawBuffer) ). Logic operations have no effect on floating point draw buffers. However, if $(D_INLINECODE GL_COLOR_LOGIC_OP) is enabled, blending is still disabled in this case.
     + 
     + Params:
     +     opcode = Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: $(D_INLINECODE GL_CLEAR), $(D_INLINECODE GL_SET), $(D_INLINECODE GL_COPY), $(D_INLINECODE GL_COPY_INVERTED), $(D_INLINECODE GL_NOOP), $(D_INLINECODE GL_INVERT), $(D_INLINECODE GL_AND), $(D_INLINECODE GL_NAND), $(D_INLINECODE GL_OR), $(D_INLINECODE GL_NOR), $(D_INLINECODE GL_XOR), $(D_INLINECODE GL_EQUIV), $(D_INLINECODE GL_AND_REVERSE), $(D_INLINECODE GL_AND_INVERTED), $(D_INLINECODE GL_OR_REVERSE), and $(D_INLINECODE GL_OR_INVERTED). The initial value is $(D_INLINECODE GL_COPY).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glStencilOp)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLogicOp(GLenum opcode) @system @nogc nothrow;

    /++
     + glMapBuffer: man4/glMapBuffer.xml
     + 
     + $(D_INLINECODE glMapBuffer) and $(D_INLINECODE glMapNamedBuffer) map the entire data store of a specified buffer object into the client's address space. The data can then be directly read and/or written relative to the returned pointer, depending on the specified $(D_INLINECODE access) policy. A pointer to the beginning of the mapped range is returned once all pending operations on that buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the value of $(D_INLINECODE access) : $(OL $(LI $(D_INLINECODE GL_READ_ONLY) indicates that the returned pointer may be used to read buffer object data.) $(LI $(D_INLINECODE GL_WRITE_ONLY) indicates that the returned pointer may be used to modify buffer object data.) $(LI $(D_INLINECODE GL_READ_WRITE) indicates that the returned pointer may be used to read and to modify buffer object data.)) If an error is generated, a $(D_INLINECODE null
     + ) pointer is returned. If no error occurs, the returned pointer will reflect an allocation aligned to the value of $(D_INLINECODE GL_MIN_MAP_BUFFER_ALIGNMENT) basic machine units. The returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons. No GL error is generated if the returned pointer is accessed in a way inconsistent with $(D_INLINECODE access) (e.g. used to read from a mapping made with $(D_INLINECODE access) $(D_INLINECODE GL_WRITE_ONLY) or write to a mapping made with $(D_INLINECODE access) $(D_INLINECODE GL_READ_ONLY) ), but the result is undefined and system errors (possibly including program termination) may occur. Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of $(D_INLINECODE GL_BUFFER_USAGE) for the buffer object and of $(D_INLINECODE access). Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.
     + 
     + Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is accepted only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glMapBuffer), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glMapNamedBuffer).
     +     access = Specifies the access policy for $(D_INLINECODE glMapBuffer) and $(D_INLINECODE glMapNamedBuffer), indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be $(D_INLINECODE GL_READ_ONLY), $(D_INLINECODE GL_WRITE_ONLY), or $(D_INLINECODE GL_READ_WRITE).
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBufferData), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glMapBufferRange), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void* glMapBuffer(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void* glMapNamedBuffer(GLuint buffer, GLenum access) @system @nogc nothrow;

    /++
     + glMapBufferRange: man4/glMapBufferRange.xml
     + 
     + $(D_INLINECODE glMapBufferRange) and $(D_INLINECODE glMapNamedBufferRange) map all or part of the data store of a specified buffer object into the client's address space. $(D_INLINECODE offset) and $(D_INLINECODE length) indicate the range of data in the buffer object that is to be mapped, in terms of basic machine units. $(D_INLINECODE access) is a bitfield containing flags which describe the requested mapping. These flags are described below. A pointer to the beginning of the mapped range is returned once all pending operations on the buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the following flag bits set in $(D_INLINECODE access) : $(OL $(LI $(D_INLINECODE GL_MAP_READ_BIT) indicates that the returned pointer may be used to read buffer object data. No GL error is generated if the pointer is used to query a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.) $(LI $(D_INLINECODE GL_MAP_WRITE_BIT) indicates that the returned pointer may be used to modify buffer object data. No GL error is generated if the pointer is used to modify a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.) $(LI $(D_INLINECODE GL_MAP_PERSISTENT_BIT) indicates that the mapping is to be made in a persistent fassion and that the client intends to hold and use the returned pointer during subsequent GL operation. It is not an error to call drawing commands (render) while buffers are mapped using this flag. It is an error to specify this flag if the buffer's data store was not allocated through a call to the $(D_INLINECODE glBufferStorage) command in which the $(D_INLINECODE GL_MAP_PERSISTENT_BIT) was also set.) $(LI $(D_INLINECODE GL_MAP_COHERENT_BIT) indicates that a persistent mapping is also to be coherent. Coherent maps guarantee that the effect of writes to a buffer's data store by either the client or server will eventually become visible to the other without further intervention from the application. In the absence of this bit, persistent mappings are not coherent and modified ranges of the buffer store must be explicitly communicated to the GL, either by unmapping the buffer, or through a call to $(D_INLINECODE glFlushMappedBufferRange) or $(D_INLINECODE glMemoryBarrier).)) The following flag bits in $(D_INLINECODE access) may be used to modify the mapping: $(OL $(LI $(D_INLINECODE GL_MAP_INVALIDATE_RANGE_BIT) indicates that the previous contents of the specified range may be discarded. Data within this range are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with $(D_INLINECODE GL_MAP_READ_BIT).) $(LI $(D_INLINECODE GL_MAP_INVALIDATE_BUFFER_BIT) indicates that the previous contents of the entire buffer may be discarded. Data within the entire buffer are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with $(D_INLINECODE GL_MAP_READ_BIT).) $(LI $(D_INLINECODE GL_MAP_FLUSH_EXPLICIT_BIT) indicates that one or more discrete subranges of the mapping may be modified. When this flag is set, modifications to each subrange must be explicitly flushed by calling $(D_INLINECODE glFlushMappedBufferRange). No GL error is set if a subrange of the mapping is modified and not flushed, but data within the corresponding subrange of the buffer are undefined. This flag may only be used in conjunction with $(D_INLINECODE GL_MAP_WRITE_BIT). When this option is selected, flushing is strictly limited to regions that are explicitly indicated with calls to $(D_INLINECODE glFlushMappedBufferRange) prior to unmap; if this option is not selected $(D_INLINECODE glUnmapBuffer) will automatically flush the entire mapped range when called.) $(LI $(D_INLINECODE GL_MAP_UNSYNCHRONIZED_BIT) indicates that the GL should not attempt to synchronize pending operations on the buffer prior to returning from $(D_INLINECODE glMapBufferRange) or $(D_INLINECODE glMapNamedBufferRange). No GL error is generated if pending operations which source or modify the buffer overlap the mapped region, but the result of such previous and any subsequent operations is undefined.)) If an error occurs, a $(D_INLINECODE null
     + ) pointer is returned. If no error occurs, the returned pointer will reflect an allocation aligned to the value of $(D_INLINECODE GL_MIN_MAP_BUFFER_ALIGNMENT) basic machine units. Subtracting $(D_INLINECODE offset) from this returned pointer will always produce a multiple of the value of $(D_INLINECODE GL_MIN_MAP_BUFFER_ALIGNMENT). The returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons. Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of $(D_INLINECODE GL_BUFFER_USAGE) for the buffer object and of $(D_INLINECODE access). Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.
     + 
     + Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is accepted only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are accepted only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater. The $(D_INLINECODE GL_MAP_PERSISTENT_BIT) and $(D_INLINECODE GL_MAP_COHERENT_BIT) flags are available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glMapBufferRange), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glMapNamedBufferRange).
     +     offset = Specifies the starting offset within the buffer of the range to be mapped.
     +     length = Specifies the length of the range to be mapped.
     +     access = Specifies a combination of access flags indicating the desired access to the mapped range.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer), $(D_INLINECODE glFlushMappedBufferRange), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferStorage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_map_buffer_range")
    void* glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void* glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizei length, GLbitfield access) @system @nogc nothrow;

    /++
     + glMemoryBarrier: man4/glMemoryBarrier.xml
     + 
     + $(D_INLINECODE glMemoryBarrier) defines a barrier ordering the memory transactions issued prior to the command relative to those issued after the barrier. For the purposes of this ordering, memory transactions performed by shaders are considered to be issued by the rendering command that triggered the execution of the shader. $(D_INLINECODE barriers) is a bitfield indicating the set of operations that are synchronized with shader stores; the bits used in $(D_INLINECODE barriers) are as follows: If $(D_INLINECODE barriers) is $(D_INLINECODE GL_ALL_BARRIER_BITS), shader memory accesses will be synchronized relative to all the operations described above. Implementations may cache buffer object and texture image memory that could be written by shaders in multiple caches; for example, there may be separate caches for texture, vertex fetching, and one or more caches for shader memory accesses.  Implementations are not required to keep these caches coherent with shader memory writes.  Stores issued by one invocation may not be immediately observable by other pipeline stages or other shader invocations because the value stored may remain in a cache local to the processor executing the store, or because data overwritten by the store is still in a cache elsewhere in the system. When $(D_INLINECODE glMemoryBarrier) is called, the GL flushes and/or invalidates any caches relevant to the operations specified by the $(D_INLINECODE barriers) parameter to ensure consistent ordering of operations across the barrier. To allow for independent shader invocations to communicate by reads and writes to a common memory address, image variables in the OpenGL Shading Language may be declared as "coherent".  Buffer object or texture image memory accessed through such variables may be cached only if caches are automatically updated due to stores issued by any other shader invocation. If the same address is accessed using both coherent and non-coherent variables, the accesses using variables declared as coherent will observe the results stored using coherent variables in other invocations.  Using variables declared as "coherent" guarantees only that the results of stores will be immediately visible to shader invocations using similarly-declared variables; calling $(D_INLINECODE glMemoryBarrier) is required to ensure that the stores are visible to other operations. The following guidelines may be helpful in choosing when to use coherent memory accesses and when to use barriers. $(OL $(LI Data that are read-only or constant may be accessed without using coherent variables or calling $(D_INLINECODE MemoryBarrier) (). Updates to the read-only data via API calls such as $(D_INLINECODE glBufferSubData) will invalidate shader caches implicitly as required.) $(LI Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another invocation) should use coherent variables to read and write the shared data.) $(LI Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution (&quot;dependent invocations&quot;) should use coherent variables in the producing shader invocation and call $(D_INLINECODE memoryBarrier) () after the last write. The consuming shader invocation should also use coherent variables.) $(LI Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables or memoryBarrier(). Calling $(D_INLINECODE glMemoryBarrier) with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in $(D_INLINECODE barriers) between passes is necessary.) $(LI Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in a later pass need not use coherent variables or $(D_INLINECODE memoryBarrier) (). Calling $(D_INLINECODE glMemoryBarrier) with the appropriate bits set in $(D_INLINECODE barriers) between passes is necessary.))
     + 
     + $(D_INLINECODE GL_SHADER_STORAGE_BARRIER_BIT) is available only if the GL version is 4.3 or higher. $(D_INLINECODE GL_QUERY_BUFFER_BARRIER_BIT) is available only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     barriers = Specifies the barriers to insert. For $(D_INLINECODE glMemoryBarrier), must be a bitwise combination of any of $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT), $(D_INLINECODE GL_ELEMENT_ARRAY_BARRIER_BIT), $(D_INLINECODE GL_UNIFORM_BARRIER_BIT), $(D_INLINECODE GL_TEXTURE_FETCH_BARRIER_BIT), $(D_INLINECODE GL_SHADER_IMAGE_ACCESS_BARRIER_BIT), $(D_INLINECODE GL_COMMAND_BARRIER_BIT), $(D_INLINECODE GL_PIXEL_BUFFER_BARRIER_BIT), $(D_INLINECODE GL_TEXTURE_UPDATE_BARRIER_BIT), $(D_INLINECODE GL_BUFFER_UPDATE_BARRIER_BIT), $(D_INLINECODE GL_FRAMEBUFFER_BARRIER_BIT), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BARRIER_BIT), $(D_INLINECODE GL_ATOMIC_COUNTER_BARRIER_BIT), or $(D_INLINECODE GL_SHADER_STORAGE_BARRIER_BIT). For $(D_INLINECODE glMemoryBarrier), must be a bitwise combination of any of $(D_INLINECODE GL_ATOMIC_COUNTER_BARRIER_BIT), or $(D_INLINECODE GL_FRAMEBUFFER_BARRIER_BIT), $(D_INLINECODE GL_SHADER_IMAGE_ACCESS_BARRIER_BIT), $(D_INLINECODE GL_SHADER_STORAGE_BARRIER_BIT). $(D_INLINECODE GL_TEXTURE_FETCH_BARRIER_BIT), or $(D_INLINECODE GL_UNIFORM_BARRIER_BIT). If the special value $(D_INLINECODE GL_ALL_BARRIER_BITS) is specified, all supported barriers for the corresponding command will be inserted.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindImageTexture), $(D_INLINECODE glBufferData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glMapBufferRange), $(D_INLINECODE glFlushMappedBufferRange), $(D_INLINECODE memoryBarrier)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_image_load_store")
    void glMemoryBarrier(GLbitfield barriers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_ES3_1_compatibility")
    void glMemoryBarrierByRegion(GLbitfield barriers) @system @nogc nothrow;

    /++
     + glMinSampleShading: man4/glMinSampleShading.xml
     + 
     + $(D_INLINECODE glMinSampleShading) specifies the rate at which samples are shaded within a covered pixel. Sample-rate shading is enabled by calling $(D_INLINECODE glEnable) with the parameter $(D_INLINECODE GL_SAMPLE_SHADING). If $(D_INLINECODE GL_MULTISAMPLE) or $(D_INLINECODE GL_SAMPLE_SHADING) is disabled, sample shading has no effect. Otherwise, an implementation must provide at least as many unique color values for each covered fragment as specified by $(D_INLINECODE value) times $(D_INLINECODE samples) where $(D_INLINECODE samples) is the value of $(D_INLINECODE GL_SAMPLES) for the current framebuffer. At least 1 sample for each covered fragment is generated. A $(D_INLINECODE value) of 1.0 indicates that each sample in the framebuffer should be indpendently shaded. A $(D_INLINECODE value) of 0.0 effectively allows the GL to ignore sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade only a subset of the total samples within each covered fragment. Which samples are shaded and the algorithm used to select that subset of the fragment's samples is implementation dependent.
     + 
     + The type of the $(D_INLINECODE value) parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     value = Specifies the rate at which samples are shaded within each covered pixel.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glMinSampleShading(GLfloat value) @system @nogc nothrow;

    /++
     + glMultiDrawArrays: man4/glMultiDrawArrays.xml
     + 
     + $(D_INLINECODE glMultiDrawArrays) specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glMultiDrawArrays). $(D_INLINECODE glMultiDrawArrays) behaves identically to $(D_INLINECODE glDrawArrays) except that $(D_INLINECODE drawcount) separate ranges of elements are specified instead. When $(D_INLINECODE glMultiDrawArrays) is called, it uses $(D_INLINECODE count) sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element $(D_INLINECODE first). $(D_INLINECODE mode) specifies what kind of primitives are constructed, and how the array elements construct those primitives. Vertex attributes that are modified by $(D_INLINECODE glMultiDrawArrays) have an unspecified value after $(D_INLINECODE glMultiDrawArrays) returns. Attributes that aren't modified remain well defined.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     first     = Points to an array of starting indices in the enabled arrays.
     +     count     = Points to an array of the number of indices to be rendered.
     +     drawcount = Specifies the size of the first and count
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glMultiDrawArrays(GLenum mode, const GLint* first, const GLsizei* count, GLsizei drawcount) @system @nogc nothrow;

    /++
     + glMultiDrawArraysIndirect: man4/glMultiDrawArraysIndirect.xml
     + 
     + $(D_INLINECODE glMultiDrawArraysIndirect) specifies multiple geometric primitives with very few subroutine calls. $(D_INLINECODE glMultiDrawArraysIndirect) behaves similarly to a multitude of calls to $(D_INLINECODE glDrawArraysInstancedBaseInstance), execept that the parameters to each call to $(D_INLINECODE glDrawArraysInstancedBaseInstance) are stored in an array in memory at the address given by $(D_INLINECODE indirect), separated by the stride, in basic machine units, specified by $(D_INLINECODE stride). If $(D_INLINECODE stride) is zero, then the array is assumed to be tightly packed in memory. The parameters addressed by $(D_INLINECODE indirect) are packed into an array of structures, each element of which takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  count;
     +     uint  instanceCount;
     +     uint  first;
     +     uint  baseInstance;
     + } DrawArraysIndirectCommand;
     + ---
     +  A single call to $(D_INLINECODE glMultiDrawArraysIndirect) is equivalent, assuming no errors are generated to:
     + 
     + ---
     + GLsizei n;
     + for (n = 0; n &lt; drawcount; n++) {
     +     const DrawArraysIndirectCommand *cmd;
     +     if (stride != 0) {
     +         cmd = (const DrawArraysIndirectCommand  *)((uintptr)indirect + n * stride);
     +     } else  {
     +         cmd = (const DrawArraysIndirectCommand  *)indirect + n;
     +     }
     + 
     +     glDrawArraysInstancedBaseInstance(mode, cmd-&gt;first, cmd-&gt;count, cmd-&gt;instanceCount, cmd-&gt;baseInstance);
     + }
     + ---
     +  If a buffer is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) binding at the time of a call to $(D_INLINECODE glMultiDrawArraysIndirect), $(D_INLINECODE indirect) is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory. In contrast to $(D_INLINECODE glDrawArraysInstancedBaseInstance), the $(D_INLINECODE first) member of the parameter structure is unsigned, and out-of-range indices do not generate an error. Vertex attributes that are modified by $(D_INLINECODE glMultiDrawArraysIndirect) have an unspecified value after $(D_INLINECODE glMultiDrawArraysIndirect) returns. Attributes that aren't modified remain well defined.
     + 
     + The $(D_INLINECODE baseInstance) member of the $(D_INLINECODE DrawArraysIndirectCommand) structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero. $(D_INLINECODE glMultiDrawArraysIndirect) is available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     indirect  = Specifies the address of an array of structures containing the draw parameters.
     +     drawcount = Specifies the the number of elements in the array of draw parameter structures.
     +     stride    = Specifies the distance in basic machine units between elements of the draw parameter array.
     + 
     + Copyright:
     +     Copyright&copy; 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArraysIndirect), $(D_INLINECODE glMultiDrawElementsIndirect)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_multi_draw_indirect")
    void glMultiDrawArraysIndirect(GLenum mode, const void* indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;

    /++
     + glMultiDrawElements: man4/glMultiDrawElements.xml
     + 
     + $(D_INLINECODE glMultiDrawElements) specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glMultiDrawElements). $(D_INLINECODE glMultiDrawElements) is identical in operation to $(D_INLINECODE glDrawElements) except that $(D_INLINECODE drawcount) separate lists of elements are specified. Vertex attributes that are modified by $(D_INLINECODE glMultiDrawElements) have an unspecified value after $(D_INLINECODE glMultiDrawElements) returns. Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count     = Points to an array of the elements counts.
     +     type      = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices   = Specifies a pointer to the location where the indices are stored.
     +     drawcount = Specifies the size of the $(D_INLINECODE count) and $(D_INLINECODE indices) arrays.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawRangeElements)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glMultiDrawElements(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei drawcount) @system @nogc nothrow;

    /++
     + glMultiDrawElementsBaseVertex: man4/glMultiDrawElementsBaseVertex.xml
     + 
     + $(D_INLINECODE glMultiDrawElementsBaseVertex) behaves identically to $(D_INLINECODE glDrawElementsBaseVertex), except that $(D_INLINECODE drawcount) separate lists of elements are specifried instead. It has the same effect as:
     + 
     + ---
     + for (int i = 0; i &lt;  $(D_INLINECODE drawcount); i++)
     +     if ( $(D_INLINECODE count)[i] &gt; 0)
     +         glDrawElementsBaseVertex( $(D_INLINECODE mode),
     +                                   $(D_INLINECODE count)[i],
     +                                   $(D_INLINECODE type),
     +                                   $(D_INLINECODE indices[i]),
     +                                   $(D_INLINECODE basevertex[i]));
     + ---
     + 
     + 
     + $(D_INLINECODE glMultiDrawElementsBaseVertex) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode       = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count      = Points to an array of the elements counts.
     +     type       = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices    = Specifies a pointer to the location where the indices are stored.
     +     drawcount  = Specifies the size of the $(D_INLINECODE count), $(D_INLINECODE indices) and $(D_INLINECODE basevertex) arrays.
     +     basevertex = Specifies a pointer to the location where the base vertices are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei drawcount, const GLint* basevertex) @system @nogc nothrow;

    /++
     + glMultiDrawElementsIndirect: man4/glMultiDrawElementsIndirect.xml
     + 
     + $(D_INLINECODE glMultiDrawElementsIndirect) specifies multiple indexed geometric primitives with very few subroutine calls. $(D_INLINECODE glMultiDrawElementsIndirect) behaves similarly to a multitude of calls to $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance), execpt that the parameters to $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance) are stored in an array in memory at the address given by $(D_INLINECODE indirect), separated by the stride, in basic machine units, specified by $(D_INLINECODE stride). If $(D_INLINECODE stride) is zero, then the array is assumed to be tightly packed in memory. The parameters addressed by $(D_INLINECODE indirect) are packed into a structure that takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  count;
     +     uint  instanceCount;
     +     uint  firstIndex;
     +     uint  baseVertex;
     +     uint  baseInstance;
     + } DrawElementsIndirectCommand;
     + ---
     +  A single call to $(D_INLINECODE glMultiDrawElementsIndirect) is equivalent, assuming no errors are generated to:
     + 
     + ---
     + GLsizei n;
     + for (n = 0; n &lt; drawcount; n++) {
     +     const DrawElementsIndirectCommand *cmd;
     +     if (stride != 0) {
     +         cmd = (const DrawElementsIndirectCommand  *)((uintptr)indirect + n * stride);
     +     } else {
     +         cmd = (const DrawElementsIndirectCommand  *)indirect + n;
     +     }
     + 
     +     glDrawElementsInstancedBaseVertexBaseInstance(mode,
     +                                                   cmd-&gt;count,
     +                                                   type,
     +                                                   cmd-&gt;firstIndex + size-of-type,
     +                                                   cmd-&gt;instanceCount,
     +                                                   cmd-&gt;baseVertex,
     +                                                   cmd-&gt;baseInstance);
     + }
     + ---
     +  If a buffer is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) binding at the time of a call to $(D_INLINECODE glDrawElementsIndirect), $(D_INLINECODE indirect) is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory. Note that indices stored in client memory are not supported. If no buffer is bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding, an error will be generated. The results of the operation are undefined if the $(D_INLINECODE reservedMustBeZero) member of the parameter structure is non-zero. However, no error is generated in this case. Vertex attributes that are modified by $(D_INLINECODE glDrawElementsIndirect) have an unspecified value after $(D_INLINECODE glDrawElementsIndirect) returns. Attributes that aren't modified remain well defined.
     + 
     + The $(D_INLINECODE baseInstance) member of the $(D_INLINECODE DrawElementsIndirectCommand) structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     type      = Specifies the type of data in the buffer bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding.
     +     indirect  = Specifies the address of a structure containing an array of draw parameters.
     +     drawcount = Specifies the number of elements in the array addressed by $(D_INLINECODE indirect).
     +     stride    = Specifies the distance in basic machine units between elements of the draw parameter array.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawArraysIndirect), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawElementsIndirect), $(D_INLINECODE glMultiDrawArraysIndirect)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_multi_draw_indirect")
    void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;

    /++
     + glNamedFramebufferReadBuffer: man4/glReadBuffer.xml
     + 
     + $(D_INLINECODE glReadBuffer) specifies a color buffer as the source for subsequent $(D_INLINECODE glReadPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), and $(D_INLINECODE glCopyTexSubImage3D) commands. $(D_INLINECODE mode) accepts one of twelve or more predefined values. In a fully configured system, $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_LEFT), and $(D_INLINECODE GL_FRONT_LEFT) all name the front left buffer, $(D_INLINECODE GL_FRONT_RIGHT) and $(D_INLINECODE GL_RIGHT) name the front right buffer, and $(D_INLINECODE GL_BACK_LEFT) and $(D_INLINECODE GL_BACK) name the back left buffer. Further more, the constants $(D_INLINECODE GL_COLOR_ATTACHMENT) may be used to indicate the<sup> th</sup> color attachment where ranges from zero to the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify a nonexistent buffer to $(D_INLINECODE glReadBuffer). $(D_INLINECODE mode) is initially $(D_INLINECODE GL_FRONT) in single-buffered configurations and $(D_INLINECODE GL_BACK) in double-buffered configurations. For $(D_INLINECODE glReadBuffer), the target framebuffer object is that bound to $(D_INLINECODE GL_READ_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferReadBuffer), $(D_INLINECODE framebuffer) must either be zero or the name of the target framebuffer object. If $(D_INLINECODE framebuffer) is zero, then the default read framebuffer is affected.
     + 
     + Params:
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferReadBuffer) function.
     +     mode        = Specifies a color buffer. Accepted values are $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), $(D_INLINECODE GL_LEFT), $(D_INLINECODE GL_RIGHT), and the constants $(D_INLINECODE GL_COLOR_ATTACHMENT).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glReadBuffer(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode) @system @nogc nothrow;

    /++
     + glNamedRenderbufferStorage: man4/glRenderbufferStorage.xml
     + 
     + $(D_INLINECODE glRenderbufferStorage) is equivalent to calling $(D_INLINECODE glRenderbufferStorageMultisample) with the $(D_INLINECODE samples) set to zero, and $(D_INLINECODE glNamedRenderbufferStorage) is equivalent to calling $(D_INLINECODE glNamedRenderbufferStorageMultisample) with the samples set to zero. For $(D_INLINECODE glRenderbufferStorage), the target of the operation, specified by $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER). For $(D_INLINECODE glNamedRenderbufferStorage), $(D_INLINECODE renderbuffer) must be a name of an existing renderbuffer object. $(D_INLINECODE internalformat) specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. $(D_INLINECODE width) and $(D_INLINECODE height) are the dimensions, in pixels, of the renderbuffer. Both $(D_INLINECODE width) and $(D_INLINECODE height) must be less than or equal to the value of $(D_INLINECODE GL_MAX_RENDERBUFFER_SIZE). Upon success, $(D_INLINECODE glRenderbufferStorage) and $(D_INLINECODE glNamedRenderbufferStorage) delete any existing data store for the renderbuffer image and the contents of the data store after calling $(D_INLINECODE glRenderbufferStorage) are undefined.
     + 
     + Params:
     +     target         = Specifies a binding target of the allocation for $(D_INLINECODE glRenderbufferStorage) function. Must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer   = Specifies the name of the renderbuffer object for $(D_INLINECODE glNamedRenderbufferStorage) function.
     +     internalformat = Specifies the internal format to use for the renderbuffer object's image.
     +     width          = Specifies the width of the renderbuffer, in pixels.
     +     height         = Specifies the height of the renderbuffer, in pixels.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glNamedRenderbufferStorageMultisample), $(D_INLINECODE glRenderbufferStorageMultisample), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glNamedRenderbufferStorageMultisample: man4/glRenderbufferStorageMultisample.xml
     + 
     + $(D_INLINECODE glRenderbufferStorageMultisample) and $(D_INLINECODE glNamedRenderbufferStorageMultisample) establish the data storage, format, dimensions and number of samples of a renderbuffer object's image. For $(D_INLINECODE glRenderbufferStorageMultisample), the target of the operation, specified by $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER). For $(D_INLINECODE glNamedRenderbufferStorageMultisample), $(D_INLINECODE renderbuffer) must be an ID of an existing renderbuffer object. $(D_INLINECODE internalformat) specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. $(D_INLINECODE width) and $(D_INLINECODE height) are the dimensions, in pixels, of the renderbuffer. Both $(D_INLINECODE width) and $(D_INLINECODE height) must be less than or equal to the value of $(D_INLINECODE GL_MAX_RENDERBUFFER_SIZE). $(D_INLINECODE samples) specifies the number of samples to be used for the renderbuffer object's image, and must be less than or equal to the value of $(D_INLINECODE GL_MAX_SAMPLES). If $(D_INLINECODE internalformat) is a signed or unsigned integer format then $(D_INLINECODE samples) must be less than or equal to the value of $(D_INLINECODE GL_MAX_INTEGER_SAMPLES). Upon success, $(D_INLINECODE glRenderbufferStorageMultisample) and $(D_INLINECODE glNamedRenderbufferStorageMultisample) delete any existing data store for the renderbuffer image and the contents of the data store after calling either of the functions are undefined.
     + 
     + Params:
     +     target         = Specifies a binding target of the allocation for $(D_INLINECODE glRenderbufferStorageMultisample) function. Must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer   = Specifies the name of the renderbuffer object for $(D_INLINECODE glNamedRenderbufferStorageMultisample) function.
     +     samples        = Specifies the number of samples to be used for the renderbuffer object's storage.
     +     internalformat = Specifies the internal format to use for the renderbuffer object's image.
     +     width          = Specifies the width of the renderbuffer, in pixels.
     +     height         = Specifies the height of the renderbuffer, in pixels.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glNamedRenderbufferStorage), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glObjectLabel: man4/glObjectLabel.xml
     + 
     + $(D_INLINECODE glObjectLabel) labels the object identified by $(D_INLINECODE name) within the namespace given by $(D_INLINECODE identifier). $(D_INLINECODE identifier) must be one of $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER), $(D_INLINECODE GL_PROGRAM), $(D_INLINECODE GL_VERTEX_ARRAY), $(D_INLINECODE GL_QUERY), $(D_INLINECODE GL_PROGRAM_PIPELINE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK), $(D_INLINECODE GL_SAMPLER), $(D_INLINECODE GL_TEXTURE), $(D_INLINECODE GL_RENDERBUFFER), $(D_INLINECODE GL_FRAMEBUFFER), to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively. $(D_INLINECODE label) is the address of a string that will be used to label an object. $(D_INLINECODE length) contains the number of characters in $(D_INLINECODE label). If $(D_INLINECODE length) is negative, it is implied that $(D_INLINECODE label) contains a null-terminated string. If $(D_INLINECODE label) is null, any debug label is effectively removed from the object.
     + 
     + Params:
     +     identifier = The namespace from which the name of the object is allocated.
     +     name       = The name of the object to label.
     +     length     = The length of the label to be used for the object.
     +     label      = The address of a string containing the label to assign to the object.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectPtrLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char* label) @system @nogc nothrow;

    /++
     + glObjectPtrLabel: man4/glObjectPtrLabel.xml
     + 
     + $(D_INLINECODE glObjectPtrLabel) labels the sync object identified by $(D_INLINECODE ptr). $(D_INLINECODE label) is the address of a string that will be used to label the object. $(D_INLINECODE length) contains the number of characters in $(D_INLINECODE label). If $(D_INLINECODE length) is negative, it is implied that $(D_INLINECODE label) contains a null-terminated string. If $(D_INLINECODE label) is null, any debug label is effectively removed from the object.
     + 
     + Params:
     +     ptr    = A pointer identifying a sync object.
     +     length = The length of the label to be used for the object.
     +     label  = The address of a string containing the label to assign to the object.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glObjectPtrLabel(void* ptr, GLsizei length, const char* label) @system @nogc nothrow;

    /++
     + glPatchParameter: man4/glPatchParameter.xml
     + 
     + $(D_INLINECODE glPatchParameter) specifies the parameters that will be used for patch primitives. $(D_INLINECODE pname) specifies the parameter to modify and must be either $(D_INLINECODE GL_PATCH_VERTICES), $(D_INLINECODE GL_PATCH_DEFAULT_OUTER_LEVEL) or $(D_INLINECODE GL_PATCH_DEFAULT_INNER_LEVEL). For $(D_INLINECODE glPatchParameteri), $(D_INLINECODE value) specifies the new value for the parameter specified by $(D_INLINECODE pname). For $(D_INLINECODE glPatchParameterfv), $(D_INLINECODE values) specifies the address of an array containing the new values for the parameter specified by $(D_INLINECODE pname). When $(D_INLINECODE pname) is $(D_INLINECODE GL_PATCH_VERTICES), $(D_INLINECODE value) specifies the number of vertices that will be used to make up a single patch primitive. Patch primitives are consumed by the tessellation control shader (if present) and subsequently used for tessellation. When primitives are specified using $(D_INLINECODE glDrawArrays) or a similar function, each patch will be made from $(D_INLINECODE parameter) control points, each represented by a vertex taken from the enabeld vertex arrays. $(D_INLINECODE parameter) must be greater than zero, and less than or equal to the value of $(D_INLINECODE GL_MAX_PATCH_VERTICES). When $(D_INLINECODE pname) is $(D_INLINECODE GL_PATCH_DEFAULT_OUTER_LEVEL) or $(D_INLINECODE GL_PATCH_DEFAULT_INNER_LEVEL), $(D_INLINECODE values) contains the address of an array contiaining the default outer or inner tessellation levels, respectively, to be used when no tessellation control shader is present.
     + 
     + Params:
     +     pname  = Specifies the name of the parameter to set. The symbolc constants $(D_INLINECODE GL_PATCH_VERTICES), $(D_INLINECODE GL_PATCH_DEFAULT_OUTER_LEVEL), and $(D_INLINECODE GL_PATCH_DEFAULT_INNER_LEVEL) are accepted.
     +     value  = Specifies the new value for the parameter given by $(D_INLINECODE pname).
     +     values = Specifies the address of an array containing the new values for the parameter given by $(D_INLINECODE pname).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements),
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_tessellation_shader")
    void glPatchParameteri(GLenum pname, GLint value) @system @nogc nothrow;

    /++
     + glPauseTransformFeedback: man4/glPauseTransformFeedback.xml
     + 
     + $(D_INLINECODE glPauseTransformFeedback) pauses transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glResumeTransformFeedback), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glDeleteTransformFeedbacks)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glPauseTransformFeedback() @system @nogc nothrow;

    /++
     + glPixelStore: man4/glPixelStore.xml
     + 
     + $(D_INLINECODE glPixelStore) sets pixel storage modes that affect the operation of subsequent $(D_INLINECODE glReadPixels) as well as the unpacking of texture patterns (see $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D) ), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D) or $(D_INLINECODE glCompressedTexSubImage1D). $(D_INLINECODE pname) is a symbolic constant indicating the parameter to be set, and $(D_INLINECODE param) is the new value.  Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows: The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D) They are as follows: The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with $(D_INLINECODE glPixelStore). $(B $(D_INLINECODE pname)) $(B Type) $(B Initial Value) $(B Valid Range) $(D_INLINECODE GL_PACK_SWAP_BYTES) boolean false true or false $(D_INLINECODE GL_PACK_LSB_FIRST) boolean false true or false $(D_INLINECODE GL_PACK_ROW_LENGTH) integer 0 0 &infin; $(D_INLINECODE GL_PACK_IMAGE_HEIGHT) integer 0 0 &infin; $(D_INLINECODE GL_PACK_SKIP_ROWS) integer 0 0 &infin; $(D_INLINECODE GL_PACK_SKIP_PIXELS) integer 0 0 &infin; $(D_INLINECODE GL_PACK_SKIP_IMAGES) integer 0 0 &infin; $(D_INLINECODE GL_PACK_ALIGNMENT) integer 4 1, 2, 4, or 8 $(D_INLINECODE GL_UNPACK_SWAP_BYTES) boolean false true or false $(D_INLINECODE GL_UNPACK_LSB_FIRST) boolean false true or false $(D_INLINECODE GL_UNPACK_ROW_LENGTH) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_SKIP_ROWS) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_ALIGNMENT) integer 4 1, 2, 4, or 8 $(D_INLINECODE glPixelStoref) can be used to set any pixel store parameter. If the parameter type is boolean, then if $(D_INLINECODE param) is 0, the parameter is false; otherwise it is set to true. If $(D_INLINECODE pname) is a integer type parameter, $(D_INLINECODE param) is rounded to the nearest integer. Likewise, $(D_INLINECODE glPixelStorei) can also be used to set any of the pixel store parameters. Boolean parameters are set to false if $(D_INLINECODE param) is 0 and true otherwise.
     + 
     + Params:
     +     pname = Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: $(D_INLINECODE GL_PACK_SWAP_BYTES), $(D_INLINECODE GL_PACK_LSB_FIRST), $(D_INLINECODE GL_PACK_ROW_LENGTH), $(D_INLINECODE GL_PACK_IMAGE_HEIGHT), $(D_INLINECODE GL_PACK_SKIP_PIXELS), $(D_INLINECODE GL_PACK_SKIP_ROWS), $(D_INLINECODE GL_PACK_SKIP_IMAGES), and $(D_INLINECODE GL_PACK_ALIGNMENT). Six more affect the unpacking of pixel data memory: $(D_INLINECODE GL_UNPACK_SWAP_BYTES), $(D_INLINECODE GL_UNPACK_LSB_FIRST), $(D_INLINECODE GL_UNPACK_ROW_LENGTH), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), $(D_INLINECODE GL_UNPACK_SKIP_PIXELS), $(D_INLINECODE GL_UNPACK_SKIP_ROWS), $(D_INLINECODE GL_UNPACK_SKIP_IMAGES), and $(D_INLINECODE GL_UNPACK_ALIGNMENT).
     +     param = Specifies the value that $(D_INLINECODE pname) is set to.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage1D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelStoref(GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glPointParameter: man4/glPointParameter.xml
     + 
     + The following values are accepted for $(D_INLINECODE pname) :
     + 
     + Params:
     +     pname  = Specifies a single-valued point parameter. $(D_INLINECODE GL_POINT_FADE_THRESHOLD_SIZE), and $(D_INLINECODE GL_POINT_SPRITE_COORD_ORIGIN) are accepted.
     +     param  = For $(D_INLINECODE glPointParameterf) and $(D_INLINECODE glPointParameteri), specifies the value that $(D_INLINECODE pname) will be set to.
     +     params = For $(D_INLINECODE glPointParameterfv) and $(D_INLINECODE glPointParameteriv), specifies a pointer to an array where the value or values to be assigned to $(D_INLINECODE pname) are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPointSize)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glPointParameterf(GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glPointSize: man4/glPointSize.xml
     + 
     + $(D_INLINECODE glPointSize) specifies the rasterized diameter of points. If point size mode is disabled (see $(D_INLINECODE glEnable) with parameter $(D_INLINECODE GL_PROGRAM_POINT_SIZE) ), this value will be used to rasterize points. Otherwise, the value written to the shading language built-in variable $(D_INLINECODE gl_PointSize) will be used.
     + 
     + The point size specified by $(D_INLINECODE glPointSize) is always returned when $(D_INLINECODE GL_POINT_SIZE) is queried.  Clamping and rounding for points have no effect on the specified value.
     + 
     + Params:
     +     size = Specifies the diameter of rasterized points. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glPointParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPointSize(GLfloat size) @system @nogc nothrow;

    /++
     + glPolygonMode: man4/glPolygonMode.xml
     + 
     + $(D_INLINECODE glPolygonMode) controls the interpretation of polygons for rasterization. $(D_INLINECODE face) describes which polygons $(D_INLINECODE mode) applies to: both front and back-facing polygons ( $(D_INLINECODE GL_FRONT_AND_BACK) ). The polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied. Three modes are defined and can be specified in $(D_INLINECODE mode) :
     + 
     + Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated internally by the GL when it decomposes triangle stips and fans.
     + 
     + Params:
     +     face = Specifies the polygons that $(D_INLINECODE mode) applies to. Must be $(D_INLINECODE GL_FRONT_AND_BACK) for front- and back-facing polygons.
     +     mode = Specifies how polygons will be rasterized. Accepted values are $(D_INLINECODE GL_POINT), $(D_INLINECODE GL_LINE), and $(D_INLINECODE GL_FILL). The initial value is $(D_INLINECODE GL_FILL) for both front- and back-facing polygons.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLineWidth), $(D_INLINECODE glPointSize)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPolygonMode(GLenum face, GLenum mode) @system @nogc nothrow;

    /++
     + glPolygonOffset: man4/glPolygonOffset.xml
     + 
     + When $(D_INLINECODE GL_POLYGON_OFFSET_FILL), $(D_INLINECODE GL_POLYGON_OFFSET_LINE), or $(D_INLINECODE GL_POLYGON_OFFSET_POINT) is enabled, each fragment's value will be offset after it is interpolated from the values of the appropriate vertices. The value of the offset is factor &times; DZ + r &times; units, where DZ is a measurement of the change in depth relative to the screen area of the polygon, and r is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer. $(D_INLINECODE glPolygonOffset) is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.
     + 
     + Params:
     +     factor = Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
     +     units  = Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glGet), $(D_INLINECODE glIsEnabled)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glPolygonOffset(GLfloat factor, GLfloat units) @system @nogc nothrow;

    /++
     + glPopDebugGroup: man4/glPopDebugGroup.xml
     + 
     + $(D_INLINECODE glPopDebugGroup) pops the active debug group. After popping a debug group, the GL will also generate a debug output message describing its cause based on the $(D_INLINECODE message) string, the source $(D_INLINECODE source), and an ID $(D_INLINECODE id) submitted to the corresponding $(D_INLINECODE glPushDebugGroup) command. $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP) and $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP) share a single namespace for message $(D_INLINECODE id). $(D_INLINECODE severity) has the value $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION). The $(D_INLINECODE type) has the value $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP). Popping a debug group restores the debug output volume control of the parent debug group.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glObjectPtrLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glPopDebugGroup() @system @nogc nothrow;

    /++
     + glPrimitiveRestartIndex: man4/glPrimitiveRestartIndex.xml
     + 
     + $(D_INLINECODE glPrimitiveRestartIndex) specifies a vertex array element that is treated specially when primitive restarting is enabled. This is known as the primitive restart index. When one of the $(D_INLINECODE Draw*) commands transfers a set of generic attribute array elements to the GL, if the index within the vertex arrays corresponding to that set is equal to the primitive restart index, then the GL does not process those elements as a vertex. Instead, it is as if the drawing command ended with the immediately preceding transfer, and another drawing command is immediately started with the same parameters, but only transferring the immediately following element through the end of the originally specified elements. When either $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawElementsInstancedBaseVertex) or $(D_INLINECODE glMultiDrawElementsBaseVertex) is used, the primitive restart comparison occurs before the basevertex offset is added to the array index.
     + 
     + $(D_INLINECODE glPrimitiveRestartIndex) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     index = Specifies the value to be interpreted as the primitive restart index.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    void glPrimitiveRestartIndex(GLuint index) @system @nogc nothrow;

    /++
     + glProgramBinary: man4/glProgramBinary.xml
     + 
     + $(D_INLINECODE glProgramBinary) loads a program object with a program binary previously returned from $(D_INLINECODE glGetProgramBinary). $(D_INLINECODE binaryFormat) and $(D_INLINECODE binary) must be those returned by a previous call to $(D_INLINECODE glGetProgramBinary), and $(D_INLINECODE length) must be the length returned by $(D_INLINECODE glGetProgramBinary), or by $(D_INLINECODE glGetProgram) when called with $(D_INLINECODE pname) set to $(D_INLINECODE GL_PROGRAM_BINARY_LENGTH). If these conditions are not met, loading the program binary will fail and $(D_INLINECODE program) 's $(D_INLINECODE GL_LINK_STATUS) will be set to $(D_INLINECODE GL_FALSE). A program object's program binary is replaced by calls to $(D_INLINECODE glLinkProgram) or $(D_INLINECODE glProgramBinary). When linking success or failure is concerned, $(D_INLINECODE glProgramBinary) can be considered to perform an implicit linking operation. $(D_INLINECODE glLinkProgram) and $(D_INLINECODE glProgramBinary) both set the program object's $(D_INLINECODE GL_LINK_STATUS) to $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE). A successful call to $(D_INLINECODE glProgramBinary) will reset all uniform variables to their initial values. The initial value is either the value of the variable's initializer as specified in the original shader source, or zero if no initializer was present. Additionally, all vertex shader input and fragment shader output assignments that were in effect when the program was linked before saving are restored with $(D_INLINECODE glProgramBinary) is called.
     + 
     + A program binary may fail to load if the implementation determines that there has been a change in hardware or software configuration from when the program binary was produced such as having been compiled with an incompatible or outdated version of the compiler.
     + 
     + Params:
     +     program      = Specifies the name of a program object into which to load a program binary.
     +     binaryFormat = Specifies the format of the binary data in binary.
     +     binary       = Specifies the address an array containing the binary to be loaded into $(D_INLINECODE program).
     +     length       = Specifies the number of bytes contained in $(D_INLINECODE binary).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramBinary)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    void glProgramBinary(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length) @system @nogc nothrow;

    /++
     + glProgramParameter: man4/glProgramParameter.xml
     + 
     + $(D_INLINECODE glProgramParameter) specifies a new value for the parameter nameed by $(D_INLINECODE pname) for the program object $(D_INLINECODE program). If $(D_INLINECODE pname) is $(D_INLINECODE GL_PROGRAM_BINARY_RETRIEVABLE_HINT), $(D_INLINECODE value) should be $(D_INLINECODE GL_FALSE) or $(D_INLINECODE GL_TRUE) to indicate to the implementation the intention of the application to retrieve the program's binary representation with $(D_INLINECODE glGetProgramBinary). The implementation may use this information to store information that may be useful for a future query of the program's binary. It is recommended to set $(D_INLINECODE GL_PROGRAM_BINARY_RETRIEVABLE_HINT) for the program to $(D_INLINECODE GL_TRUE) before calling $(D_INLINECODE glLinkProgram), and using the program at run-time if the binary is to be retrieved later. If $(D_INLINECODE pname) is $(D_INLINECODE GL_PROGRAM_SEPARABLE), $(D_INLINECODE value) must be $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE) and indicates whether $(D_INLINECODE program) can be bound to individual pipeline stages via $(D_INLINECODE glUseProgramStages). A program's $(D_INLINECODE GL_PROGRAM_SEPARABLE) parameter must be set to $(D_INLINECODE GL_TRUE) $(D_INLINECODE glLinkProgram) is called in order for it to be usable with a program pipeline object. The initial state of $(D_INLINECODE GL_PROGRAM_SEPARABLE) is $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     program = Specifies the name of a program object whose parameter to modify.
     +     pname   = Specifies the name of the parameter to modify.
     +     value   = Specifies the new value of the parameter specified by $(D_INLINECODE pname) for $(D_INLINECODE program).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramBinary), $(D_INLINECODE glProgramBinary)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    void glProgramParameteri(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;

    /++
     + glProgramUniform: man4/glProgramUniform.xml
     + 
     + $(D_INLINECODE glProgramUniform) modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by $(D_INLINECODE location), which should be a value returned by $(D_INLINECODE glGetUniformLocation). $(D_INLINECODE glProgramUniform) operates on the program object specified by $(D_INLINECODE program). The commands $(D_INLINECODE glProgramUniform{1|2|3|4}{f|i|ui}) are used to change the value of the uniform variable specified by $(D_INLINECODE location) using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for $(D_INLINECODE float), $(D_INLINECODE int), $(D_INLINECODE unsigned int), $(D_INLINECODE bool); $(D_INLINECODE 2) for $(D_INLINECODE vec2), $(D_INLINECODE ivec2), $(D_INLINECODE uvec2), $(D_INLINECODE bvec2), etc.). The suffix $(D_INLINECODE f) indicates that floating-point values are being passed; the suffix $(D_INLINECODE i) indicates that integer values are being passed; the suffix $(D_INLINECODE ui) indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The $(D_INLINECODE i) variants of this function should be used to provide values for uniform variables defined as $(D_INLINECODE int), $(D_INLINECODE ivec2), $(D_INLINECODE ivec3), $(D_INLINECODE ivec4), or arrays of these. The $(D_INLINECODE ui) variants of this function should be used to provide values for uniform variables defined as $(D_INLINECODE unsigned int), $(D_INLINECODE uvec2), $(D_INLINECODE uvec3), $(D_INLINECODE uvec4), or arrays of these. The $(D_INLINECODE f) variants should be used to provide values for uniform variables of type $(D_INLINECODE float), $(D_INLINECODE vec2), $(D_INLINECODE vec3), $(D_INLINECODE vec4), or arrays of these. Either the $(D_INLINECODE i), $(D_INLINECODE ui) or $(D_INLINECODE f) variants may be used to provide values for uniform variables of type $(D_INLINECODE bool), $(D_INLINECODE bvec2), $(D_INLINECODE bvec3), $(D_INLINECODE bvec4), or arrays of these. The uniform variable will be set to $(D_INLINECODE false) if the input value is 0 or 0.0f, and it will be set to $(D_INLINECODE true) otherwise. All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to $(D_INLINECODE glProgramUniform) until the next successful link operation occurs on the program object, when they are once again initialized to 0. The commands $(D_INLINECODE glProgramUniform{1|2|3|4}{f|i|ui}v) can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading elements starting at an arbitrary position in a uniform variable array, elements + - 1 in the array will be replaced with the new values. If $(D_INLINECODE m) + $(D_INLINECODE n) - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in $(D_INLINECODE value), and it should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for $(D_INLINECODE float), $(D_INLINECODE int), $(D_INLINECODE bool); $(D_INLINECODE 2) for $(D_INLINECODE vec2), $(D_INLINECODE ivec2), $(D_INLINECODE bvec2), etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for $(D_INLINECODE glProgramUniform{1|2|3|4}{f|i|ui}). For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., $(D_INLINECODE glProgramUniform3f) or $(D_INLINECODE glProgramUniform3fv) can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by $(D_INLINECODE count) The commands $(D_INLINECODE glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv) are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number $(D_INLINECODE 2) indicates a 2 &#215; 2 matrix (i.e., 4 values), the number $(D_INLINECODE 3) indicates a 3 &#215; 3 matrix (i.e., 9 values), and the number $(D_INLINECODE 4) indicates a 4 &#215; 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows.  For example, $(D_INLINECODE 2x4) indicates a 2 &#215; 4 matrix with 2 columns and 4 rows (i.e., 8 values). If $(D_INLINECODE transpose) is $(D_INLINECODE GL_FALSE), each matrix is assumed to be supplied in column major order. If $(D_INLINECODE transpose) is $(D_INLINECODE GL_TRUE), each matrix is assumed to be supplied in row major order. The $(D_INLINECODE count) argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.
     + 
     + $(D_INLINECODE glProgramUniform1i) and $(D_INLINECODE glProgramUniform1iv) are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a $(D_INLINECODE GL_INVALID_OPERATION) error. If $(D_INLINECODE count) is greater than 1 and the indicated uniform variable is not an array, a $(D_INLINECODE GL_INVALID_OPERATION) error is generated and the specified uniform variable will remain unchanged. Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a $(D_INLINECODE GL_INVALID_OPERATION) error will be generated and the specified uniform variable will remain unchanged. If $(D_INLINECODE location) is a value other than -1 and it does not represent a valid uniform variable location in within $(D_INLINECODE program), an error will be generated, and no changes will be made to the uniform variable storage of $(D_INLINECODE program). If $(D_INLINECODE location) is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
     + 
     + Params:
     +     program        = Specifies the handle of the program containing the uniform variable to be modified.
     +     location       = Specifies the location of the uniform variable to be modified.
     +     count          = For the vector commands ( $(D_INLINECODE glProgramUniform*v) ), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. For the matrix commands ( $(D_INLINECODE glProgramUniformMatrix*) ), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
     +     transpose      = For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
     +     v0, v1, v2, v3 = For the scalar commands, specifies the new values to be used for the specified uniform variable.
     +     value          = For the vector and matrix commands, specifies a pointer to an array of $(D_INLINECODE count) values that will be used to update the specified uniform variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1f(GLuint program, GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1i(GLuint program, GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1ui(GLuint program, GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;

    /++
     + glProvokingVertex: man4/glProvokingVertex.xml
     + 
     + a vertex shader varying output means to assign all vetices of the primitive the same value for that output. The vertex from which these values is derived is known as the and $(D_INLINECODE glProvokingVertex) specifies which vertex is to be used as the source of data for flat shaded varyings. $(D_INLINECODE provokeMode) must be either $(D_INLINECODE GL_FIRST_VERTEX_CONVENTION) or $(D_INLINECODE GL_LAST_VERTEX_CONVENTION), and controls the selection of the vertex whose values are assigned to flatshaded varying outputs. The interpretation of these values for the supported primitive types is: $(B Primitive Type of Polygon) $(B First Vertex Convention) $(B Last Vertex Convention) point independent line 2 - 1 2 line loop + 1, if &lt; 1, if = line strip + 1 independent triangle 3 - 2 3 triangle strip + 2 triangle fan + 1 + 2 line adjacency 4 - 2 4 - 1 line strip adjacency + 1 + 2 triangle adjacency 6 - 5 6 - 1 triangle strip adjacency 2 - 1 2 + 3 If a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using the $(D_INLINECODE flat) qualifier when declaring the output.
     + 
     + $(D_INLINECODE glProvokingVertex) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     provokeMode = Specifies the vertex to be used as the source of data for flat shaded varyings.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_provoking_vertex")
    void glProvokingVertex(GLenum provokeMode) @system @nogc nothrow;

    /++
     + glPushDebugGroup: man4/glPushDebugGroup.xml
     + 
     + $(D_INLINECODE glPushDebugGroup) pushes a debug group described by the string $(D_INLINECODE message) into the command stream. The value of $(D_INLINECODE id) specifies the ID of messages generated. The parameter $(D_INLINECODE length) contains the number of characters in $(D_INLINECODE message). If $(D_INLINECODE length) is negative, it is implied that $(D_INLINECODE message) contains a null terminated string. The message has the specified $(D_INLINECODE source) and $(D_INLINECODE id), the $(D_INLINECODE type) $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), and $(D_INLINECODE severity) $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION). The GL will put a new debug group on top of the debug group stack which inherits the control of the volume of debug output of the debug group previously residing on the top of the debug group stack. Because debug groups are strictly hierarchical, any additional control of the debug output volume will only apply within the active debug group and the debug groups pushed on top of the active debug group.
     + 
     + Params:
     +     source  = The source of the debug message.
     +     id      = The identifier of the message.
     +     length  = The length of the message to be sent to the debug output stream.
     +     message = The a string containing the message to be sent to the debug output stream.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glObjectPtrLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char* message) @system @nogc nothrow;

    /++
     + glQueryCounter: man4/glQueryCounter.xml
     + 
     + $(D_INLINECODE glQueryCounter) causes the GL to record the current time into the query object named $(D_INLINECODE id). $(D_INLINECODE target) must be $(D_INLINECODE GL_TIMESTAMP). The time is recorded after all previous commands on the GL client and server state and the framebuffer have been fully realized. When the time is recorded, the query result for that object is marked available. $(D_INLINECODE glQueryCounter) timer queries can be used within a $(D_INLINECODE glBeginQuery) / $(D_INLINECODE glEndQuery) block where the target is $(D_INLINECODE GL_TIME_ELAPSED) and it does not affect the result of that query object.
     + 
     + $(D_INLINECODE glQueryCounter) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     id     = Specify the name of a query object into which to record the GL time.
     +     target = Specify the counter to query. $(D_INLINECODE target) must be $(D_INLINECODE GL_TIMESTAMP).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenQueries), $(D_INLINECODE glBeginQuery), $(D_INLINECODE glEndQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    void glQueryCounter(GLuint id, GLenum target) @system @nogc nothrow;

    /++
     + glReadnPixels: man4/glReadPixels.xml
     + 
     + $(D_INLINECODE glReadPixels) and $(D_INLINECODE glReadnPixels) return pixel data from the frame buffer, starting with the pixel whose lower left corner is at location ( $(D_INLINECODE x), $(D_INLINECODE y) ), into client memory starting at location $(D_INLINECODE data). Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with $(D_INLINECODE glPixelStore). This reference page describes the effects on $(D_INLINECODE glReadPixels) and $(D_INLINECODE glReadnPixels) of most, but not all of the parameters specified by these three commands. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a block of pixels is requested, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store rather than a pointer to client memory. $(D_INLINECODE glReadPixels) and $(D_INLINECODE glReadnPixels) return values from each pixel with lower left corner at x + i y + j for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height. This pixel is said to be the i th pixel in the j th row. Pixels are returned in row order from the lowest to the highest row, left to right in each row. $(D_INLINECODE format) specifies the format for the returned pixel values; accepted values are: Finally, the indices or components are converted to the proper format, as specified by $(D_INLINECODE type). If $(D_INLINECODE format) is $(D_INLINECODE GL_STENCIL_INDEX) and $(D_INLINECODE type) is not $(D_INLINECODE GL_FLOAT), each index is masked with the mask value given in the following table. If $(D_INLINECODE type) is $(D_INLINECODE GL_FLOAT), then each integer index is converted to single-precision floating-point format. If $(D_INLINECODE format) is $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), $(D_INLINECODE GL_BLUE), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), or $(D_INLINECODE GL_BGRA) and $(D_INLINECODE type) is not $(D_INLINECODE GL_FLOAT), each component is multiplied by the multiplier shown in the following table. If type is $(D_INLINECODE GL_FLOAT), then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL). $(D_INLINECODE type) $(B Index Mask) $(B Component Conversion) $(D_INLINECODE GL_UNSIGNED_BYTE) 2 8 - 1 2 8 - 1 &it; c $(D_INLINECODE GL_BYTE) 2 7 - 1 2 8 - 1 &it; c - 1 2 $(D_INLINECODE GL_UNSIGNED_SHORT) 2 16 - 1 2 16 - 1 &it; c $(D_INLINECODE GL_SHORT) 2 15 - 1 2 16 - 1 &it; c - 1 2 $(D_INLINECODE GL_UNSIGNED_INT) 2 32 - 1 2 32 - 1 &it; c $(D_INLINECODE GL_INT) 2 31 - 1 2 32 - 1 &it; c - 1 2 $(D_INLINECODE GL_HALF_FLOAT) none c $(D_INLINECODE GL_FLOAT) none c $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_24_8) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) -- Special $(D_INLINECODE GL_UNSIGNED_INT_5_9_9_9_REV) -- Special $(D_INLINECODE GL_FLOAT_32_UNSIGNED_INT_24_8_REV) none c (Depth Only) Return values are placed in memory as follows. If $(D_INLINECODE format) is $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), or $(D_INLINECODE GL_BLUE), a single value is returned and the data for the i th pixel in the j th row is placed in location j &it; width + i. $(D_INLINECODE GL_RGB) and $(D_INLINECODE GL_BGR) return three values, $(D_INLINECODE GL_RGBA) and $(D_INLINECODE GL_BGRA) return four values for each pixel, with all values corresponding to a single pixel occupying contiguous space in $(D_INLINECODE data). Storage parameters set by $(D_INLINECODE glPixelStore), such as $(D_INLINECODE GL_PACK_LSB_FIRST) and $(D_INLINECODE GL_PACK_SWAP_BYTES), affect the way that data is written into memory. See $(D_INLINECODE glPixelStore) for a description. $(D_INLINECODE glReadnPixels) function will only handle the call if $(D_INLINECODE bufSize) is at least of the size required to store the requested data. Otherwise, it will generate a $(D_INLINECODE GL_INVALID_OPERATION) error.
     + 
     + Values for pixels that lie outside the window connected to the current GL context are undefined. If an error is generated, no change is made to the contents of $(D_INLINECODE data).
     + 
     + Params:
     +     x       = Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
     +     width   = Specify the dimensions of the pixel rectangle. $(D_INLINECODE width) and $(D_INLINECODE height) of one correspond to a single pixel.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), $(D_INLINECODE GL_BLUE), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), and $(D_INLINECODE GL_BGRA).
     +     type    = Specifies the data type of the pixel data. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_HALF_FLOAT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), $(D_INLINECODE GL_UNSIGNED_INT_24_8), $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV), $(D_INLINECODE GL_UNSIGNED_INT_5_9_9_9_REV), or $(D_INLINECODE GL_FLOAT_32_UNSIGNED_INT_24_8_REV).
     +     bufSize = Specifies the size of the buffer $(D_INLINECODE data) for $(D_INLINECODE glReadnPixels) function.
     +     data    = Returns the pixel data.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPixelStore), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;

    /++
     + glReleaseShaderCompiler: man4/glReleaseShaderCompiler.xml
     + 
     + $(D_INLINECODE glReleaseShaderCompiler) provides a hint to the implementation that it may free internal resources associated with its shader compiler. $(D_INLINECODE glCompileShader) may subsequently be called and the implementation may at that time reallocate resources previously freed by the call to $(D_INLINECODE glReleaseShaderCompiler).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glReleaseShaderCompiler() @system @nogc nothrow;

    /++
     + glResumeTransformFeedback: man4/glResumeTransformFeedback.xml
     + 
     + $(D_INLINECODE glResumeTransformFeedback) resumes transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glDeleteTransformFeedbacks)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glResumeTransformFeedback() @system @nogc nothrow;

    /++
     + glSampleCoverage: man4/glSampleCoverage.xml
     + 
     + Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations to generate antialiasing effects.  Multisampling transparently antialiases points, lines, polygons, and images if it is enabled. $(D_INLINECODE value) is used in constructing a temporary mask used in determining which samples will be used in resolving the final fragment color.  This mask is bitwise-anded with the coverage mask generated from the multisampling computation.  If the $(D_INLINECODE invert) flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed. If an implementation does not have any multisample buffers available, or multisampling is disabled, rasterization occurs with only a single sample computing a pixel's final RGB color. Provided an implementation supports multisample buffers, and multisampling is enabled, then a pixel's final color is generated by combining several samples per pixel.  Each sample contains color, depth, and stencil information, allowing those operations to be performed on each sample.
     + 
     + The type of the $(D_INLINECODE value) parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     value  = Specify a single floating-point sample coverage value.  The value is clamped to the range 0 1. The initial value is 1.0.
     +     invert = Specify a single boolean value representing if the coverage masks should be inverted. $(D_INLINECODE GL_TRUE) and $(D_INLINECODE GL_FALSE) are accepted.  The initial value is $(D_INLINECODE GL_FALSE).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glSampleCoverage(GLfloat value, GLboolean invert) @system @nogc nothrow;

    /++
     + glSampleMaski: man4/glSampleMaski.xml
     + 
     + $(D_INLINECODE glSampleMaski) sets one 32-bit sub-word of the multi-word sample mask, $(D_INLINECODE GL_SAMPLE_MASK_VALUE). $(D_INLINECODE maskIndex) specifies which 32-bit sub-word of the sample mask to update, and $(D_INLINECODE mask) specifies the new value to use for that sub-word. $(D_INLINECODE maskIndex) must be less than the value of $(D_INLINECODE GL_MAX_SAMPLE_MASK_WORDS). Bit of mask word corresponds to sample 32 x +.
     + 
     + $(D_INLINECODE glSampleMaski) is available only if the GL version is 3.2 or greater, or if the $(D_INLINECODE ARB_texture_multisample) extension is supported.
     + 
     + Params:
     +     maskNumber = Specifies which 32-bit sub-word of the sample mask to update.
     +     mask       = Specifies the new value of the mask sub-word.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glRenderbufferStorageMultisample), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    void glSampleMaski(GLuint maskNumber, GLbitfield mask) @system @nogc nothrow;

    /++
     + glSamplerParameter: man4/glSamplerParameter.xml
     + 
     + $(D_INLINECODE glSamplerParameter) assigns the value or values in $(D_INLINECODE params) to the sampler parameter specified as $(D_INLINECODE pname). $(D_INLINECODE sampler) specifies the sampler object to be modified, and must be the name of a sampler object previously returned from a call to $(D_INLINECODE glGenSamplers). The following symbols are accepted in $(D_INLINECODE pname) :
     + 
     + $(D_INLINECODE glSamplerParameter) is available only if the GL version is 3.3 or higher. If a sampler object is bound to a texture unit and that unit is used to sample from a texture, the parameters in the sampler are used to sample from the texture, rather than the equivalent parameters in the texture object bound to that unit. This introduces the possibility of sampling from the same texture object with different sets of sampler state, which may lead to a condition where a texture is with respect to one sampler object and not with respect to another. Thus, completeness can be considered a function of a sampler object and a texture object bound to a single texture unit, rather than a property of the texture object itself. $(D_INLINECODE GL_MIRROR_CLAMP_TO_EDGE) is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     sampler = Specifies the sampler object whose parameter to modify.
     +     pname   = Specifies the symbolic name of a sampler parameter. $(D_INLINECODE pname) can be one of the following: $(D_INLINECODE GL_TEXTURE_WRAP_S), $(D_INLINECODE GL_TEXTURE_WRAP_T), $(D_INLINECODE GL_TEXTURE_WRAP_R), $(D_INLINECODE GL_TEXTURE_MIN_FILTER), $(D_INLINECODE GL_TEXTURE_MAG_FILTER), $(D_INLINECODE GL_TEXTURE_BORDER_COLOR), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_LOD_BIAS) $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), or $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC).
     +     param   = For the scalar commands, specifies the value of $(D_INLINECODE pname).
     +     params  = For the vector commands ( $(D_INLINECODE glSamplerParameter*v) ), specifies a pointer to an array where the value or values of $(D_INLINECODE pname) are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glBindSampler), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glIsSampler), $(D_INLINECODE glBindTexture), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glScissor: man4/glScissor.xml
     + 
     + $(D_INLINECODE glScissor) defines a rectangle, called the scissor box, in window coordinates. The first two arguments, $(D_INLINECODE x) and $(D_INLINECODE y), specify the lower left corner of the box. $(D_INLINECODE width) and $(D_INLINECODE height) specify the width and height of the box. To enable and disable the scissor test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_SCISSOR_TEST). The test is initially disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. $(D_INLINECODE glScissor(0,0,1,1)) allows modification of only the lower left pixel in the window, and $(D_INLINECODE glScissor(0,0,0,0)) doesn't allow modification of any pixels in the window. When the scissor test is disabled, it is as though the scissor box includes the entire window.
     + 
     + Params:
     +     x     = Specify the lower left corner of the scissor box. Initially (0, 0).
     +     width = Specify the width and height of the scissor box. When a GL context is first attached to a window, $(D_INLINECODE width) and $(D_INLINECODE height) are set to the dimensions of that window.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glScissor(GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glScissorArray: man4/glScissorArray.xml
     + 
     + $(D_INLINECODE glScissorArrayv) defines rectangles, called scissor boxes, in window coordinates for each viewport. $(D_INLINECODE first) specifies the index of the first scissor box to modify and $(D_INLINECODE count) specifies the number of scissor boxes to modify. $(D_INLINECODE first) must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS), and $(D_INLINECODE first) + $(D_INLINECODE count) must be less than or equal to the value of $(D_INLINECODE GL_MAX_VIEWPORTS). $(D_INLINECODE v) specifies the address of an array containing integers specifying the lower left corner of the scissor boxes, and the width and height of the scissor boxes, in that order. To enable and disable the scissor test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_SCISSOR_TEST). The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. $(D_INLINECODE glScissor(0,0,1,1)) allows modification of only the lower left pixel in the window, and $(D_INLINECODE glScissor(0,0,0,0)) doesn't allow modification of any pixels in the window. When the scissor test is disabled, it is as though the scissor box includes the entire window.
     + 
     + Params:
     +     first = Specifies the index of the first viewport whose scissor box to modify.
     +     count = Specifies the number of scissor boxes to modify.
     +     v     = Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glViewport), $(D_INLINECODE glViewportIndexed), $(D_INLINECODE glViewportArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glScissorArrayv(GLuint first, GLsizei count, const GLint* v) @system @nogc nothrow;

    /++
     + glScissorIndexed: man4/glScissorIndexed.xml
     + 
     + $(D_INLINECODE glScissorIndexed) defines the scissor box for a specified viewport. $(D_INLINECODE index) specifies the index of scissor box to modify. $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS). For $(D_INLINECODE glScissorIndexed), $(D_INLINECODE left), $(D_INLINECODE bottom), $(D_INLINECODE width) and $(D_INLINECODE height) specify the left, bottom, width and height of the scissor box, in pixels, respectively. For $(D_INLINECODE glScissorIndexedv), $(D_INLINECODE v) specifies the address of an array containing integers specifying the lower left corner of the scissor box, and the width and height of the scissor box, in that order. To enable and disable the scissor test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_SCISSOR_TEST). The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. $(D_INLINECODE glScissor(0,0,1,1)) allows modification of only the lower left pixel in the window, and $(D_INLINECODE glScissor(0,0,0,0)) doesn't allow modification of any pixels in the window. When the scissor test is disabled, it is as though the scissor box includes the entire window.
     + 
     + Params:
     +     index = Specifies the index of the viewport whose scissor box to modify.
     +     left  = Specify the coordinate of the bottom left corner of the scissor box, in pixels.
     +     width = Specify ths dimensions of the scissor box, in pixels.
     +     v     = For $(D_INLINECODE glScissorIndexedv), specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glScissor), $(D_INLINECODE glScissorArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glScissorIndexedv(GLuint index, const GLint* v) @system @nogc nothrow;

    /++
     + glShaderBinary: man4/glShaderBinary.xml
     + 
     + $(D_INLINECODE glShaderBinary) loads pre-compiled shader binary code into the $(D_INLINECODE count) shader objects whose handles are given in $(D_INLINECODE shaders). $(D_INLINECODE binary) points to $(D_INLINECODE length) bytes of binary shader code stored in client memory. $(D_INLINECODE binaryFormat) specifies the format of the pre-compiled code. The binary image contained in $(D_INLINECODE binary) will be decoded according to the extension specification defining the specified $(D_INLINECODE binaryFormat) token. OpenGL does not define any specific binary formats, but it does provide a mechanism to obtain token vaues for such formats provided by such extensions. Depending on the types of the shader objects in $(D_INLINECODE shaders), $(D_INLINECODE glShaderBinary) will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized pair of vertex and fragment shaders stored in the same binary.
     + 
     + Params:
     +     count        = Specifies the number of shader object handles contained in $(D_INLINECODE shaders).
     +     shaders      = Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
     +     binaryFormat = Specifies the format of the shader binaries contained in $(D_INLINECODE binary).
     +     binary       = Specifies the address of an array of bytes containing pre-compiled binary shader code.
     +     length       = Specifies the length of the array whose address is given in $(D_INLINECODE binary).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramBinary), $(D_INLINECODE glProgramBinary)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glShaderBinary(GLsizei count, const GLuint* shaders, GLenum binaryFormat, const void* binary, GLsizei length) @system @nogc nothrow;

    /++
     + glShaderSource: man4/glShaderSource.xml
     + 
     + $(D_INLINECODE glShaderSource) sets the source code in $(D_INLINECODE shader) to the source code in the array of strings specified by $(D_INLINECODE string). Any source code previously stored in the shader object is completely replaced. The number of strings in the array is specified by $(D_INLINECODE count). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), each string is assumed to be null terminated. If $(D_INLINECODE length) is a value other than $(D_INLINECODE null
     + ), it points to an array containing a string length for each of the corresponding elements of $(D_INLINECODE string). Each element in the $(D_INLINECODE length) array may contain the length of the corresponding string (the null character is not counted as part of the string length) or a value less than 0 to indicate that the string is null terminated. The source code strings are not scanned or parsed at this time; they are simply copied into the specified shader object.
     + 
     + OpenGL copies the shader source code strings when $(D_INLINECODE glShaderSource) is called, so an application may free its copy of the source code strings immediately after the function returns.
     + 
     + Params:
     +     shader = Specifies the handle of the shader object whose source code is to be replaced.
     +     count  = Specifies the number of elements in the $(D_INLINECODE string) and $(D_INLINECODE length) arrays.
     +     string = Specifies an array of pointers to strings containing the source code to be loaded into the shader.
     +     length = Specifies an array of string lengths.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glShaderSource(GLuint shader, GLsizei count, const GLchar** string, const GLint* length) @system @nogc nothrow;

    /++
     + glShaderStorageBlockBinding: man4/glShaderStorageBlockBinding.xml
     + 
     + $(D_INLINECODE glShaderStorageBlockBinding), changes the active shader storage block with an assigned index of $(D_INLINECODE storageBlockIndex) in program object $(D_INLINECODE program). $(D_INLINECODE storageBlockIndex) must be an active shader storage block index in $(D_INLINECODE program). $(D_INLINECODE storageBlockBinding) must be less than the value of $(D_INLINECODE GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS). If successful, $(D_INLINECODE glShaderStorageBinding) specifies that $(D_INLINECODE program) will use the data store of the buffer object bound to the binding point $(D_INLINECODE storageBlockBinding) to read and write the values of the buffer variables in the shader storage block identified by $(D_INLINECODE storageBlockIndex).
     + 
     + Params:
     +     program             = The name of the program containing the block whose binding to change.
     +     storageBlockIndex   = The index storage block within the program.
     +     storageBlockBinding = The index storage block binding to associate with the specified storage block.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_shader_storage_buffer_object")
    void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) @system @nogc nothrow;

    /++
     + glStencilFunc: man4/glStencilFunc.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST). To specify actions based on the outcome of the stencil test, call $(D_INLINECODE glStencilOp) or $(D_INLINECODE glStencilOpSeparate). There can be two separate sets of $(D_INLINECODE func), $(D_INLINECODE ref), and $(D_INLINECODE mask) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilFunc) sets both front and back stencil state to the same values. Use $(D_INLINECODE glStencilFuncSeparate) to set front and back stencil state to different values. $(D_INLINECODE func) is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. $(D_INLINECODE ref) is an integer reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. $(D_INLINECODE mask) is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison. If represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by $(D_INLINECODE func). Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see $(D_INLINECODE glStencilOp) ). All tests treat values as unsigned integers in the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The following values are accepted by $(D_INLINECODE func) :
     + 
     + Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes. $(D_INLINECODE glStencilFunc) is the same as calling $(D_INLINECODE glStencilFuncSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     +     func = Specifies the test function. Eight symbolic constants are valid: $(D_INLINECODE GL_NEVER), $(D_INLINECODE GL_LESS), $(D_INLINECODE GL_LEQUAL), $(D_INLINECODE GL_GREATER), $(D_INLINECODE GL_GEQUAL), $(D_INLINECODE GL_EQUAL), $(D_INLINECODE GL_NOTEQUAL), and $(D_INLINECODE GL_ALWAYS). The initial value is $(D_INLINECODE GL_ALWAYS).
     +     ref_ = Specifies the reference value for the stencil test. $(D_INLINECODE ref) is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.
     +     mask = Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glStencilFunc(GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;

    /++
     + glStencilFuncSeparate: man4/glStencilFuncSeparate.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST). To specify actions based on the outcome of the stencil test, call $(D_INLINECODE glStencilOp) or $(D_INLINECODE glStencilOpSeparate). There can be two separate sets of $(D_INLINECODE func), $(D_INLINECODE ref), and $(D_INLINECODE mask) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilFunc) sets both front and back stencil state to the same values, as if $(D_INLINECODE glStencilFuncSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK). $(D_INLINECODE func) is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. $(D_INLINECODE ref) is an integer reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. $(D_INLINECODE mask) is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison. If represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by $(D_INLINECODE func). Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see $(D_INLINECODE glStencilOp) ). All tests treat values as unsigned integers in the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The following values are accepted by $(D_INLINECODE func) :
     + 
     + Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
     + 
     + Params:
     +     face = Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), and $(D_INLINECODE GL_FRONT_AND_BACK).
     +     func = Specifies the test function. Eight symbolic constants are valid: $(D_INLINECODE GL_NEVER), $(D_INLINECODE GL_LESS), $(D_INLINECODE GL_LEQUAL), $(D_INLINECODE GL_GREATER), $(D_INLINECODE GL_GEQUAL), $(D_INLINECODE GL_EQUAL), $(D_INLINECODE GL_NOTEQUAL), and $(D_INLINECODE GL_ALWAYS). The initial value is $(D_INLINECODE GL_ALWAYS).
     +     ref_ = Specifies the reference value for the stencil test. $(D_INLINECODE ref) is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.
     +     mask = Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
     + 
     + Copyright:
     +     Copyright&copy; 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;

    /++
     + glStencilMask: man4/glStencilMask.xml
     + 
     + $(D_INLINECODE glStencilMask) controls the writing of individual bits in the stencil planes. The least significant n bits of $(D_INLINECODE mask), where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing. There can be two separate $(D_INLINECODE mask) writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilMask) sets both front and back stencil writemasks to the same values. Use $(D_INLINECODE glStencilMaskSeparate) to set front and back stencil writemasks to different values.
     + 
     + $(D_INLINECODE glStencilMask) is the same as calling $(D_INLINECODE glStencilMaskSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     +     mask = Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glStencilMask(GLuint mask) @system @nogc nothrow;

    /++
     + glStencilMaskSeparate: man4/glStencilMaskSeparate.xml
     + 
     + $(D_INLINECODE glStencilMaskSeparate) controls the writing of individual bits in the stencil planes. The least significant n bits of $(D_INLINECODE mask), where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing. There can be two separate $(D_INLINECODE mask) writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilMask) sets both front and back stencil writemasks to the same values, as if $(D_INLINECODE glStencilMaskSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     +     face = Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), and $(D_INLINECODE GL_FRONT_AND_BACK).
     +     mask = Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
     + 
     + Copyright:
     +     Copyright&copy; 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glStencilMaskSeparate(GLenum face, GLuint mask) @system @nogc nothrow;

    /++
     + glStencilOp: man4/glStencilOp.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST); to control it, call $(D_INLINECODE glStencilFunc) or $(D_INLINECODE glStencilFuncSeparate). There can be two separate sets of $(D_INLINECODE sfail), $(D_INLINECODE dpfail), and $(D_INLINECODE dppass) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilOp) sets both front and back stencil state to the same values. Use $(D_INLINECODE glStencilOpSeparate) to set front and back stencil state to different values. $(D_INLINECODE glStencilOp) takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and $(D_INLINECODE sfail) specifies what happens to the stencil buffer contents. The following eight actions are possible. Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n - 1, where n is the value returned by querying $(D_INLINECODE GL_STENCIL_BITS). The other two arguments to $(D_INLINECODE glStencilOp) specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed ( $(D_INLINECODE dppass) ) or fail ( $(D_INLINECODE dpfail) ) (see $(D_INLINECODE glDepthFunc) ). The actions are specified using the same eight symbolic constants as $(D_INLINECODE sfail). Note that $(D_INLINECODE dpfail) is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, $(D_INLINECODE sfail) and $(D_INLINECODE dppass) specify stencil action when the stencil test fails and passes, respectively.
     + 
     + Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil tests always pass, regardless of any call to $(D_INLINECODE glStencilOp). $(D_INLINECODE glStencilOp) is the same as calling $(D_INLINECODE glStencilOpSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     +     sfail  = Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: $(D_INLINECODE GL_KEEP), $(D_INLINECODE GL_ZERO), $(D_INLINECODE GL_REPLACE), $(D_INLINECODE GL_INCR), $(D_INLINECODE GL_INCR_WRAP), $(D_INLINECODE GL_DECR), $(D_INLINECODE GL_DECR_WRAP), and $(D_INLINECODE GL_INVERT). The initial value is $(D_INLINECODE GL_KEEP).
     +     dpfail = Specifies the stencil action when the stencil test passes, but the depth test fails. $(D_INLINECODE dpfail) accepts the same symbolic constants as $(D_INLINECODE sfail). The initial value is $(D_INLINECODE GL_KEEP).
     +     dppass = Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. $(D_INLINECODE dppass) accepts the same symbolic constants as $(D_INLINECODE sfail). The initial value is $(D_INLINECODE GL_KEEP).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;

    /++
     + glStencilOpSeparate: man4/glStencilOpSeparate.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST); to control it, call $(D_INLINECODE glStencilFunc) or $(D_INLINECODE glStencilFuncSeparate). There can be two separate sets of $(D_INLINECODE sfail), $(D_INLINECODE dpfail), and $(D_INLINECODE dppass) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilOp) sets both front and back stencil state to the same values, as if $(D_INLINECODE glStencilOpSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK). $(D_INLINECODE glStencilOpSeparate) takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and $(D_INLINECODE sfail) specifies what happens to the stencil buffer contents. The following eight actions are possible. Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n - 1, where n is the value returned by querying $(D_INLINECODE GL_STENCIL_BITS). The other two arguments to $(D_INLINECODE glStencilOpSeparate) specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed ( $(D_INLINECODE dppass) ) or fail ( $(D_INLINECODE dpfail) ) (see $(D_INLINECODE glDepthFunc) ). The actions are specified using the same eight symbolic constants as $(D_INLINECODE sfail). Note that $(D_INLINECODE dpfail) is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, $(D_INLINECODE sfail) and $(D_INLINECODE dppass) specify stencil action when the stencil test fails and passes, respectively.
     + 
     + Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
     + 
     + Params:
     +     face   = Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), and $(D_INLINECODE GL_FRONT_AND_BACK).
     +     sfail  = Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: $(D_INLINECODE GL_KEEP), $(D_INLINECODE GL_ZERO), $(D_INLINECODE GL_REPLACE), $(D_INLINECODE GL_INCR), $(D_INLINECODE GL_INCR_WRAP), $(D_INLINECODE GL_DECR), $(D_INLINECODE GL_DECR_WRAP), and $(D_INLINECODE GL_INVERT). The initial value is $(D_INLINECODE GL_KEEP).
     +     dpfail = Specifies the stencil action when the stencil test passes, but the depth test fails. $(D_INLINECODE dpfail) accepts the same symbolic constants as $(D_INLINECODE sfail). The initial value is $(D_INLINECODE GL_KEEP).
     +     dppass = Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. $(D_INLINECODE dppass) accepts the same symbolic constants as $(D_INLINECODE sfail). The initial value is $(D_INLINECODE GL_KEEP).
     + 
     + Copyright:
     +     Copyright&copy; 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;

    /++
     + glTexBuffer: man4/glTexBuffer.xml
     + 
     + $(D_INLINECODE glTexBuffer) and $(D_INLINECODE glTextureBuffer) attaches the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found found in the buffer object. The texture object must be a buffer texture. If $(D_INLINECODE buffer) is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If $(D_INLINECODE buffer) is non-zero, it must be the name of an existing buffer object. $(D_INLINECODE internalformat) specifies the storage format, and must be one of the following sized internal formats: $(D_INLINECODE internalformat) specifies the storage format, and must be one of the following sized internal formats: $(B Component) $(B Sized Internal Format) $(B Base Type) $(B Components) $(B Norm) 0 1 2 3 $(D_INLINECODE GL_R8) ubyte 1 YES R 0 0 1 $(D_INLINECODE GL_R16) ushort 1 YES R 0 0 1 $(D_INLINECODE GL_R16F) half 1 NO R 0 0 1 $(D_INLINECODE GL_R32F) float 1 NO R 0 0 1 $(D_INLINECODE GL_R8I) byte 1 NO R 0 0 1 $(D_INLINECODE GL_R16I) short 1 NO R 0 0 1 $(D_INLINECODE GL_R32I) int 1 NO R 0 0 1 $(D_INLINECODE GL_R8UI) ubyte 1 NO R 0 0 1 $(D_INLINECODE GL_R16UI) ushort 1 NO R 0 0 1 $(D_INLINECODE GL_R32UI) uint 1 NO R 0 0 1 $(D_INLINECODE GL_RG8) ubyte 2 YES R G 0 1 $(D_INLINECODE GL_RG16) ushort 2 YES R G 0 1 $(D_INLINECODE GL_RG16F) half 2 NO R G 0 1 $(D_INLINECODE GL_RG32F) float 2 NO R G 0 1 $(D_INLINECODE GL_RG8I) byte 2 NO R G 0 1 $(D_INLINECODE GL_RG16I) short 2 NO R G 0 1 $(D_INLINECODE GL_RG32I) int 2 NO R G 0 1 $(D_INLINECODE GL_RG8UI) ubyte 2 NO R G 0 1 $(D_INLINECODE GL_RG16UI) ushort 2 NO R G 0 1 $(D_INLINECODE GL_RG32UI) uint 2 NO R G 0 1 $(D_INLINECODE GL_RGB32F) float 3 NO R G B 1 $(D_INLINECODE GL_RGB32I) int 3 NO R G B 1 $(D_INLINECODE GL_RGB32UI) uint 3 NO R G B 1 $(D_INLINECODE GL_RGBA8) uint 4 YES R G B A $(D_INLINECODE GL_RGBA16) short 4 YES R G B A $(D_INLINECODE GL_RGBA16F) half 4 NO R G B A $(D_INLINECODE GL_RGBA32F) float 4 NO R G B A $(D_INLINECODE GL_RGBA8I) byte 4 NO R G B A $(D_INLINECODE GL_RGBA16I) short 4 NO R G B A $(D_INLINECODE GL_RGBA32I) int 4 NO R G B A $(D_INLINECODE GL_RGBA8UI) ubyte 4 NO R G B A $(D_INLINECODE GL_RGBA16UI) ushort 4 NO R G B A $(D_INLINECODE GL_RGBA32UI) uint 4 NO R G B A When a buffer object is attached to a buffer texture, the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$ where $size$ is the size of the buffer object in basic machine units (the value of $(D_INLINECODE GL_BUFFER_SIZE) for $(D_INLINECODE buffer) ), and $components$ and $base\_type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit $(D_INLINECODE GL_MAX_TEXTURE_BUFFER_SIZE). When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.
     + 
     + Params:
     +     target         = Specifies the target to which the texture is bound for $(D_INLINECODE glTexBuffer). Must be $(D_INLINECODE GL_TEXTURE_BUFFER).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureBuffer).
     +     internalFormat = Specifies the internal format of the data in the store belonging to $(D_INLINECODE buffer).
     +     buffer         = Specifies the name of the buffer object whose storage to attach to the active buffer texture.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGenTextures), $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    void glTexBuffer(GLenum target, GLenum internalFormat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer) @system @nogc nothrow;

    /++
     + glTexBufferRange: man4/glTexBufferRange.xml
     + 
     + $(D_INLINECODE glTexBufferRange) and $(D_INLINECODE glTextureBufferRange) attach a range of the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found found in the buffer object. The texture object must be a buffer texture. If $(D_INLINECODE buffer) is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If $(D_INLINECODE buffer) is non-zero, it must be the name of an existing buffer object. The start and size of the range are specified by $(D_INLINECODE offset) and $(D_INLINECODE size) respectively, both measured in basic machine units. $(D_INLINECODE offset) must be greater than or equal to zero, $(D_INLINECODE size) must be greater than zero, and the sum of $(D_INLINECODE offset) and $(D_INLINECODE size) must not exceed the value of $(D_INLINECODE GL_BUFFER_SIZE) for $(D_INLINECODE buffer). Furthermore, $(D_INLINECODE offset) must be an integer multiple of the value of $(D_INLINECODE GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT). $(D_INLINECODE internalformat) specifies the storage format, and must be one of the following sized internal formats: $(B Component) $(B Sized Internal Format) $(B Base Type) $(B Components) $(B Norm) 0 1 2 3 $(D_INLINECODE GL_R8) ubyte 1 YES R 0 0 1 $(D_INLINECODE GL_R16) ushort 1 YES R 0 0 1 $(D_INLINECODE GL_R16F) half 1 NO R 0 0 1 $(D_INLINECODE GL_R32F) float 1 NO R 0 0 1 $(D_INLINECODE GL_R8I) byte 1 NO R 0 0 1 $(D_INLINECODE GL_R16I) short 1 NO R 0 0 1 $(D_INLINECODE GL_R32I) int 1 NO R 0 0 1 $(D_INLINECODE GL_R8UI) ubyte 1 NO R 0 0 1 $(D_INLINECODE GL_R16UI) ushort 1 NO R 0 0 1 $(D_INLINECODE GL_R32UI) uint 1 NO R 0 0 1 $(D_INLINECODE GL_RG8) ubyte 2 YES R G 0 1 $(D_INLINECODE GL_RG16) ushort 2 YES R G 0 1 $(D_INLINECODE GL_RG16F) half 2 NO R G 0 1 $(D_INLINECODE GL_RG32F) float 2 NO R G 0 1 $(D_INLINECODE GL_RG8I) byte 2 NO R G 0 1 $(D_INLINECODE GL_RG16I) short 2 NO R G 0 1 $(D_INLINECODE GL_RG32I) int 2 NO R G 0 1 $(D_INLINECODE GL_RG8UI) ubyte 2 NO R G 0 1 $(D_INLINECODE GL_RG16UI) ushort 2 NO R G 0 1 $(D_INLINECODE GL_RG32UI) uint 2 NO R G 0 1 $(D_INLINECODE GL_RGB32F) float 3 NO R G B 1 $(D_INLINECODE GL_RGB32I) int 3 NO R G B 1 $(D_INLINECODE GL_RGB32UI) uint 3 NO R G B 1 $(D_INLINECODE GL_RGBA8) uint 4 YES R G B A $(D_INLINECODE GL_RGBA16) short 4 YES R G B A $(D_INLINECODE GL_RGBA16F) half 4 NO R G B A $(D_INLINECODE GL_RGBA32F) float 4 NO R G B A $(D_INLINECODE GL_RGBA8I) byte 4 NO R G B A $(D_INLINECODE GL_RGBA16I) short 4 NO R G B A $(D_INLINECODE GL_RGBA32I) int 4 NO R G B A $(D_INLINECODE GL_RGBA8UI) ubyte 4 NO R G B A $(D_INLINECODE GL_RGBA16UI) ushort 4 NO R G B A $(D_INLINECODE GL_RGBA32UI) uint 4 NO R G B A When a range of a buffer object is attached to a buffer texture, the specified range of the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$ where $components$ and $base\_type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit $(D_INLINECODE GL_MAX_TEXTURE_BUFFER_SIZE). When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.
     + 
     + Params:
     +     target         = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexBufferRange). Must be $(D_INLINECODE GL_TEXTURE_BUFFER).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureBufferRange).
     +     internalFormat = Specifies the internal format of the data in the store belonging to $(D_INLINECODE buffer).
     +     buffer         = Specifies the name of the buffer object whose storage to attach to the active buffer texture.
     +     offset         = Specifies the offset of the start of the range of the buffer's data store to attach.
     +     size           = Specifies the size of the range of the buffer's data store to attach.
     + 
     + Copyright:
     +     Copyright&copy; 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexBuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_buffer_range")
    void glTexBufferRange(GLenum target, GLenum internalFormat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size) @system @nogc nothrow;

    /++
     + glTexImage1D: man4/glTexImage1D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable one-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_1D). Texture images are defined with $(D_INLINECODE glTexImage1D). The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and the internal resolution and format used to store the image. The last three arguments describe how the image is represented in memory. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_1D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D), data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type). These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right through the remaining texels in the texture array. The final element corresponds to the right end of the texture array. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB) and $(D_INLINECODE GL_RGBA) must match exactly.) $(D_INLINECODE internalFormat) may be one of the base internal formats shown in Table 1, below<h3> Base Internal Formats</h3> $(B Base Internal Format) $(B RGBA, Depth and Stencil Values) $(B Internal Components) $(D_INLINECODE GL_DEPTH_COMPONENT) Depth D $(D_INLINECODE GL_DEPTH_STENCIL) Depth, Stencil D, S $(D_INLINECODE GL_RED) Red R $(D_INLINECODE GL_RG) Red, Green R, G $(D_INLINECODE GL_RGB) Red, Green, Blue R, G, B $(D_INLINECODE GL_RGBA) Red, Green, Blue, Alpha R, G, B, A $(D_INLINECODE internalFormat) may also be one of the sized internal formats shown in Table 2, below<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32 Finally, $(D_INLINECODE internalFormat) may also be one of the generic or compressed compressed texture formats shown in Table 3 below<h3> Compressed Internal Formats</h3> $(B Compressed Internal Format) $(B Base Internal Format) $(B Type) $(D_INLINECODE GL_COMPRESSED_RED) $(D_INLINECODE GL_RED) Generic $(D_INLINECODE GL_COMPRESSED_RG) $(D_INLINECODE GL_RG) Generic $(D_INLINECODE GL_COMPRESSED_RGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_RGBA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_SRGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA) or $(D_INLINECODE GL_SRGB8_ALPHA8), the texture is treated as if the red, green, or blue components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_1D) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color from $(D_INLINECODE data). A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components. Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result.  See $(D_INLINECODE glTexParameter) for details on texture comparison.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images. $(D_INLINECODE data) may be a null pointer. In this case texture memory is allocated to accommodate a texture of width $(D_INLINECODE width). You can then download subtextures to initialize the texture memory. The image is undefined if the program tries to apply an uninitialized portion of the texture image to a primitive. $(D_INLINECODE glTexImage1D) specifies the one-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) may be used for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_1D) or $(D_INLINECODE GL_PROXY_TEXTURE_1D).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalFormat = Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
     +     width          = Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1.
     +     border         = This value must be 0.
     +     format         = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_RED_INTEGER), $(D_INLINECODE GL_RG_INTEGER), $(D_INLINECODE GL_RGB_INTEGER), $(D_INLINECODE GL_BGR_INTEGER), $(D_INLINECODE GL_RGBA_INTEGER), $(D_INLINECODE GL_BGRA_INTEGER), $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL).
     +     type           = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     data           = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glTexImage2D: man4/glTexImage2D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. To define texture images, call $(D_INLINECODE glTexImage2D). The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and number of color components provided. The last three arguments describe how the image is represented in memory. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), or $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_RECTANGLE) or one of the $(D_INLINECODE GL_TEXTURE_CUBE_MAP) targets, data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type).  These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D_ARRAY), data is interpreted as an array of one-dimensional images. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), and $(D_INLINECODE GL_RGBA) must match exactly.) $(D_INLINECODE internalFormat) may be one of the base internal formats shown in Table 1, below<h3> Base Internal Formats</h3> $(B Base Internal Format) $(B RGBA, Depth and Stencil Values) $(B Internal Components) $(D_INLINECODE GL_DEPTH_COMPONENT) Depth D $(D_INLINECODE GL_DEPTH_STENCIL) Depth, Stencil D, S $(D_INLINECODE GL_RED) Red R $(D_INLINECODE GL_RG) Red, Green R, G $(D_INLINECODE GL_RGB) Red, Green, Blue R, G, B $(D_INLINECODE GL_RGBA) Red, Green, Blue, Alpha R, G, B, A $(D_INLINECODE internalFormat) may also be one of the sized internal formats shown in Table 2, below<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32 Finally, $(D_INLINECODE internalFormat) may also be one of the generic or compressed compressed texture formats shown in Table 3 below<h3> Compressed Internal Formats</h3> $(B Compressed Internal Format) $(B Base Internal Format) $(B Type) $(D_INLINECODE GL_COMPRESSED_RED) $(D_INLINECODE GL_RED) Generic $(D_INLINECODE GL_COMPRESSED_RG) $(D_INLINECODE GL_RG) Generic $(D_INLINECODE GL_COMPRESSED_RGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_RGBA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_SRGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), or $(D_INLINECODE GL_SRGB8_ALPHA8), the texture is treated as if the red, green, or blue components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color extracted from $(D_INLINECODE data). A two-component image uses the R and G values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components. Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See $(D_INLINECODE glTexParameter) for details on texture comparison.
     + 
     + The $(D_INLINECODE glPixelStore) mode affects texture images. $(D_INLINECODE data) may be a null pointer. In this case, texture memory is allocated to accommodate a texture of width $(D_INLINECODE width) and height $(D_INLINECODE height). You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive. $(D_INLINECODE glTexImage2D) specifies the two-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) may be used for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_RECTANGLE) or $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), $(D_INLINECODE level) must be 0.
     +     internalFormat = Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
     +     width          = Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
     +     height         = Specifies the height of the texture image, or the number of layers in a texture array, in the case of the $(D_INLINECODE GL_TEXTURE_1D_ARRAY) and $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY) targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
     +     border         = This value must be 0.
     +     format         = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_RED_INTEGER), $(D_INLINECODE GL_RG_INTEGER), $(D_INLINECODE GL_RGB_INTEGER), $(D_INLINECODE GL_BGR_INTEGER), $(D_INLINECODE GL_RGBA_INTEGER), $(D_INLINECODE GL_BGRA_INTEGER), $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL).
     +     type           = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     data           = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glTexImage2DMultisample: man4/glTexImage2DMultisample.xml
     + 
     + $(D_INLINECODE glTexImage2DMultisample) establishes the data storage, format, dimensions and number of samples of a multisample texture's image. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE). $(D_INLINECODE width) and $(D_INLINECODE height) are the dimensions in texels of the texture, and must be in the range zero to the value of $(D_INLINECODE GL_MAX_TEXTURE_SIZE) minus one. $(D_INLINECODE samples) specifies the number of samples in the image and must be in the range zero to the value of $(D_INLINECODE GL_MAX_SAMPLES) minus one. $(D_INLINECODE internalformat) must be a color-renderable, depth-renderable, or stencil-renderable format. If $(D_INLINECODE fixedsamplelocations) is $(D_INLINECODE GL_TRUE), the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.
     + 
     + $(D_INLINECODE glTexImage2DMultisample) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     target               = Specifies the target of the operation. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE).
     +     samples              = The number of samples in the multisample texture's image.
     +     internalformat       = The internal format to be used to store the multisample texture's image. $(D_INLINECODE internalformat) must specify a color-renderable, depth-renderable, or stencil-renderable format.
     +     width                = The width of the multisample texture's image, in texels.
     +     height               = The height of the multisample texture's image, in texels.
     +     fixedsamplelocations = Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage2DMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;

    /++
     + glTexImage3D: man4/glTexImage3D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable three-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_3D). To define texture images, call $(D_INLINECODE glTexImage3D). The arguments describe the parameters of the texture image, such as height, width, depth, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and number of color components provided. The last three arguments describe how the image is represented in memory. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_3D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_3D), data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type). These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), and $(D_INLINECODE GL_RGBA) must match exactly.) $(D_INLINECODE internalFormat) may be one of the base internal formats shown in Table 1, below<h3> Base Internal Formats</h3> $(B Base Internal Format) $(B RGBA, Depth and Stencil Values) $(B Internal Components) $(D_INLINECODE GL_DEPTH_COMPONENT) Depth D $(D_INLINECODE GL_DEPTH_STENCIL) Depth, Stencil D, S $(D_INLINECODE GL_RED) Red R $(D_INLINECODE GL_RG) Red, Green R, G $(D_INLINECODE GL_RGB) Red, Green, Blue R, G, B $(D_INLINECODE GL_RGBA) Red, Green, Blue, Alpha R, G, B, A $(D_INLINECODE internalFormat) may also be one of the sized internal formats shown in Table 2, below<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32 Finally, $(D_INLINECODE internalFormat) may also be one of the generic or compressed compressed texture formats shown in Table 3 below<h3> Compressed Internal Formats</h3> $(B Compressed Internal Format) $(B Base Internal Format) $(B Type) $(D_INLINECODE GL_COMPRESSED_RED) $(D_INLINECODE GL_RED) Generic $(D_INLINECODE GL_COMPRESSED_RG) $(D_INLINECODE GL_RG) Generic $(D_INLINECODE GL_COMPRESSED_RGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_RGBA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_SRGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), or $(D_INLINECODE GL_SRGB8_ALPHA8), the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_3D) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color extracted from $(D_INLINECODE data). A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
     + 
     + The $(D_INLINECODE glPixelStore) mode affects texture images. $(D_INLINECODE data) may be a null pointer. In this case texture memory is allocated to accommodate a texture of width $(D_INLINECODE width), height $(D_INLINECODE height), and depth $(D_INLINECODE depth). You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive. $(D_INLINECODE glTexImage3D) specifies the three-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) may be used for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be one of $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap reduction image.
     +     internalFormat = Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
     +     width          = Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
     +     height         = Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
     +     depth          = Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
     +     border         = This value must be 0.
     +     format         = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_RED_INTEGER), $(D_INLINECODE GL_RG_INTEGER), $(D_INLINECODE GL_RGB_INTEGER), $(D_INLINECODE GL_BGR_INTEGER), $(D_INLINECODE GL_RGBA_INTEGER), $(D_INLINECODE GL_BGRA_INTEGER), $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL).
     +     type           = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     data           = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glTexImage3DMultisample: man4/glTexImage3DMultisample.xml
     + 
     + $(D_INLINECODE glTexImage3DMultisample) establishes the data storage, format, dimensions and number of samples of a multisample texture's image. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY). $(D_INLINECODE width) and $(D_INLINECODE height) are the dimensions in texels of the texture, and must be in the range zero to the value of $(D_INLINECODE GL_MAX_TEXTURE_SIZE) minus one. $(D_INLINECODE depth) is the number of array slices in the array texture's image. $(D_INLINECODE samples) specifies the number of samples in the image and must be in the range zero to the value of $(D_INLINECODE GL_MAX_SAMPLES) minus one. $(D_INLINECODE internalformat) must be a color-renderable, depth-renderable, or stencil-renderable format. If $(D_INLINECODE fixedsamplelocations) is $(D_INLINECODE GL_TRUE), the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.
     + 
     + $(D_INLINECODE glTexImage2DMultisample) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     target               = Specifies the target of the operation. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY).
     +     samples              = The number of samples in the multisample texture's image.
     +     internalformat       = The internal format to be used to store the multisample texture's image. $(D_INLINECODE internalformat) must specify a color-renderable, depth-renderable, or stencil-renderable format.
     +     width                = The width of the multisample texture's image, in texels.
     +     height               = The height of the multisample texture's image, in texels.
     +     fixedsamplelocations = Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage2DMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;

    /++
     + glTexParameter: man4/glTexParameter.xml
     + 
     + $(D_INLINECODE glTexParameter) and $(D_INLINECODE glTextureParameter) assign the value or values in $(D_INLINECODE params) to the texture parameter specified as $(D_INLINECODE pname). For $(D_INLINECODE glTexParameter), $(D_INLINECODE target) defines the target texture, either $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), or $(D_INLINECODE GL_TEXTURE_RECTANGLE). The following symbols are accepted in $(D_INLINECODE pname) :
     + 
     + Suppose that a program attempts to sample from a texture and has set $(D_INLINECODE GL_TEXTURE_MIN_FILTER) to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glCopyTexImage1D), or $(D_INLINECODE glCopyTexImage2D) ) do not follow the proper sequence for mipmaps (described above), or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then the texture is considered. Linear filtering accesses the four nearest texture elements only in 2D textures. In 1D textures, linear filtering accesses the two nearest texture elements. In 3D textures, linear filtering accesses the eight nearest texture elements. $(D_INLINECODE glTexParameter) specifies the texture parameters for the active texture unit, specified by calling $(D_INLINECODE glActiveTexture). $(D_INLINECODE glTextureParameter) specifies the texture parameters for the texture object with ID $(D_INLINECODE texture). $(D_INLINECODE GL_DEPTH_STENCIL_TEXTURE_MODE) is available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MIRROR_CLAMP_TO_EDGE) is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glTexParameter) functions. Must be one of $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), or $(D_INLINECODE GL_TEXTURE_RECTANGLE).
     +     texture = Specifies the texture object name for $(D_INLINECODE glTextureParameter) functions.
     +     pname   = Specifies the symbolic name of a single-valued texture parameter. $(D_INLINECODE pname) can be one of the following: $(D_INLINECODE GL_DEPTH_STENCIL_TEXTURE_MODE), $(D_INLINECODE GL_TEXTURE_BASE_LEVEL), $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC), $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), $(D_INLINECODE GL_TEXTURE_LOD_BIAS), $(D_INLINECODE GL_TEXTURE_MIN_FILTER), $(D_INLINECODE GL_TEXTURE_MAG_FILTER), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LEVEL), $(D_INLINECODE GL_TEXTURE_SWIZZLE_R), $(D_INLINECODE GL_TEXTURE_SWIZZLE_G), $(D_INLINECODE GL_TEXTURE_SWIZZLE_B), $(D_INLINECODE GL_TEXTURE_SWIZZLE_A), $(D_INLINECODE GL_TEXTURE_WRAP_S), $(D_INLINECODE GL_TEXTURE_WRAP_T), or $(D_INLINECODE GL_TEXTURE_WRAP_R). For the vector commands ( $(D_INLINECODE glTexParameter*v) ), $(D_INLINECODE pname) can also be one of $(D_INLINECODE GL_TEXTURE_BORDER_COLOR) or $(D_INLINECODE GL_TEXTURE_SWIZZLE_RGBA).
     +     param   = For the scalar commands, specifies the value of $(D_INLINECODE pname).
     +     params  = For the vector commands, specifies a pointer to an array where the value or values of $(D_INLINECODE pname) are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glSamplerParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexParameterf(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexParameteri(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;

    /++
     + glTexStorage1D: man4/glTexStorage1D.xml
     + 
     + $(D_INLINECODE glTexStorage1D) and $(D_INLINECODE glTextureStorage1D) specify the storage requirements for all levels of a one-dimensional texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. Calling $(D_INLINECODE glTexStorage1D) is equivalent, assuming no errors are generated, to executing the following pseudo-code:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage1D(target, i, internalformat, width, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     + }
     + ---
     +  Calling $(D_INLINECODE glTextureStorage1D) is equivalent to the above pseudo-code, where $(D_INLINECODE target) is the effective target of $(D_INLINECODE texture) and it is as if $(D_INLINECODE texture) were bound to $(D_INLINECODE target) for the purposes of $(D_INLINECODE glTexImage1D). Since no texture data is actually provided, the values used in the pseudo-code for $(D_INLINECODE format) and $(D_INLINECODE type) are irrelevant and may be considered to be any values that are legal for the chosen $(D_INLINECODE internalformat) enumerant. $(D_INLINECODE internalformat) must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats $(D_INLINECODE GL_DEPTH_COMPONENT32F), $(D_INLINECODE GL_DEPTH_COMPONENT24), or $(D_INLINECODE GL_DEPTH_COMPONENT16), one of the combined depth-stencil formats, $(D_INLINECODE GL_DEPTH32F_STENCIL8), or $(D_INLINECODE GL_DEPTH24_STENCIL8), or the stencil-only format, $(D_INLINECODE GL_STENCIL_INDEX8). Upon success, the value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) becomes $(D_INLINECODE GL_TRUE). The value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) may be discovered by calling $(D_INLINECODE glGetTexParameter) with $(D_INLINECODE pname) set to $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT). No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as $(D_INLINECODE glTexImage1D) or another call to $(D_INLINECODE glTexStorage1D) ) will result in the generation of a $(D_INLINECODE GL_INVALID_OPERATION) error, even if it would not, in fact, alter the dimensions or format of the object.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage1D). Must be one of $(D_INLINECODE GL_TEXTURE_1D) or $(D_INLINECODE GL_PROXY_TEXTURE_1D).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureStorage1D). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     levels         = Specify the number of texture levels.
     +     internalformat = Specifies the sized internal format to be used to store texture image data.
     +     width          = Specifies the width of the texture, in texels.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;

    /++
     + glTexStorage2D: man4/glTexStorage2D.xml
     + 
     + $(D_INLINECODE glTexStorage2D) and $(D_INLINECODE glTextureStorage2D) specify the storage requirements for all levels of a two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. The behavior of $(D_INLINECODE glTexStorage2D) depends on the $(D_INLINECODE target) parameter. When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE) or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), calling $(D_INLINECODE glTexStorage2D) is equivalent, assuming no errors are generated, to executing the following pseudo-code:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     +     height = max(1, (height / 2));
     + }
     + ---
     +  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE glTexStorage2D) is equivalent to:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     for (face in (+X, -X, +Y, -Y, +Z, -Z)) {
     +         glTexImage2D(face, i, internalformat, width, height, 0, format, type, NULL);
     +     }
     +     width = max(1, (width / 2));
     +     height = max(1, (height / 2));
     + }
     + ---
     +  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D) or $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE glTexStorage2D) is equivalent to:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     + }
     + ---
     +  Calling $(D_INLINECODE glTextureStorage2D) is equivalent to the above pseudo-code, where $(D_INLINECODE target) is the effective target of $(D_INLINECODE texture) and it is as if $(D_INLINECODE texture) were bound to $(D_INLINECODE target) for the purposes of $(D_INLINECODE glTexImage2D). Since no texture data is actually provided, the values used in the pseudo-code for $(D_INLINECODE format) and $(D_INLINECODE type) are irrelevant and may be considered to be any values that are legal for the chosen $(D_INLINECODE internalformat) enumerant. $(D_INLINECODE internalformat) must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats $(D_INLINECODE GL_DEPTH_COMPONENT32F), $(D_INLINECODE GL_DEPTH_COMPONENT24), or $(D_INLINECODE GL_DEPTH_COMPONENT16), one of the combined depth-stencil formats, $(D_INLINECODE GL_DEPTH32F_STENCIL8), or $(D_INLINECODE GL_DEPTH24_STENCIL8), or the stencil-only format, $(D_INLINECODE GL_STENCIL_INDEX8). Upon success, the value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) becomes $(D_INLINECODE GL_TRUE). The value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) may be discovered by calling $(D_INLINECODE glGetTexParameter) with $(D_INLINECODE pname) set to $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT). No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as $(D_INLINECODE glTexImage2D) or another call to $(D_INLINECODE glTexStorage2D) ) will result in the generation of a $(D_INLINECODE GL_INVALID_OPERATION) error, even if it would not, in fact, alter the dimensions or format of the object.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage2D). Must be one of $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureStorage2D). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     levels         = Specify the number of texture levels.
     +     internalformat = Specifies the sized internal format to be used to store texture image data.
     +     width          = Specifies the width of the texture, in texels.
     +     height         = Specifies the height of the texture, in texels.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage3D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glTexStorage2DMultisample: man4/glTexStorage2DMultisample.xml
     + 
     + $(D_INLINECODE glTexStorage2DMultisample) and $(D_INLINECODE glTextureStorage2DMultisample) specify the storage requirements for a two-dimensional multisample texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. $(D_INLINECODE samples) specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of $(D_INLINECODE GL_MAX_SAMPLES). $(D_INLINECODE internalformat) must be a color-renderable, depth-renderable, or stencil-renderable format. $(D_INLINECODE width) and $(D_INLINECODE height) specify the width and height, respectively, of the texture. If $(D_INLINECODE fixedsamplelocations) is $(D_INLINECODE GL_TRUE), the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + Params:
     +     target               = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage2DMultisample). Must be one of $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE).
     +     texture              = Specifies the texture object name for $(D_INLINECODE glTextureStorage2DMultisample). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     samples              = Specify the number of samples in the texture.
     +     internalformat       = Specifies the sized internal format to be used to store texture image data.
     +     width                = Specifies the width of the texture, in texels.
     +     height               = Specifies the height of the texture, in texels.
     +     fixedsamplelocations = Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage3D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_storage_multisample")
    void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;

    /++
     + glTexStorage3D: man4/glTexStorage3D.xml
     + 
     + $(D_INLINECODE glTexStorage3D) and $(D_INLINECODE glTextureStorage3D) specify specify the storage requirements for all levels of a three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. The behavior of $(D_INLINECODE glTexStorage3D) depends on the $(D_INLINECODE target) parameter. When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_3D), or $(D_INLINECODE GL_PROXY_TEXTURE_3D), calling $(D_INLINECODE glTexStorage3D) is equivalent, assuming no errors are generated, to executing the following pseudo-code:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     +     height = max(1, (height / 2));
     +     depth = max(1, (depth / 2));
     + }
     + ---
     +  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE glTexStorage3D) is equivalent to:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     +     height = max(1, (height / 2));
     + }
     + ---
     +  Calling $(D_INLINECODE glTextureStorage3D) is equivalent to the above pseudo-code, where $(D_INLINECODE target) is the effective target of $(D_INLINECODE texture) and it is as if $(D_INLINECODE texture) were bound to $(D_INLINECODE target) for the purposes of $(D_INLINECODE glTexImage3D). Since no texture data is actually provided, the values used in the pseudo-code for $(D_INLINECODE format) and $(D_INLINECODE type) are irrelevant and may be considered to be any values that are legal for the chosen $(D_INLINECODE internalformat) enumerant. $(D_INLINECODE internalformat) must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats $(D_INLINECODE GL_DEPTH_COMPONENT32F), $(D_INLINECODE GL_DEPTH_COMPONENT24), or $(D_INLINECODE GL_DEPTH_COMPONENT16), one of the combined depth-stencil formats, $(D_INLINECODE GL_DEPTH32F_STENCIL8), or $(D_INLINECODE GL_DEPTH24_STENCIL8), or the stencil-only format, $(D_INLINECODE GL_STENCIL_INDEX8). Upon success, the value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) becomes $(D_INLINECODE GL_TRUE). The value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) may be discovered by calling $(D_INLINECODE glGetTexParameter) with $(D_INLINECODE pname) set to $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT). No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as $(D_INLINECODE glTexImage3D) or another call to $(D_INLINECODE glTexStorage3D) ) will result in the generation of a $(D_INLINECODE GL_INVALID_OPERATION) error, even if it would not, in fact, alter the dimensions or format of the object.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage3D). Must be one of $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_ARRAY).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureStorage3D). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     levels         = Specify the number of texture levels.
     +     internalformat = Specifies the sized internal format to be used to store texture image data.
     +     width          = Specifies the width of the texture, in texels.
     +     height         = Specifies the height of the texture, in texels.
     +     depth          = Specifies the depth of the texture, in texels.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;

    /++
     + glTexStorage3DMultisample: man4/glTexStorage3DMultisample.xml
     + 
     + $(D_INLINECODE glTexStorage3DMultisample) and $(D_INLINECODE glTextureStorage3DMultisample) specify the storage requirements for a two-dimensional multisample array texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. $(D_INLINECODE samples) specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of $(D_INLINECODE GL_MAX_SAMPLES). $(D_INLINECODE internalformat) must be a color-renderable, depth-renderable, or stencil-renderable format. $(D_INLINECODE width) and $(D_INLINECODE height) specify the width and height, respectively, of the texture and $(D_INLINECODE depth) specifies the depth (or the number of layers) of the texture. If $(D_INLINECODE fixedsamplelocations) is $(D_INLINECODE GL_TRUE), the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + Params:
     +     target               = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage3DMultisample). Must be one of $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY).
     +     texture              = Specifies the texture object name for $(D_INLINECODE glTextureStorage3DMultisample). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     samples              = Specify the number of samples in the texture.
     +     internalformat       = Specifies the sized internal format to be used to store texture image data.
     +     width                = Specifies the width of the texture, in texels.
     +     height               = Specifies the height of the texture, in texels.
     +     depth                = Specifies the depth of the texture, in layers.
     +     fixedsamplelocations = Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2DMultisample), $(D_INLINECODE glTexStorage3D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_storage_multisample")
    void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;

    /++
     + glTexSubImage1D: man4/glTexSubImage1D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable or disable one-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_1D). $(D_INLINECODE glTexSubImage1D) and $(D_INLINECODE glTextureSubImage1D) redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by $(D_INLINECODE pixels) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images. $(D_INLINECODE glTexSubImage1D) and $(D_INLINECODE glTextureSubImage1D) specify a one-dimensional subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) is accepted for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glTexSubImage1D). Must be $(D_INLINECODE GL_TEXTURE_1D).
     +     texture = Specifies the texture object name for $(D_INLINECODE glTextureSubImage1D). The effective target of $(D_INLINECODE texture) must be one of the valid $(D_INLINECODE target) values above.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     width   = Specifies the width of the texture subimage.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_DEPTH_COMPONENT), and $(D_INLINECODE GL_STENCIL_INDEX).
     +     type    = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     pixels  = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;

    /++
     + glTexSubImage2D: man4/glTexSubImage2D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. $(D_INLINECODE glTexSubImage2D) and $(D_INLINECODE glTextureSubImage2D) redefine a contiguous subregion of an existing two-dimensional or one-dimensional array texture image. The texels referenced by $(D_INLINECODE pixels) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images. $(D_INLINECODE glTexSubImage2D) and $(D_INLINECODE glTextureSubImage3D) specify a two-dimensional subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) is accepted for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glTexSubImage2D). Must be $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_TEXTURE_1D_ARRAY).
     +     texture = Specifies the texture object name for $(D_INLINECODE glTextureSubImage2D). The effective target of $(D_INLINECODE texture) must be one of the valid $(D_INLINECODE target) values above.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_DEPTH_COMPONENT), and $(D_INLINECODE GL_STENCIL_INDEX).
     +     type    = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     pixels  = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;

    /++
     + glTexSubImage3D: man4/glTexSubImage3D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. $(D_INLINECODE glTexSubImage3D) and $(D_INLINECODE glTextureSubImage3D) redefine a contiguous subregion of an existing three-dimensional or two-dimensioanl array texture image. The texels referenced by $(D_INLINECODE pixels) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive, y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive, and z indices $(D_INLINECODE zoffset) and zoffset + depth - 1, inclusive. For three-dimensional textures, the z index refers to the third dimension. For two-dimensional array textures, the z index refers to the slice index. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width, height, or depth but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store.
     + 
     + The $(D_INLINECODE glPixelStore) modes affect texture images. $(D_INLINECODE glTexSubImage3D) and $(D_INLINECODE glTextureSubImage3D) specify a three-dimensional or two-dimensional array subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) is accepted for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glTexSubImage3D). Must be $(D_INLINECODE GL_TEXTURE_3D) or $(D_INLINECODE GL_TEXTURE_2D_ARRAY).
     +     texture = Specifies the texture object name for $(D_INLINECODE glTextureSubImage3D). The effective target of $(D_INLINECODE texture) must be one of the valid $(D_INLINECODE target) values above.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     zoffset = Specifies a texel offset in the z direction within the texture array.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     +     depth   = Specifies the depth of the texture subimage.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_DEPTH_COMPONENT), and $(D_INLINECODE GL_STENCIL_INDEX).
     +     type    = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     pixels  = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;

    /++
     + glTextureBarrier: man4/glTextureBarrier.xml
     + 
     + The values of rendered fragments are undefined when a shader stage fetches texels and the same texels are written via fragment shader outputs, even if the reads and writes are not in the same drawing command. To safely read the result of a written texel via a texel fetch in a subsequent drawing command, call $(D_INLINECODE glTextureBarrier) between the two drawing commands to guarantee that writes have completed and caches have been invalidated before subsequent drawing commands are executed.
     + 
     + The situation described above is referred to as a and is discussed in more detail in section 9.3 of the OpenGL 4.5 Specification.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMemoryBarrier)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_texture_barrier")
    void glTextureBarrier() @system @nogc nothrow;

    /++
     + glTextureView: man4/glTextureView.xml
     + 
     + $(D_INLINECODE glTextureView) initializes a texture object as an alias, or view of another texture object, sharing some or all of the parent texture's data store with the initialized texture. $(D_INLINECODE texture) specifies a name previously reserved by a successful call to $(D_INLINECODE glGenTextures) but that has not yet been bound or given a target. $(D_INLINECODE target) specifies the target for the newly initialized texture and must be compatible with the target of the parent texture, given in $(D_INLINECODE origtexture) as specified in the following table: Original Target Compatible New Targets $(D_INLINECODE GL_TEXTURE_1D) $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY) $(D_INLINECODE GL_TEXTURE_2D) $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY) $(D_INLINECODE GL_TEXTURE_3D) $(D_INLINECODE GL_TEXTURE_3D) $(D_INLINECODE GL_TEXTURE_CUBE_MAP) $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTUER_CUBE_MAP_ARRAY) $(D_INLINECODE GL_TEXTURE_RECTANGLE) $(D_INLINECODE GL_TEXTURE_RECTANGLE) $(D_INLINECODE GL_TEXTURE_BUFFER) $(D_INLINECODE GL_TEXTURE_1D_ARRAY) $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY) $(D_INLINECODE GL_TEXTURE_2D_ARRAY) $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY) $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTUER_CUBE_MAP_ARRAY) $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_MULTISAMPLE_ARRAY) $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_MULTISAMPLE_ARRAY) The value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) for $(D_INLINECODE origtexture) must be $(D_INLINECODE GL_TRUE). After initialization, $(D_INLINECODE texture) inherits the data store of the parent texture, $(D_INLINECODE origtexture) and is usable as a normal texture object with target $(D_INLINECODE target). Data in the shared store is reinterpreted with the new internal format specified by $(D_INLINECODE internalformat). $(D_INLINECODE internalformat) must be compatible with the internal format of the parent texture as specified in the following table: Class Internal Formats 128-bit $(D_INLINECODE GL_RGBA32F), $(D_INLINECODE GL_RGBA32UI), $(D_INLINECODE GL_RGBA32I) 96-bit $(D_INLINECODE GL_RGB32F), $(D_INLINECODE GL_RGB32UI), $(D_INLINECODE GL_RGB32I) 64-bit $(D_INLINECODE GL_RGBA16F), $(D_INLINECODE GL_RG32F), $(D_INLINECODE GL_RGBA16UI), $(D_INLINECODE GL_RG32UI), $(D_INLINECODE GL_RGBA16I), $(D_INLINECODE GL_RG32I), $(D_INLINECODE GL_RGBA16), $(D_INLINECODE GL_RGBA16_SNORM) 48-bit $(D_INLINECODE GL_RGB16), $(D_INLINECODE GL_RGB16_SNORM), $(D_INLINECODE GL_RGB16F), $(D_INLINECODE GL_RGB16UI), $(D_INLINECODE GL_RGB16I) 32-bit $(D_INLINECODE GL_RG16F), $(D_INLINECODE GL_R11F_G11F_B10F), $(D_INLINECODE GL_R32F), $(D_INLINECODE GL_RGB10_A2UI), $(D_INLINECODE GL_RGBA8UI), $(D_INLINECODE GL_RG16UI), $(D_INLINECODE GL_R32UI), $(D_INLINECODE GL_RGBA8I), $(D_INLINECODE GL_RG16I), $(D_INLINECODE GL_R32I), $(D_INLINECODE GL_RGB10_A2), $(D_INLINECODE GL_RGBA8), $(D_INLINECODE GL_RG16), $(D_INLINECODE GL_RGBA8_SNORM), $(D_INLINECODE GL_RG16_SNORM), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_RGB9_E5) 24-bit $(D_INLINECODE GL_RGB8), $(D_INLINECODE GL_RGB8_SNORM), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_RGB8UI), $(D_INLINECODE GL_RGB8I) 16-bit $(D_INLINECODE GL_R16F), $(D_INLINECODE GL_RG8UI), $(D_INLINECODE GL_R16UI), $(D_INLINECODE GL_RG8I), $(D_INLINECODE GL_R16I), $(D_INLINECODE GL_RG8), $(D_INLINECODE GL_R16), $(D_INLINECODE GL_RG8_SNORM), $(D_INLINECODE GL_R16_SNORM) 8-bit $(D_INLINECODE GL_R8UI), $(D_INLINECODE GL_R8I), $(D_INLINECODE GL_R8), $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RGTC1_RED) $(D_INLINECODE GL_COMPRESSED_RED_RGTC1), $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1) $(D_INLINECODE GL_RGTC2_RG) $(D_INLINECODE GL_COMPRESSED_RG_RGTC2), $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2) $(D_INLINECODE GL_BPTC_UNORM) $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) $(D_INLINECODE GL_BPTC_FLOAT) $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT), $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) If the original texture is an array or has multiple mipmap levels, the parameters $(D_INLINECODE minlayer), $(D_INLINECODE numlayers), $(D_INLINECODE minlevel), and $(D_INLINECODE numlevels) control which of those slices and levels are considered part of the texture. The $(D_INLINECODE minlevel) and $(D_INLINECODE minlayer) parameters are relative to the view of the original texture. If $(D_INLINECODE numlayers) or $(D_INLINECODE numlevels) extend beyond the original texture, they are clamped to the max extent of the original texture. If the new texture's target is $(D_INLINECODE GL_TEXTURE_CUBE_MAP), the clamped $(D_INLINECODE numlayers) must be equal to 6. If the new texture's target is $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), then $(D_INLINECODE numlayers) counts layer-faces rather than layers, and the clamped $(D_INLINECODE numlayers) must be a multiple of 6. If the new texture's target is $(D_INLINECODE GL_TEXTURE_CUBE_MAP) or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), the width and height of the original texture's levels must be equal. When the original texture's target is $(D_INLINECODE GL_TEXTURE_CUBE_MAP), the layer parameters are interpreted in the same order as if it were a $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) with 6 layer-faces. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_RECTANGLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE numlayers) must equal 1. The dimensions of the original texture must be less than or equal to the maximum supported dimensions of the new target. For example, if the original texture has a $(D_INLINECODE GL_TEXTURE_2D_ARRAY) target and its width is greater than $(D_INLINECODE GL_MAX_CUBE_MAP_TEXTURE_SIZE), an error will be generated if $(D_INLINECODE glTextureView) is called to create a $(D_INLINECODE GL_TEXTURE_CUBE_MAP) view. Texture commands that take a $(D_INLINECODE level) or $(D_INLINECODE layer) parameter, such as $(D_INLINECODE glTexSubImage2D), interpret that parameter to be relative to the view of the texture. i.e. the mipmap level of the data store that would be updated via $(D_INLINECODE glTexSubImage2D) would be the sum of $(D_INLINECODE level) and the value of $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LEVEL).
     + 
     + Params:
     +     texture        = Specifies the texture object to be initialized as a view.
     +     target         = Specifies the target to be used for the newly initialized texture.
     +     origtexture    = Specifies the name of a texture object of which to make a view.
     +     internalFormat = Specifies the internal format for the newly created view.
     +     minlevel       = Specifies lowest level of detail of the view.
     +     numlevels      = Specifies the number of levels of detail to include in the view.
     +     minlayer       = Specifies the index of the first layer to include in the view.
     +     numlayers      = Specifies the number of layers to include in the view.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glGetTexParameter).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_view")
    void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;

    /++
     + glTransformFeedbackBufferBase: man4/glTransformFeedbackBufferBase.xml
     + 
     + $(D_INLINECODE glTransformFeedbackBufferBase) binds the buffer object $(D_INLINECODE buffer) to the binding point at index $(D_INLINECODE index) of the transform feedback object $(D_INLINECODE xfb).
     + 
     + Calling $(D_INLINECODE glTransformFeedbackBufferBase) is equivalent to calling $(D_INLINECODE glTransformFeedbackBufferRange) with $(D_INLINECODE offset) zero and $(D_INLINECODE size) equal to the size of $(D_INLINECODE buffer).
     + 
     + Params:
     +     xfb    = Name of the transform feedback buffer object.
     +     index  = Index of the binding point within $(D_INLINECODE xfb).
     +     buffer = Name of the buffer object to bind to the specified binding point.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glTransformFeedbackBufferRange).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer) @system @nogc nothrow;

    /++
     + glTransformFeedbackBufferRange: man4/glTransformFeedbackBufferRange.xml
     + 
     + $(D_INLINECODE glTransformFeedbackBufferRange) binds a range of the buffer object $(D_INLINECODE buffer) represented by $(D_INLINECODE offset) and $(D_INLINECODE size) to the binding point at index $(D_INLINECODE index) of the transform feedback object $(D_INLINECODE xfb). $(D_INLINECODE offset) specifies the offset in basic machine units into the buffer object $(D_INLINECODE buffer) and $(D_INLINECODE size) specifies the amount of data that can be read from the buffer object while used as an indexed target.
     + 
     + Params:
     +     xfb    = Name of the transform feedback buffer object.
     +     index  = Index of the binding point within $(D_INLINECODE xfb).
     +     buffer = Name of the buffer object to bind to the specified binding point.
     +     offset = The starting offset in basic machine units into the buffer object.
     +     size   = The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glTransformFeedbackBufferBase).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size) @system @nogc nothrow;

    /++
     + glTransformFeedbackVaryings: man4/glTransformFeedbackVaryings.xml
     + 
     + The names of the vertex or geometry shader outputs to be recorded in transform feedback mode are specified using $(D_INLINECODE glTransformFeedbackVaryings). When a geometry shader is active, transform feedback records the values of selected geometry shader output variables from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are recorded. The state set by $(D_INLINECODE glTranformFeedbackVaryings) is stored and takes effect next time $(D_INLINECODE glLinkProgram) is called on $(D_INLINECODE program). When $(D_INLINECODE glLinkProgram) is called, $(D_INLINECODE program) is linked so that the values of the specified varying variables for the vertices of each primitive generated by the GL are written to a single buffer object if $(D_INLINECODE bufferMode) is $(D_INLINECODE GL_INTERLEAVED_ATTRIBS) or multiple buffer objects if $(D_INLINECODE bufferMode) is $(D_INLINECODE GL_SEPARATE_ATTRIBS). In addition to the errors generated by $(D_INLINECODE glTransformFeedbackVaryings), the program $(D_INLINECODE program) will fail to link if: $(OL $(LI The count specified by $(D_INLINECODE glTransformFeedbackVaryings) is non-zero, but the program object has no vertex or geometry shader.) $(LI Any variable name specified in the $(D_INLINECODE varyings) array is not declared as an output in the vertex shader (or the geometry shader, if active).) $(LI Any two entries in the $(D_INLINECODE varyings) array specify the same varying variable.) $(LI The total number of components to capture in any varying variable in $(D_INLINECODE varyings) is greater than the constant $(D_INLINECODE GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS) and the buffer mode is $(D_INLINECODE GL_SEPARATE_ATTRIBS).) $(LI The total number of components to capture is greater than the constant $(D_INLINECODE GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS) and the buffer mode is $(D_INLINECODE GL_INTERLEAVED_ATTRIBS).))
     + 
     + $(D_INLINECODE glGetTransformFeedbackVarying) is available only if the GL version is 3.0 or greater.
     + 
     + Params:
     +     program    = The name of the target program object.
     +     count      = The number of varying variables used for transform feedback.
     +     varyings   = An array of $(D_INLINECODE count) zero-terminated strings specifying the names of the varying variables to use for transform feedback.
     +     bufferMode = Identifies the mode used to capture the varying variables when transform feedback is active. $(D_INLINECODE bufferMode) must be $(D_INLINECODE GL_INTERLEAVED_ATTRIBS) or $(D_INLINECODE GL_SEPARATE_ATTRIBS).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glGetTransformFeedbackVarying)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char** varyings, GLenum bufferMode) @system @nogc nothrow;

    /++
     + glUniform: man4/glUniform.xml
     + 
     + $(D_INLINECODE glUniform) modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by $(D_INLINECODE location), which should be a value returned by $(D_INLINECODE glGetUniformLocation). $(D_INLINECODE glUniform) operates on the program object that was made part of current state by calling $(D_INLINECODE glUseProgram). The commands $(D_INLINECODE glUniform{1|2|3|4}{f|i|ui}) are used to change the value of the uniform variable specified by $(D_INLINECODE location) using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for $(D_INLINECODE float), $(D_INLINECODE int), $(D_INLINECODE unsigned int), $(D_INLINECODE bool); $(D_INLINECODE 2) for $(D_INLINECODE vec2), $(D_INLINECODE ivec2), $(D_INLINECODE uvec2), $(D_INLINECODE bvec2), etc.). The suffix $(D_INLINECODE f) indicates that floating-point values are being passed; the suffix $(D_INLINECODE i) indicates that integer values are being passed; the suffix $(D_INLINECODE ui) indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The $(D_INLINECODE i) variants of this function should be used to provide values for uniform variables defined as $(D_INLINECODE int), $(D_INLINECODE ivec2), $(D_INLINECODE ivec3), $(D_INLINECODE ivec4), or arrays of these. The $(D_INLINECODE ui) variants of this function should be used to provide values for uniform variables defined as $(D_INLINECODE unsigned int), $(D_INLINECODE uvec2), $(D_INLINECODE uvec3), $(D_INLINECODE uvec4), or arrays of these. The $(D_INLINECODE f) variants should be used to provide values for uniform variables of type $(D_INLINECODE float), $(D_INLINECODE vec2), $(D_INLINECODE vec3), $(D_INLINECODE vec4), or arrays of these. Either the $(D_INLINECODE i), $(D_INLINECODE ui) or $(D_INLINECODE f) variants may be used to provide values for uniform variables of type $(D_INLINECODE bool), $(D_INLINECODE bvec2), $(D_INLINECODE bvec3), $(D_INLINECODE bvec4), or arrays of these. The uniform variable will be set to $(D_INLINECODE false) if the input value is 0 or 0.0f, and it will be set to $(D_INLINECODE true) otherwise. All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to $(D_INLINECODE glUniform) until the next successful link operation occurs on the program object, when they are once again initialized to 0. The commands $(D_INLINECODE glUniform{1|2|3|4}{f|i|ui}v) can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading elements starting at an arbitrary position in a uniform variable array, elements + - 1 in the array will be replaced with the new values. If $(D_INLINECODE m) + $(D_INLINECODE n) - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in $(D_INLINECODE value), and it should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for float, int, bool; $(D_INLINECODE 2) for vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for $(D_INLINECODE glUniform{1|2|3|4}{f|i|ui}). For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., $(D_INLINECODE glUniform3f) or $(D_INLINECODE glUniform3fv) can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by $(D_INLINECODE count) The commands $(D_INLINECODE glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv) are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number $(D_INLINECODE 2) indicates a 2 &#215; 2 matrix (i.e., 4 values), the number $(D_INLINECODE 3) indicates a 3 &#215; 3 matrix (i.e., 9 values), and the number $(D_INLINECODE 4) indicates a 4 &#215; 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows.  For example, $(D_INLINECODE 2x4) indicates a 2 &#215; 4 matrix with 2 columns and 4 rows (i.e., 8 values). If $(D_INLINECODE transpose) is $(D_INLINECODE GL_FALSE), each matrix is assumed to be supplied in column major order. If $(D_INLINECODE transpose) is $(D_INLINECODE GL_TRUE), each matrix is assumed to be supplied in row major order. The $(D_INLINECODE count) argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.
     + 
     + $(D_INLINECODE glUniform1i) and $(D_INLINECODE glUniform1iv) are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a $(D_INLINECODE GL_INVALID_OPERATION) error. If $(D_INLINECODE count) is greater than 1 and the indicated uniform variable is not an array, a $(D_INLINECODE GL_INVALID_OPERATION) error is generated and the specified uniform variable will remain unchanged. Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a $(D_INLINECODE GL_INVALID_OPERATION) error will be generated and the specified uniform variable will remain unchanged. If $(D_INLINECODE location) is a value other than -1 and it does not represent a valid uniform variable location in the current program object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object. If $(D_INLINECODE location) is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
     + 
     + Params:
     +     location       = Specifies the location of the uniform variable to be modified.
     +     count          = For the vector ( $(D_INLINECODE glUniform*v) ) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. For the matrix ( $(D_INLINECODE glUniformMatrix*) ) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
     +     transpose      = For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
     +     v0, v1, v2, v3 = For the scalar commands, specifies the new values to be used for the specified uniform variable.
     +     value          = For the vector and matrix commands, specifies a pointer to an array of $(D_INLINECODE count) values that will be used to update the specified uniform variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform1f(GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform2f(GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform1i(GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform2i(GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform1ui(GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform2ui(GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform1fv(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform2fv(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform3fv(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform4fv(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform1iv(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform2iv(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform3iv(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform4iv(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform1uiv(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform2uiv(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform3uiv(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform4uiv(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;

    /++
     + glUniformBlockBinding: man4/glUniformBlockBinding.xml
     + 
     + Binding points for active uniform blocks are assigned using $(D_INLINECODE glUniformBlockBinding). Each of a program's active uniform blocks has a corresponding uniform buffer binding point. $(D_INLINECODE program) is the name of a program object for which the command $(D_INLINECODE glLinkProgram) has been issued in the past. If successful, $(D_INLINECODE glUniformBlockBinding) specifies that $(D_INLINECODE program) will use the data store of the buffer object bound to the binding point $(D_INLINECODE uniformBlockBinding) to extract the values of the uniforms in the uniform block identified by $(D_INLINECODE uniformBlockIndex). When a program object is linked or re-linked, the uniform buffer object binding point assigned to each of its active uniform blocks is reset to zero.
     + 
     + $(D_INLINECODE glUniformBlockBinding) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     program             = The name of a program object containing the active uniform block whose binding to assign.
     +     uniformBlockIndex   = The index of the active uniform block within $(D_INLINECODE program) whose binding to assign.
     +     uniformBlockBinding = Specifies the binding point to which to bind the uniform block with index $(D_INLINECODE uniformBlockIndex) within $(D_INLINECODE program).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glGetActiveUniformBlock)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) @system @nogc nothrow;

    /++
     + glUniformSubroutines: man4/glUniformSubroutines.xml
     + 
     + $(D_INLINECODE glUniformSubroutines) loads all active subroutine uniforms for shader stage $(D_INLINECODE shadertype) of the current program with subroutine indices from $(D_INLINECODE indices), storing $(D_INLINECODE indices[i]) into the uniform at location $(D_INLINECODE i). $(D_INLINECODE count) must be equal to the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS) for the program currently in use at shader stage $(D_INLINECODE shadertype). Furthermore, all values in $(D_INLINECODE indices) must be less than the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINES) for the shader stage.
     + 
     + Params:
     +     shadertype = Specifies the shader stage from which to query for subroutine uniform index. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     count      = Specifies the number of uniform indices stored in $(D_INLINECODE indices).
     +     indices    = Specifies the address of an array holding the indices to load into the shader subroutine variables.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetProgramStage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint* indices) @system @nogc nothrow;

    /++
     + glUnmapBuffer: man4/glUnmapBuffer.xml
     + 
     + $(D_INLINECODE glUnmapBuffer) and $(D_INLINECODE glUnmapNamedBuffer) unmap (release) any mapping of a specified buffer object into the client's address space (see $(D_INLINECODE glMapBufferRange) and $(D_INLINECODE glMapBuffer) ). If a mapping is not unmapped before the corresponding buffer object's data store is used by the GL, an error will be generated by any GL command that attempts to dereference the buffer object's data store, unless the buffer was successfully mapped with $(D_INLINECODE GL_MAP_PERSISTENT_BIT) (see $(D_INLINECODE glMapBufferRange) ). When a data store is unmapped, the mapped pointer becomes invalid. $(D_INLINECODE glUnmapBuffer) returns $(D_INLINECODE GL_TRUE) unless the data store contents have become corrupt during the time the data store was mapped. This can occur for system-specific reasons that affect the availability of graphics memory, such as screen mode changes. In such situations, $(D_INLINECODE GL_FALSE) is returned and the data store contents are undefined. An application must detect this rare condition and reinitialize the data store. A buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store is recreated with $(D_INLINECODE glBufferData) ).
     + 
     + If an error is generated, $(D_INLINECODE glUnmapBuffer) returns $(D_INLINECODE GL_FALSE). The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is accepted only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glUnmapBuffer), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glUnmapNamedBuffer).
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBufferData), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glMapBufferRange)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    GLboolean glUnmapBuffer(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    GLboolean glUnmapNamedBuffer(GLuint buffer) @system @nogc nothrow;

    /++
     + glUseProgram: man4/glUseProgram.xml
     + 
     + $(D_INLINECODE glUseProgram) installs the program object specified by $(D_INLINECODE program) as part of current rendering state. One or more executables are created in a program object by successfully attaching shader objects to it with $(D_INLINECODE glAttachShader), successfully compiling the shader objects with $(D_INLINECODE glCompileShader), and successfully linking the program object with $(D_INLINECODE glLinkProgram). A program object will contain an executable that will run on the vertex processor if it contains one or more shader objects of type $(D_INLINECODE GL_VERTEX_SHADER) that have been successfully compiled and linked. A program object will contain an executable that will run on the geometry processor if it contains one or more shader objects of type $(D_INLINECODE GL_GEOMETRY_SHADER) that have been successfully compiled and linked. Similarly, a program object will contain an executable that will run on the fragment processor if it contains one or more shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER) that have been successfully compiled and linked. While a program object is in use, applications are free to modify attached shader objects, compile attached shader objects, attach additional shader objects, and detach or delete shader objects. None of these operations will affect the executables that are part of the current state. However, relinking the program object that is currently in use will install the program object as part of the current rendering state if the link operation was successful (see $(D_INLINECODE glLinkProgram) ). If the program object currently in use is relinked unsuccessfully, its link status will be set to $(D_INLINECODE GL_FALSE), but the executables and associated state will remain part of the current state until a subsequent call to $(D_INLINECODE glUseProgram) removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked. If $(D_INLINECODE program) is zero, then the current rendering state refers to an program object and the results of shader execution are undefined. However, this is not an error. If $(D_INLINECODE program) does not contain shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER), an executable will be installed on the vertex, and possibly geometry processors, but the results of fragment shader execution will be undefined.
     + 
     + Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
     + 
     + Params:
     +     program = Specifies the handle of the program object whose executables are to be used as part of current rendering state.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glValidateProgram), $(D_INLINECODE glVertexAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUseProgram(GLuint program) @system @nogc nothrow;

    /++
     + glUseProgramStages: man4/glUseProgramStages.xml
     + 
     + $(D_INLINECODE glUseProgramStages) binds executables from a program object associated with a specified set of shader stages to the program pipeline object given by $(D_INLINECODE pipeline). $(D_INLINECODE pipeline) specifies the program pipeline object to which to bind the executables. $(D_INLINECODE stages) contains a logical combination of bits indicating the shader stages to use within $(D_INLINECODE program) with the program pipeline object $(D_INLINECODE pipeline). $(D_INLINECODE stages) must be a logical combination of $(D_INLINECODE GL_VERTEX_SHADER_BIT), $(D_INLINECODE GL_TESS_CONTROL_SHADER_BIT), $(D_INLINECODE GL_TESS_EVALUATION_SHADER_BIT), $(D_INLINECODE GL_GEOMETRY_SHADER_BIT), $(D_INLINECODE GL_FRAGMENT_SHADER_BIT) and $(D_INLINECODE GL_COMPUTE_SHADER_BIT). Additionally, the special value $(D_INLINECODE GL_ALL_SHADER_BITS) may be specified to indicate that all executables contained in $(D_INLINECODE program) should be installed in $(D_INLINECODE pipeline). If $(D_INLINECODE program) refers to a program object with a valid shader attached for an indicated shader stage, $(D_INLINECODE glUseProgramStages) installs the executable code for that stage in the indicated program pipeline object $(D_INLINECODE pipeline). If $(D_INLINECODE program) is zero, or refers to a program object with no valid shader executable for a given stage, it is as if the pipeline object has no programmable stage configured for the indicated shader stages. If $(D_INLINECODE stages) contains bits other than those listed above, and is not equal to $(D_INLINECODE GL_ALL_SHADER_BITS), an error is generated.
     + 
     + The $(D_INLINECODE GL_COMPUTE_SHADER_BIT) bit is available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     pipeline = Specifies the program pipeline object to which to bind stages from $(D_INLINECODE program).
     +     stages   = Specifies a set of program stages to bind to the program pipeline object.
     +     program  = Specifies the program object containing the shader executables to use in $(D_INLINECODE pipeline).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glIsProgramPipeline)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program) @system @nogc nothrow;

    /++
     + glValidateProgram: man4/glValidateProgram.xml
     + 
     + $(D_INLINECODE glValidateProgram) checks to see whether the executables contained in $(D_INLINECODE program) can execute given the current OpenGL state. The information generated by the validation process will be stored in $(D_INLINECODE program) 's information log. The validation information may consist of an empty string, or it may be a string containing information about how the current program object interacts with the rest of current OpenGL state. This provides a way for OpenGL implementers to convey more information about why the current program is inefficient, suboptimal, failing to execute, and so on. The status of the validation operation will be stored as part of the program object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the validation succeeded, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_VALIDATE_STATUS). If validation is successful, $(D_INLINECODE program) is guaranteed to execute given the current state. Otherwise, $(D_INLINECODE program) is guaranteed to not execute. This function is typically useful only during application development. The informational string stored in the information log is completely implementation dependent; therefore, an application should not expect different OpenGL implementations to produce identical information strings.
     + 
     + This function mimics the validation operation that OpenGL implementations must perform when rendering commands are issued while programmable shaders are part of current state. The error $(D_INLINECODE GL_INVALID_OPERATION) will be generated by any command that triggers the rendering of geometry if: $(OL $(LI any two active samplers in the current program object are of different types, but refer to the same texture image unit,) $(LI the number of active samplers in the program exceeds the maximum number of texture image units allowed.)) It may be difficult or cause a performance degradation for applications to catch these errors when rendering commands are issued. Therefore, applications are advised to make calls to $(D_INLINECODE glValidateProgram) to detect these issues during application development.
     + 
     + Params:
     +     program = Specifies the handle of the program object to be validated.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glValidateProgram(GLuint program) @system @nogc nothrow;

    /++
     + glValidateProgramPipeline: man4/glValidateProgramPipeline.xml
     + 
     + $(D_INLINECODE glValidateProgramPipeline) instructs the implementation to validate the shader executables contained in $(D_INLINECODE pipeline) against the current GL state. The implementation may use this as an opportunity to perform any internal shader modifications that may be required to ensure correct operation of the installed shaders given the current GL state. After a program pipeline has been validated, its validation status is set to $(D_INLINECODE GL_TRUE). The validation status of a program pipeline object may be queried by calling $(D_INLINECODE glGetProgramPipeline) with parameter $(D_INLINECODE GL_VALIDATE_STATUS). If $(D_INLINECODE pipeline) is a name previously returned from a call to $(D_INLINECODE glGenProgramPipelines) but that has not yet been bound by a call to $(D_INLINECODE glBindProgramPipeline), a new program pipeline object is created with name $(D_INLINECODE pipeline) and the default state vector.
     + 
     + Params:
     +     pipeline = Specifies the name of a program pipeline object to validate.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glDeleteProgramPipelines)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glValidateProgramPipeline(GLuint pipeline) @system @nogc nothrow;

    /++
     + glVertexArrayAttribBinding: man4/glVertexAttribBinding.xml
     + 
     + $(D_INLINECODE glVertexAttribBinding) and $(D_INLINECODE glVertexArrayAttribBinding) establishes an association between the generic vertex attribute of a vertex array object whose index is given by $(D_INLINECODE attribindex), and a vertex buffer binding whose index is given by $(D_INLINECODE bindingindex). For $(D_INLINECODE glVertexAttribBinding), the vertex array object affected is that currently bound. For $(D_INLINECODE glVertexArrayAttribBinding), $(D_INLINECODE vaobj) is the name of the vertex array object. $(D_INLINECODE attribindex) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS) and $(D_INLINECODE bindingindex) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIB_BINDINGS).
     + 
     + Params:
     +     vaobj        = Specifies the name of the vertex array object for $(D_INLINECODE glVertexArrayAttribBinding).
     +     attribindex  = The index of the attribute to associate with a vertex buffer binding.
     +     bindingindex = The index of the vertex buffer binding with which to associate the generic vertex attribute.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexBuffer), $(D_INLINECODE glVertexAttribFormat), $(D_INLINECODE glVertexBindingDivisor), $(D_INLINECODE glVertexAttribPointer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;

    /++
     + glVertexArrayAttribFormat: man4/glVertexAttribFormat.xml
     + 
     + $(D_INLINECODE glVertexAttribFormat), $(D_INLINECODE glVertexAttribIFormat) and $(D_INLINECODE glVertexAttribLFormat), as well as $(D_INLINECODE glVertexArrayAttribFormat), $(D_INLINECODE glVertexArrayAttribIFormat) and $(D_INLINECODE glVertexArrayAttribLFormat) specify the organization of data in vertex arrays. The first three calls operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID $(D_INLINECODE vaobj). $(D_INLINECODE attribindex) specifies the index of the generic vertex attribute array whose data layout is being described, and must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS). $(D_INLINECODE size) determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3 or 4. $(D_INLINECODE type) indicates the type of the data. If $(D_INLINECODE type) is one of $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FIXED), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_HALF_FLOAT), and $(D_INLINECODE GL_DOUBLE) indicate types $(D_INLINECODE GLbyte), $(D_INLINECODE GLshort), $(D_INLINECODE GLint), $(D_INLINECODE GLfixed), $(D_INLINECODE GLfloat), $(D_INLINECODE GLhalf), and $(D_INLINECODE GLdouble), respectively; the values $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), and $(D_INLINECODE GL_UNSIGNED_INT) indicate types $(D_INLINECODE GLubyte), $(D_INLINECODE GLushort), and $(D_INLINECODE GLuint), respectively; the values $(D_INLINECODE GL_INT_2_10_10_10_REV) and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) indicating respectively four signed or unsigned elements packed into a single $(D_INLINECODE GLuint); and the value $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) indicating three floating point values packed into a single $(D_INLINECODE GLuint). $(D_INLINECODE glVertexAttribLFormat) and $(D_INLINECODE glVertexArrayAttribLFormat) is used to specify layout for data associated with a generic attribute variable declared as 64-bit double precision components. For $(D_INLINECODE glVertexAttribLFormat) and $(D_INLINECODE glVertexArrayAttribLFormat), $(D_INLINECODE type) must be $(D_INLINECODE GL_DOUBLE). In contrast to $(D_INLINECODE glVertexAttribFormat) or $(D_INLINECODE glVertexArrayAttribFormat), which will cause data declared as $(D_INLINECODE GL_DOUBLE) to be converted to 32-bit representation, $(D_INLINECODE glVertexAttribLFormat) and $(D_INLINECODE glVertexArrayAttribLFormat) cause such data to be left in its natural, 64-bit representation. For $(D_INLINECODE glVertexAttribFormat) and $(D_INLINECODE glVertexArrayAttribFormat), if $(D_INLINECODE normalized) is $(D_INLINECODE GL_TRUE), then integer data is normalized to the range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If $(D_INLINECODE normalized) is $(D_INLINECODE GL_FALSE) then integer data is directly converted to floating point. $(D_INLINECODE relativeoffset) is the offset, measured in basic machine units of the first element relative to the start of the vertex buffer binding this attribute fetches from. $(D_INLINECODE glVertexAttribFormat) and $(D_INLINECODE glVertexArrayAttribFormat) should be used to describe vertex attribute layout for floating-point vertex attributes, $(D_INLINECODE glVertexAttribIFormat) and $(D_INLINECODE glVertexArrayAttribIFormat) should be used to describe vertex attribute layout for integer vertex attribute, and $(D_INLINECODE glVertexAttribLFormat) and $(D_INLINECODE glVertexArrayAttribLFormat) should be used to describe the layout for 64-bit vertex attributes. Data for an array specified by $(D_INLINECODE glVertexAttribIFormat) and $(D_INLINECODE glVertexArrayAttribIFormat) will always be left as integer values; such data are referred to as pure integers.
     + 
     + $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) is accepted for $(D_INLINECODE type) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     vaobj          = Specifies the name of the vertex array object for $(D_INLINECODE glVertexArrayAttrib{I, L}Format) functions.
     +     attribindex    = The generic vertex attribute array being described.
     +     size           = The number of values per vertex that are stored in the array.
     +     type           = The type of the data stored in the array.
     +     normalized     = The distance between elements within the buffer.
     +     relativeoffset = The distance between elements within the buffer.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexBuffer), $(D_INLINECODE glVertexAttribBinding), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexBindingDivisor), $(D_INLINECODE glVertexAttribPointer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;

    /++
     + glVertexArrayBindingDivisor: man4/glVertexBindingDivisor.xml
     + 
     + $(D_INLINECODE glVertexBindingDivisor) and $(D_INLINECODE glVertexArrayBindingDivisor) modify the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw command. If $(D_INLINECODE divisor) is zero, the attributes using the buffer bound to $(D_INLINECODE bindingindex) advance once per vertex. If $(D_INLINECODE divisor) is non-zero, the attributes advance once per $(D_INLINECODE divisor) instances of the set(s) of vertices being rendered. An attribute is referred to as if the corresponding $(D_INLINECODE divisor) value is non-zero. $(D_INLINECODE glVertexBindingDivisor) uses currently bound vertex array object , whereas $(D_INLINECODE glVertexArrayBindingDivisor) updates state of the vertex array object with ID $(D_INLINECODE vaobj).
     + 
     + Params:
     +     vaobj        = Specifies the name of the vertex array object for $(D_INLINECODE glVertexArrayBindingDivisor) function.
     +     bindingindex = The index of the binding whose divisor to modify.
     +     divisor      = The new value for the instance step rate to apply.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexBuffer), $(D_INLINECODE glVertexAttribBinding), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexBindingDivisor), $(D_INLINECODE glVertexAttribPointer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor) @system @nogc nothrow;

    /++
     + glVertexArrayElementBuffer: man4/glVertexArrayElementBuffer.xml
     + 
     + $(D_INLINECODE glVertexArrayElementBuffer) binds a buffer object with id $(D_INLINECODE buffer) to the element array buffer bind point of a vertex array object with id $(D_INLINECODE vaobj). If $(D_INLINECODE buffer) is zero, any existing element array buffer binding to $(D_INLINECODE vaobj) is removed.
     + 
     + Params:
     +     vaobj  = Specifies the name of the vertex array object.
     +     buffer = Specifies the name of the buffer object to use for the element array buffer binding.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGet), $(D_INLINECODE glGetVertexArrayiv)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer) @system @nogc nothrow;

    /++
     + glVertexAttrib: man4/glVertexAttrib.xml
     + 
     + The $(D_INLINECODE glVertexAttrib) family of entry points allows an application to pass generic vertex attributes in numbered locations. Generic attributes are defined as four-component values that are organized into an array. The first entry of this array is numbered 0, and the size of the array is specified by the implementation-dependent constant $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS). Individual elements of this array can be modified with a $(D_INLINECODE glVertexAttrib) call that specifies the index of the element to be modified and a value for that element. These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified by $(D_INLINECODE index). A $(D_INLINECODE 1) in the name of the command indicates that only one value is passed, and it will be used to modify the first component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component will be set to 1. Similarly, a $(D_INLINECODE 2) in the name of the command indicates that values are provided for the first two components, the third component will be set to 0, and the fourth component will be set to 1. A $(D_INLINECODE 3) in the name of the command indicates that values are provided for the first three components and the fourth component will be set to 1, whereas a $(D_INLINECODE 4) in the name indicates that values are provided for all four components. The letters $(D_INLINECODE s), $(D_INLINECODE f), $(D_INLINECODE i), $(D_INLINECODE d), $(D_INLINECODE ub), $(D_INLINECODE us), and $(D_INLINECODE ui) indicate whether the arguments are of type short, float, int, double, unsigned byte, unsigned short, or unsigned int. When $(D_INLINECODE v) is appended to the name, the commands can take a pointer to an array of such values. Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function: The commands containing $(D_INLINECODE N) indicate that the arguments will be passed as fixed-point values that are scaled to a normalized range according to the component conversion rules defined by the OpenGL specification. Signed values are understood to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values in the range [0,1]. The commands containing $(D_INLINECODE I) indicate that the arguments are extended to full signed or unsigned integers. The commands containing $(D_INLINECODE P) indicate that the arguments are stored as packed components within a larger natural type. The commands containing $(D_INLINECODE L) indicate that the arguments are full 64-bit quantities and should be passed directly to shader inputs declared as 64-bit double precision types. OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may be loaded using the $(D_INLINECODE glVertexAttrib) entry points. Matrices must be loaded into successive generic attribute slots in column major order, with one column of the matrix in each generic attribute slot. A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling $(D_INLINECODE glBindAttribLocation). This allows an application to use more descriptive variable names in a vertex shader. A subsequent change to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable in the vertex shader. The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different program object is used. An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable. These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing, the vertex shader will repeatedly use the current value for the generic vertex attribute.
     + 
     + Generic vertex attributes can be updated at any time. It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location. OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing. There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes with standard attributes. $(D_INLINECODE glVertexAttribL) versions are available only if the GL version is 4.1 or higher. $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) is accepted for $(D_INLINECODE type) by $(D_INLINECODE glVertexAttribP*) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     index          = Specifies the index of the generic vertex attribute to be modified.
     +     v0, v1, v2, v3 = For the scalar commands, specifies the new values to be used for the specified vertex attribute.
     +     v              = For the vector commands ( $(D_INLINECODE glVertexAttrib*v) ), specifies a pointer to an array of values to be used for the generic vertex attribute.
     +     type           = For the packed commands ( $(D_INLINECODE glVertexAttribP*) ), specified the type of packing used on the data. This parameter must be $(D_INLINECODE GL_INT_2_10_10_10_REV) or $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), to specify signed or unsigned data, respectively, or $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) to specify floating point data.
     +     normalized     = For the packed commands, if $(D_INLINECODE GL_TRUE), then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If $(D_INLINECODE type) indicates a floating-pont format, then $(D_INLINECODE normalized) value must be $(D_INLINECODE GL_FALSE).
     +     value          = For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1f(GLuint index, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1s(GLuint index, GLshort v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1d(GLuint index, GLdouble v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI1i(GLuint index, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI1ui(GLuint index, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI2i(GLuint index, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL1d(GLuint index, GLdouble v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1fv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI1iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI1uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2fv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI2iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI2uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3fv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI3iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI3uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4fv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4bv(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4ubv(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4usv(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nbv(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nsv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Niv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nubv(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nusv(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nuiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4bv(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4ubv(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4usv(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL1dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL2dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL3dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL4dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;

    /++
     + glVertexAttribDivisor: man4/glVertexAttribDivisor.xml
     + 
     + $(D_INLINECODE glVertexAttribDivisor) modifies the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw call. If $(D_INLINECODE divisor) is zero, the attribute at slot $(D_INLINECODE index) advances once per vertex. If $(D_INLINECODE divisor) is non-zero, the attribute advances once per $(D_INLINECODE divisor) instances of the set(s) of vertices being rendered.  An attribute is referred to as instanced if its $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_DIVISOR) value is non-zero. $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS).
     + 
     + $(D_INLINECODE glVertexAttribDivisor) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     index   = Specify the index of the generic vertex attribute.
     +     divisor = Specify the number of instances that will pass between updates of the generic attribute at slot $(D_INLINECODE index).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glDisableVertexAttribArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    void glVertexAttribDivisor(GLuint index, GLuint divisor) @system @nogc nothrow;

    /++
     + glVertexAttribIPointer: man4/glVertexAttribPointer.xml
     + 
     + $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexAttribIPointer) and $(D_INLINECODE glVertexAttribLPointer) specify the location and data format of the array of generic vertex attributes at index $(D_INLINECODE index) to use when rendering. $(D_INLINECODE size) specifies the number of components per attribute and must be 1, 2, 3, 4, or $(D_INLINECODE GL_BGRA). $(D_INLINECODE type) specifies the data type of each component, and $(D_INLINECODE stride) specifies the byte stride from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. For $(D_INLINECODE glVertexAttribPointer), if $(D_INLINECODE normalized) is set to $(D_INLINECODE GL_TRUE), it indicates that values stored in an integer format are to be mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and converted to floating point. Otherwise, values will be converted to floats directly without normalization. For $(D_INLINECODE glVertexAttribIPointer), only the integer types $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_UNSIGNED_INT) are accepted. Values are always left as integer values. $(D_INLINECODE glVertexAttribLPointer) specifies state for a generic vertex attribute array associated with a shader attribute variable declared with 64-bit double precision components. $(D_INLINECODE type) must be $(D_INLINECODE GL_DOUBLE). $(D_INLINECODE index), $(D_INLINECODE size), and $(D_INLINECODE stride) behave as described for $(D_INLINECODE glVertexAttribPointer) and $(D_INLINECODE glVertexAttribIPointer). If $(D_INLINECODE pointer) is not $(D_INLINECODE null
     + ), a non-zero named buffer object must be bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ), otherwise an error is generated. $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. The buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as generic vertex attribute array state ( $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING) ) for index $(D_INLINECODE index). When a generic vertex attribute array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE normalized), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as vertex array state, in addition to the current vertex array buffer object binding. To enable and disable a generic vertex attribute array, call $(D_INLINECODE glEnableVertexAttribArray) and $(D_INLINECODE glDisableVertexAttribArray) with $(D_INLINECODE index). If enabled, the generic vertex attribute array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + Each generic vertex attribute array is initially disabled and isn't accessed when $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) is accepted for $(D_INLINECODE type) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     index      = Specifies the index of the generic vertex attribute to be modified.
     +     size       = Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant $(D_INLINECODE GL_BGRA) is accepted by $(D_INLINECODE glVertexAttribPointer). The initial value is 4.
     +     type       = Specifies the data type of each component in the array. The symbolic constants $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_INT), and $(D_INLINECODE GL_UNSIGNED_INT) are accepted by $(D_INLINECODE glVertexAttribPointer) and $(D_INLINECODE glVertexAttribIPointer). Additionally $(D_INLINECODE GL_HALF_FLOAT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_FIXED), $(D_INLINECODE GL_INT_2_10_10_10_REV), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) and $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) are accepted by $(D_INLINECODE glVertexAttribPointer). $(D_INLINECODE GL_DOUBLE) is also accepted by $(D_INLINECODE glVertexAttribLPointer) and is the only token accepted by the $(D_INLINECODE type) parameter for that function. The initial value is $(D_INLINECODE GL_FLOAT).
     +     normalized = For $(D_INLINECODE glVertexAttribPointer), specifies whether fixed-point data values should be normalized ( $(D_INLINECODE GL_TRUE) ) or converted directly as fixed-point values ( $(D_INLINECODE GL_FALSE) ) when they are accessed.
     +     stride     = Specifies the byte offset between consecutive generic vertex attributes. If $(D_INLINECODE stride) is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
     +     pointer    = Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target. The initial value is 0.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glVertexAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + glViewport: man4/glViewport.xml
     + 
     + $(D_INLINECODE glViewport) specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w y w are computed as follows: x w = x nd + 1 &it; width 2 + x y w = y nd + 1 &it; height 2 + y Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_VIEWPORT_DIMS).
     + 
     + Params:
     +     x     = Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
     +     width = Specify the width and height of the viewport. When a GL context is first attached to a window, $(D_INLINECODE width) and $(D_INLINECODE height) are set to the dimensions of that window.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glViewport(GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glViewportArray: man4/glViewportArray.xml
     + 
     + $(D_INLINECODE glViewportArrayv) specifies the parameters for multiple viewports simulataneously. $(D_INLINECODE first) specifies the index of the first viewport to modify and $(D_INLINECODE count) specifies the number of viewports to modify. $(D_INLINECODE first) must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS), and $(D_INLINECODE first) + $(D_INLINECODE count) must be less than or equal to the value of $(D_INLINECODE GL_MAX_VIEWPORTS). Viewports whose indices lie outside the range [ $(D_INLINECODE first), $(D_INLINECODE first) + $(D_INLINECODE count) ) are not modified. $(D_INLINECODE v) contains the address of an array of floating point values specifying the left ( x ), bottom ( y ), width ( w ), and height ( h ) of each viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h give the width and height of the viewport, respectively. The viewport specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w y w are computed as follows: x w = x nd + 1 &it; width 2 + x y w = y nd + 1 &it; height 2 + y The location of the viewport's bottom left corner, given by ( x, y ) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range [ min, max ] can be determined by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_VIEWPORT_BOUNDS_RANGE). Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_VIEWPORT_DIMS). The precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant $(D_INLINECODE GL_VIEWPORT_SUBPIXEL_BITS).
     + 
     + Params:
     +     first = Specify the first viewport to set.
     +     count = Specify the number of viewports to set.
     +     v     = Specify the address of an array containing the viewport parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange), $(D_INLINECODE glViewport), $(D_INLINECODE glViewportIndexed)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glViewportArrayv(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;

    /++
     + glViewportIndexed: man4/glViewportIndexed.xml
     + 
     + $(D_INLINECODE glViewportIndexedf) and $(D_INLINECODE glViewportIndexedfv) specify the parameters for a single viewport. $(D_INLINECODE index) specifies the index of the viewport to modify. $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS). For $(D_INLINECODE glViewportIndexedf), $(D_INLINECODE x), $(D_INLINECODE y), $(D_INLINECODE w), and $(D_INLINECODE h) specify the left, bottom, width and height of the viewport in pixels, respectively. For $(D_INLINECODE glViewportIndexedfv), $(D_INLINECODE v) contains the address of an array of floating point values specifying the left ( x ), bottom ( y ), width ( w ), and height ( h ) of each viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h give the width and height of the viewport, respectively. The viewport specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w y w are computed as follows: x w = x nd + 1 &it; width 2 + x y w = y nd + 1 &it; height 2 + y The location of the viewport's bottom left corner, given by ( x, y ) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range [ min, max ] can be determined by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_VIEWPORT_BOUNDS_RANGE). Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_VIEWPORT_DIMS). The precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant $(D_INLINECODE GL_VIEWPORT_SUBPIXEL_BITS). Calling $(D_INLINECODE glViewportIndexedfv) is equivalent to calling $(D_INLINECODE glViewportArray) with $(D_INLINECODE first) set to $(D_INLINECODE index), $(D_INLINECODE count) set to 1 and $(D_INLINECODE v) passsed directly. $(D_INLINECODE glViewportIndexedf) is equivalent to:
     + 
     + ---
     + void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
     +     const float v[4]  = { x, y, w, h };
     +     glViewportArrayv(index, 1, v);
     + }
     + ---
     + 
     + Params:
     +     index = Specify the first viewport to set.
     +     x     = For $(D_INLINECODE glViewportIndexedf), specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
     +     width = For $(D_INLINECODE glViewportIndexedf), specifies the width and height of the viewport. When a GL context is first attached to a window, $(D_INLINECODE width) and $(D_INLINECODE height) are set to the dimensions of that window.
     +     v     = For $(D_INLINECODE glViewportIndexedfv), specifies the address of an array containing the viewport parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange), $(D_INLINECODE glViewport), $(D_INLINECODE glViewportArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;

    /++
     + glWaitSync: man4/glWaitSync.xml
     + 
     + $(D_INLINECODE glWaitSync) causes the GL server to block and wait until $(D_INLINECODE sync) becomes signaled. $(D_INLINECODE sync) is the name of an existing sync object upon which to wait. $(D_INLINECODE flags) and $(D_INLINECODE timeout) are currently not used and must be set to zero and the special value $(D_INLINECODE GL_TIMEOUT_IGNORED), respectively $(D_INLINECODE flags) and $(D_INLINECODE timeout) are placeholders for anticipated future extensions of sync object capabilities. They must have these reserved values in order that existing code calling $(D_INLINECODE glWaitSync) operate properly in the presence of such extensions.. $(D_INLINECODE glWaitSync) will always wait no longer than an implementation-dependent timeout. The duration of this timeout in nanoseconds may be queried by calling $(D_INLINECODE glGet) with the parameter $(D_INLINECODE GL_MAX_SERVER_WAIT_TIMEOUT). There is currently no way to determine whether $(D_INLINECODE glWaitSync) unblocked because the timeout expired or because the sync object being waited on was signaled. If an error occurs, $(D_INLINECODE glWaitSync) does not cause the GL server to block.
     + 
     + $(D_INLINECODE glWaitSync) is available only if the GL version is 3.2 or higher.
     + 
     + Params:
     +     sync    = Specifies the sync object whose status to wait on.
     +     flags   = A bitfield controlling the command flushing behavior. $(D_INLINECODE flags) may be zero.
     +     timeout = Specifies the timeout that the server should wait before continuing. $(D_INLINECODE timeout) must be $(D_INLINECODE GL_TIMEOUT_IGNORED).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glClientWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;

    /++
     + : 
     + 
     + 
     + Params:
     + 
     + Copyright:
     +     
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glAccum(GLenum op, GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glAccumxOES(GLenum op, GLfixed value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glActiveProgramEXT(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glActiveShaderProgramEXT(GLuint pipeline, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_stencil_two_side")
    void glActiveStencilFaceEXT(GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glActiveTextureARB(GLenum texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glActiveVaryingNV(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glAlphaFunc(GLenum func, GLfloat ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_alpha_test")
    void glAlphaFuncQCOM(GLenum func, GLclampf ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glAlphaFuncx(GLenum func, GLfixed ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glAlphaFuncxOES(GLenum func, GLfixed ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_framebuffer_CMAA")
    void glApplyFramebufferAttachmentCMAAINTEL() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    void glApplyTextureEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    GLboolean glAreProgramsResidentNV(GLsizei n, const GLuint* programs, GLboolean* residences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    GLboolean glAreTexturesResident(GLsizei n, const GLuint* textures, GLboolean* residences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint* textures, GLboolean* residences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glArrayElement(GLint i) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glArrayElementEXT(GLint i) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    void glAsyncMarkerSGIX(GLuint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glBegin(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conditional_render")
    void glBeginConditionalRenderNV(GLuint id, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NVX_conditional_render")
    void glBeginConditionalRenderNVX(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glBeginFragmentShaderATI() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glBeginOcclusionQueryNV(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glBeginPerfMonitorAMD(GLuint monitor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glBeginPerfQueryINTEL(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glBeginQueryARB(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glBeginQueryEXT(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glBeginTransformFeedbackEXT(GLenum primitiveMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glBeginTransformFeedbackNV(GLenum primitiveMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glBeginVertexShaderEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glBeginVideoCaptureNV(GLuint video_capture_slot) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glBindBufferARB(GLenum target, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    void glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    void glBindFragDataLocationIndexedEXT(GLuint program, GLuint colorNumber, GLuint index, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glBindFragmentShaderATI(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glBindFramebufferEXT(GLenum target, GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glBindFramebufferOES(GLenum target, GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_image_load_store")
    void glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindLightParameterEXT(GLenum light, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindMaterialParameterEXT(GLenum face, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindParameterEXT(GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glBindProgramARB(GLenum target, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glBindProgramNV(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glBindProgramPipelineEXT(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glBindRenderbufferOES(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    void glBindTextureEXT(GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindTextureUnitParameterEXT(GLenum unit, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glBindTransformFeedbackNV(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    void glBindVertexArrayAPPLE(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    void glBindVertexArrayOES(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glBindVertexShaderEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3bvEXT(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3dvEXT(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3fvEXT(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3iEXT(GLint bx, GLint by, GLint bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3ivEXT(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3svEXT(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormalPointerEXT(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const(GLubyte)* bitmap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glBitmapxOES(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const(GLubyte)* bitmap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glBlendBarrier() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_blend_equation_advanced")
    void glBlendBarrierKHR() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_blend_equation_advanced")
    void glBlendBarrierNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_color")
    void glBlendColorEXT(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glBlendColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_minmax")
    void glBlendEquationEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    void glBlendEquationIndexedAMD(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_subtract")
    void glBlendEquationOES(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_equation_separate")
    void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    void glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_equation_separate")
    void glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    void glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glBlendEquationSeparateiEXT(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glBlendEquationSeparateiOES(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    void glBlendEquationiARB(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glBlendEquationiEXT(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glBlendEquationiOES(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    void glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_separate")
    void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INGR_blend_func_separate")
    void glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    void glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_func_separate")
    void glBlendFuncSeparateOES(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    void glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glBlendFuncSeparateiEXT(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glBlendFuncSeparateiOES(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    void glBlendFunciARB(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glBlendFunciEXT(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glBlendFunciOES(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_blend_equation_advanced")
    void glBlendParameteriNV(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_framebuffer_blit")
    void glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_blit")
    void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_blit")
    void glBlitFramebufferNV(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glBufferDataARB(GLenum target, GLsizeiptrARB size, const void* data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    void glBufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_flush_buffer_range")
    void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_buffer_storage")
    void glBufferStorageEXT(GLenum target, GLsizeiptr size, const void* data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCallCommandListNV(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glCallList(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glCallLists(GLsizei n, GLenum type, const void* lists) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    GLenum glCheckFramebufferStatusEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    GLenum glCheckFramebufferStatusOES(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    GLenum glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_color_buffer_float")
    void glClampColorARB(GLenum target, GLenum clamp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glClearAccumxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_integer")
    void glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_integer")
    void glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glClearColorx(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glClearColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    void glClearDepthdNV(GLdouble depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glClearDepthfOES(GLclampf depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glClearDepthx(GLfixed depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glClearDepthxOES(GLfixed depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearIndex(GLfloat c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    void glClearPixelLocalStorageuiEXT(GLsizei offset, GLsizei n, const GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_clear_texture")
    void glClearTexImageEXT(GLuint texture, GLint level, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_clear_texture")
    void glClearTexSubImageEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glClientActiveTexture(GLenum texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glClientActiveTextureARB(GLenum texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glClientActiveVertexStreamATI(GLenum stream) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glClientAttribDefaultEXT(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    GLenum glClientWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClipPlane(GLenum plane, const GLdouble* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glClipPlanef(GLenum p, const GLfloat* eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_user_clip_plane")
    void glClipPlanefIMG(GLenum p, const GLfloat* eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glClipPlanefOES(GLenum plane, const GLfloat* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glClipPlanex(GLenum plane, const GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_user_clip_plane")
    void glClipPlanexIMG(GLenum p, const GLfixed* eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glClipPlanexOES(GLenum plane, const GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3b(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3bv(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3d(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3f(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor3fVertex3fvSUN(const GLfloat* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glColor3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3i(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3s(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3ub(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3ubv(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3ui(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3uiv(const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3us(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3usv(const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glColor3xOES(GLfixed red, GLfixed green, GLfixed blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glColor3xvOES(const GLfixed* components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4bv(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4fNormal3fVertex3fvSUN(const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glColor4hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4i(GLint red, GLint green, GLint blue, GLint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4ubVertex2fvSUN(const(GLubyte)* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4ubVertex3fvSUN(const(GLubyte)* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4ubv(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4uiv(const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4usv(const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glColor4xOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glColor4xvOES(const GLfixed* components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glColorFormatNV(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers2")
    void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glColorMaskiEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glColorMaskiOES(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColorMaterial(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glColorP3ui(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glColorP3uiv(GLenum type, const GLuint* color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glColorP4ui(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glColorP4uiv(GLenum type, const GLuint* color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glColorPointer(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glColorPointerListIBM(GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    void glColorPointervINTEL(GLint size, GLenum type, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_color_subtable")
    void glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    void glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glColorTableParameteriv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerParameterfNV(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerParameterfvNV(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerParameteriNV(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerParameterivNV(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners2")
    void glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCommandListSegmentsNV(GLuint list, GLuint segments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCompileCommandListNV(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glCompileShaderARB(GLhandleARB shaderObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glCompileShaderIncludeARB(GLuint shader, GLsizei count, const(const(GLvoid*)*) path, const GLint* length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster_dilate")
    void glConservativeRasterParameterfNV(GLenum pname, GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster_pre_snap_triangles")
    void glConservativeRasterParameteriNV(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionParameteri(GLenum target, GLenum pname, GLint params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glConvolutionParameterxOES(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glConvolutionParameterxvOES(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_copy_buffer")
    void glCopyBufferSubDataNV(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_color_subtable")
    void glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_image")
    void glCopyImageSubDataEXT(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_copy_image")
    void glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_copy_image")
    void glCopyImageSubDataOES(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCopyPathNV(GLuint resultPath, GLuint srcPath) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_copy_texture_levels")
    void glCopyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCoverFillPathNV(GLuint path, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCoverStrokePathNV(GLuint path, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_coverage_sample")
    void glCoverageMaskNV(GLboolean mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    void glCoverageModulationNV(GLenum components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    void glCoverageModulationTableNV(GLsizei n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_coverage_sample")
    void glCoverageOperationNV(GLenum operation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCreateCommandListsNV(GLsizei n, GLuint* lists) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glCreatePerfQueryINTEL(GLuint queryId, GLuint* queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    GLhandleARB glCreateProgramObjectARB() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    GLhandleARB glCreateShaderObjectARB(GLenum shaderType) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    GLuint glCreateShaderProgramEXT(GLenum type, const GLchar* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    GLuint glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar** strings) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCreateStatesNV(GLsizei n, GLuint* states) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_cl_event")
    GLsync glCreateSyncFromCLeventARB(_cl_context* context, _cl_event* event, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_cull_vertex")
    void glCullParameterdvEXT(GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_cull_vertex")
    void glCullParameterfvEXT(GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glCurrentPaletteMatrixARB(GLint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    void glCurrentPaletteMatrixOES(GLuint matrixpaletteindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    void glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, void* userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    void glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const void* userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageCallbackKHR(GLDEBUGPROCKHR callback, const void* userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    void glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageControlKHR(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    void glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    void glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    void glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageInsertKHR(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    void glDeformSGIX(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    void glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    void glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    void glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glDeleteBuffersARB(GLsizei n, const GLuint* buffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDeleteCommandListsNV(GLsizei n, const GLuint* lists) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glDeleteFencesAPPLE(GLsizei n, const GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glDeleteFencesNV(GLsizei n, const GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glDeleteFragmentShaderATI(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glDeleteFramebuffersEXT(GLsizei n, const GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glDeleteFramebuffersOES(GLsizei n, const GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDeleteLists(GLuint list, GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glDeleteNamedStringARB(GLint namelen, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    void glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint* names) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glDeleteObjectARB(GLhandleARB obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glDeleteOcclusionQueriesNV(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glDeletePathsNV(GLuint path, GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glDeletePerfMonitorsAMD(GLsizei n, GLuint* monitors) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glDeletePerfQueryINTEL(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glDeleteProgramPipelinesEXT(GLsizei n, const GLuint* pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glDeleteProgramsARB(GLsizei n, const GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glDeleteProgramsNV(GLsizei n, const GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glDeleteQueriesARB(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glDeleteQueriesEXT(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glDeleteRenderbuffersEXT(GLsizei n, const GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glDeleteRenderbuffersOES(GLsizei n, const GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDeleteStatesNV(GLsizei n, const GLuint* states) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    void glDeleteSyncAPPLE(GLsync sync) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    void glDeleteTexturesEXT(GLsizei n, const GLuint* textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glDeleteTransformFeedbacksNV(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    void glDeleteVertexArraysOES(GLsizei n, const GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glDeleteVertexShaderEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_depth_bounds_test")
    void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    void glDepthBoundsdNV(GLdouble zmin, GLdouble zmax) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glDepthRangeArrayfvNV(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glDepthRangeArrayfvOES(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glDepthRangeIndexedfNV(GLuint index, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glDepthRangeIndexedfOES(GLuint index, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    void glDepthRangedNV(GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glDepthRangefOES(GLclampf n, GLclampf f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glDepthRangex(GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glDepthRangexOES(GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_detail_texture")
    void glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDisable(GLenum cap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glDisableClientState(GLenum array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableClientStateIndexedEXT(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableClientStateiEXT(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    void glDisableDriverControlQCOM(GLuint driverControl) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableIndexedEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glDisableVariantClientStateEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableVertexArrayAttribEXT(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableVertexArrayEXT(GLuint vaobj, GLenum array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glDisableVertexAttribAPPLE(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glDisableVertexAttribArrayARB(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glDisablei(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glDisableiEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glDisableiNV(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glDisableiOES(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_discard_framebuffer")
    void glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum* attachments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_compute_variable_group_size")
    void glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    void glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_instanced")
    void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    void glDrawArraysInstancedBaseInstanceEXT(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_instanced")
    void glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_instanced")
    void glDrawArraysInstancedNV(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers")
    void glDrawBuffersARB(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_draw_buffers")
    void glDrawBuffersATI(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers")
    void glDrawBuffersEXT(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    void glDrawBuffersIndexedEXT(GLint n, const GLenum* location, const GLint* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_buffers")
    void glDrawBuffersNV(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDrawCommandsAddressNV(GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDrawCommandsNV(GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDrawCommandsStatesAddressNV(const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDrawCommandsStatesNV(GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    void glDrawElementArrayATI(GLenum mode, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    void glDrawElementsBaseVertexEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    void glDrawElementsBaseVertexOES(GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    void glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_instanced")
    void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    void glDrawElementsInstancedBaseInstanceEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    void glDrawElementsInstancedBaseVertexBaseInstanceEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    void glDrawElementsInstancedBaseVertexEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    void glDrawElementsInstancedBaseVertexOES(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_instanced")
    void glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_instanced")
    void glDrawElementsInstancedNV(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_mesh_array")
    void glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    void glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    void glDrawRangeElementsBaseVertexEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    void glDrawRangeElementsBaseVertexOES(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_range_elements")
    void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexfvOES(const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexivOES(const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexsvOES(const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_texture")
    void glDrawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexxvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_transform_feedback")
    void glDrawTransformFeedbackEXT(GLenum mode, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_transform_feedback")
    void glDrawTransformFeedbackInstancedEXT(GLenum mode, GLuint id, GLsizei instancecount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glDrawTransformFeedbackNV(GLenum mode, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_EGL_image")
    void glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_EGL_image")
    void glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEdgeFlag(GLboolean flag) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glEdgeFlagFormatNV(GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glEdgeFlagPointer(GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glEdgeFlagPointerListIBM(GLint stride, const GLboolean** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEdgeFlagv(const GLboolean* flag) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glElementPointerAPPLE(GLenum type, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    void glElementPointerATI(GLenum type, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glEnableClientState(GLenum array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableClientStateIndexedEXT(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableClientStateiEXT(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    void glEnableDriverControlQCOM(GLuint driverControl) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableIndexedEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glEnableVariantClientStateEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableVertexArrayAttribEXT(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableVertexArrayEXT(GLuint vaobj, GLenum array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glEnableVertexAttribAPPLE(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glEnableVertexAttribArrayARB(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glEnablei(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glEnableiEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glEnableiNV(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glEnableiOES(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEnd() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glEndConditionalRender() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conditional_render")
    void glEndConditionalRenderNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NVX_conditional_render")
    void glEndConditionalRenderNVX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glEndFragmentShaderATI() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEndList() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glEndOcclusionQueryNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glEndPerfMonitorAMD(GLuint monitor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glEndPerfQueryINTEL(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glEndQuery(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glEndQueryARB(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glEndQueryEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    void glEndQueryIndexed(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_tiled_rendering")
    void glEndTilingQCOM(GLbitfield preserveMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glEndTransformFeedback() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glEndTransformFeedbackEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glEndTransformFeedbackNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glEndVertexShaderEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glEndVideoCaptureNV(GLuint video_capture_slot) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord1d(GLdouble u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord1dv(const GLdouble* u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord1f(GLfloat u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord1fv(const GLfloat* u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glEvalCoord1xOES(GLfixed u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glEvalCoord1xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord2d(GLdouble u, GLdouble v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord2dv(const GLdouble* u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord2f(GLfloat u, GLfloat v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord2fv(const GLfloat* u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glEvalCoord2xOES(GLfixed u, GLfixed v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glEvalCoord2xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glEvalMapsNV(GLenum target, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalMesh1(GLenum mode, GLint i1, GLint i2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalPoint1(GLint i) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalPoint2(GLint i, GLint j) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    void glEvaluateDepthValuesARB() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glExecuteProgramNV(GLenum target, GLuint id, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetBufferPointervQCOM(GLenum target, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetBuffersQCOM(GLuint* buffers, GLint maxBuffers, GLint* numBuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetFramebuffersQCOM(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    void glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar* source, GLint* length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    void glExtGetProgramsQCOM(GLuint* programs, GLint maxPrograms, GLint* numPrograms) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetRenderbuffersQCOM(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    void glExtGetShadersQCOM(GLuint* shaders, GLint maxShaders, GLint* numShaders) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* texels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetTexturesQCOM(GLuint* textures, GLint maxTextures, GLint* numTextures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    GLboolean glExtIsProgramBinaryQCOM(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glExtractComponentEXT(GLuint res, GLuint src, GLuint num) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat* buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glFeedbackBufferxOES(GLsizei n, GLenum type, const GLfixed* buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    GLsync glFenceSyncAPPLE(GLenum condition, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    GLint glFinishAsyncSGIX(GLuint* markerp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glFinishFenceAPPLE(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glFinishFenceNV(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glFinishObjectAPPLE(GLenum object, GLint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUNX_constant_data")
    void glFinishTextureSUNX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_flush_buffer_range")
    void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_map_buffer_range")
    void glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_pixel_data_range")
    void glFlushPixelDataRangeNV(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_flush_raster")
    void glFlushRasterSGIX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_static_data")
    void glFlushStaticDataIBM(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    void glFlushVertexArrayRangeAPPLE(GLsizei length, void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_array_range")
    void glFlushVertexArrayRangeNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glFogCoordFormatNV(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoordPointer(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoordPointerEXT(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glFogCoordPointerListIBM(GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoordd(GLdouble coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoorddEXT(GLdouble coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoorddv(const GLdouble* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoorddvEXT(const GLdouble* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoordf(GLfloat coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoordfEXT(GLfloat coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoordfv(const GLfloat* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoordfvEXT(const GLfloat* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glFogCoordhNV(GLhalfNV fog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glFogCoordhvNV(const GLhalfNV* fog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_fog_function")
    void glFogFuncSGIS(GLsizei n, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFogf(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFogfv(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFogi(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFogiv(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glFogx(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glFogxOES(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glFogxv(GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glFogxvOES(GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentColorMaterialSGIX(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_coverage_to_color")
    void glFragmentCoverageColorNV(GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightModelfSGIX(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightModelfvSGIX(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightModeliSGIX(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightModelivSGIX(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_GREMEDY_frame_terminator")
    void glFrameTerminatorGREMEDY() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_framezoom")
    void glFrameZoomSGIX(GLint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    void glFramebufferPixelLocalStorageSizeEXT(GLuint target, GLsizei size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    void glFramebufferSampleLocationsfvARB(GLenum target, GLuint start, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    void glFramebufferSampleLocationsfvNV(GLenum target, GLuint start, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_framebuffer_downsample")
    void glFramebufferTexture2DDownsampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisampled_render_to_texture")
    void glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_multisampled_render_to_texture")
    void glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    void glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_geometry_shader")
    void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    void glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_geometry_program4")
    void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    void glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_array")
    void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_framebuffer_downsample")
    void glFramebufferTextureLayerDownsampleIMG(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OVR_multiview_multisampled_render_to_texture")
    void glFramebufferTextureMultisampleMultiviewOVR(GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OVR_multiview")
    void glFramebufferTextureMultiviewOVR(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_geometry_shader")
    void glFramebufferTextureOES(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glFreeObjectBufferATI(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glFrustumf(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glFrustumx(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glFrustumxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    GLuint glGenAsyncMarkersSGIX(GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glGenBuffersARB(GLsizei n, GLuint* buffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glGenFencesAPPLE(GLsizei n, GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glGenFencesNV(GLsizei n, GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    GLuint glGenFragmentShadersATI(GLuint range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGenFramebuffersEXT(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGenFramebuffersOES(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLuint glGenLists(GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    void glGenNamesAMD(GLenum identifier, GLuint num, GLuint* names) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glGenOcclusionQueriesNV(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLuint glGenPathsNV(GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGenPerfMonitorsAMD(GLsizei n, GLuint* monitors) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glGenProgramPipelinesEXT(GLsizei n, GLuint* pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGenProgramsARB(GLsizei n, GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGenProgramsNV(GLsizei n, GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glGenQueriesARB(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGenQueriesEXT(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGenRenderbuffersEXT(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGenRenderbuffersOES(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    void glGenTexturesEXT(GLsizei n, GLuint* textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glGenTransformFeedbacksNV(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    void glGenVertexArraysAPPLE(GLsizei n, GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    void glGenVertexArraysOES(GLsizei n, GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glGenVertexShadersEXT(GLuint range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGenerateMipmapEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGenerateMipmapOES(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGenerateTextureMipmapEXT(GLuint texture, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetArrayObjectivATI(GLenum array, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB* obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetBooleani_v(GLenum target, GLuint index, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glGetBufferPointervARB(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    void glGetBufferPointervOES(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetClipPlane(GLenum plane, GLdouble* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetClipPlanef(GLenum plane, GLfloat* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glGetClipPlanefOES(GLenum plane, GLfloat* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetClipPlanex(GLenum plane, GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetClipPlanexOES(GLenum plane, GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetColorTable(GLenum target, GLenum format, GLenum type, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    void glGetColorTableEXT(GLenum target, GLenum format, GLenum type, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    void glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glGetColorTableSGI(GLenum target, GLenum format, GLenum type, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners2")
    void glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    GLuint glGetCommandHeaderNV(GLenum tokenID, GLuint size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glGetCompressedTexImageARB(GLenum target, GLint level, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetConvolutionParameterxvOES(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    void glGetCoverageModulationTableNV(GLsizei bufsize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    GLuint glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    GLuint glGetDebugMessageLogARB(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    GLuint glGetDebugMessageLogKHR(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_detail_texture")
    void glGetDetailTexFuncSGIS(GLenum target, GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glGetDoublei_v(GLenum target, GLuint index, GLdouble* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetDoublei_vEXT(GLenum pname, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetDoublev(GLenum pname, GLdouble* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    void glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    void glGetDriverControlsQCOM(GLint* num, GLsizei size, GLuint* driverControls) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glGetFenceivNV(GLuint fence, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetFirstPerfQueryIdINTEL(GLuint* queryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetFixedv(GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetFixedvOES(GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glGetFloati_v(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetFloati_vEXT(GLenum pname, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glGetFloati_vNV(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glGetFloati_vOES(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetFloatv(GLenum pname, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_fog_function")
    void glGetFogFuncSGIS(GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    GLint glGetFragDataIndexEXT(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    GLint glGetFragDataLocationEXT(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    GLsizei glGetFramebufferPixelLocalStorageSizeEXT(GLuint target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    GLenum glGetGraphicsResetStatusARB() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    GLenum glGetGraphicsResetStatusEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    GLenum glGetGraphicsResetStatusKHR() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    GLhandleARB glGetHandleARB(GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetHistogramParameterxvOES(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLuint64 glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLuint64 glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB* infoLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    GLint glGetInstrumentsSGIX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    void glGetInteger64i_v(GLenum target, GLuint index, GLint64* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    void glGetInteger64v(GLenum pname, GLint64* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    void glGetInteger64vAPPLE(GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetIntegeri_v(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    void glGetIntegeri_vEXT(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glGetIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT* result) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glGetIntegerui64vNV(GLenum value, GLuint64EXT* result) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetIntegerv(GLenum pname, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_internalformat_sample_query")
    void glGetInternalformatSampleivNV(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetLightfv(GLenum light, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetLightiv(GLenum light, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetLightxOES(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetLightxv(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetLightxvOES(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glGetListParameterivSGIX(GLuint list, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapParameterivNV(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMapdv(GLenum target, GLenum query, GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMapfv(GLenum target, GLenum query, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMapiv(GLenum target, GLenum query, GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetMapxvOES(GLenum target, GLenum query, GLfixed* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMaterialfv(GLenum face, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMaterialiv(GLenum face, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetMaterialxOES(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetMaterialxv(GLenum face, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetMaterialxvOES(GLenum face, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    void glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat* val) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glGetNamedStringARB(GLint namelen, const GLchar* name, GLsizei bufSize, GLint* stringlen, GLchar* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glGetNamedStringivARB(GLint namelen, const GLchar* name, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetNextPerfQueryIdINTEL(GLuint queryId, GLuint* nextQueryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_label")
    void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetObjectLabelKHR(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetObjectPtrLabelKHR(const void* ptr, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathColorGenivNV(GLenum color, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathCommandsNV(GLuint path, GLubyte* commands) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathCoordsNV(GLuint path, GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathDashArrayNV(GLuint path, GLfloat* dashArray) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLfloat glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLsizei stride, GLfloat* metrics) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathParameterfvNV(GLuint path, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathParameterivNV(GLuint path, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat* returnedSpacing) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetPerfCounterInfoINTEL(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar* counterDesc, GLuint* counterOffset, GLuint* counterDataSize, GLuint* counterTypeEnum, GLuint* counterDataTypeEnum, GLuint64* rawCounterMaxValue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetPerfQueryDataINTEL(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid* data, GLuint* bytesWritten) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetPerfQueryIdByNameINTEL(GLchar* queryName, GLuint* queryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetPerfQueryInfoINTEL(GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint* dataSize, GLuint* noCounters, GLuint* noInstances, GLuint* capsMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetPixelMapfv(GLenum map, GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetPixelMapuiv(GLenum map, GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetPixelMapusv(GLenum map, GLushort* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetPixelMapxv(GLenum map, GLint size, GLfixed* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glGetPixelTexGenParameterivSGIS(GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetPointerIndexedvEXT(GLenum target, GLuint index, void** data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetPointeri_vEXT(GLenum pname, GLuint index, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glGetPointervEXT(GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetPointervKHR(GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetPolygonStipple(GLubyte* mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_get_program_binary")
    void glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const(GLubyte)* name, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const(GLubyte)* name, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    GLint glGetProgramResourceLocationIndexEXT(GLuint program, GLenum programInterface, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetProgramResourcefvNV(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramStringARB(GLenum target, GLenum pname, void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetProgramStringNV(GLuint id, GLenum pname, GLubyte* program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program5")
    void glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramivARB(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetProgramivNV(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryObjectivEXT(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glGetQueryivARB(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glGetSamplerParameterIivEXT(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glGetSamplerParameterIivOES(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glGetSamplerParameterIuivEXT(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glGetSamplerParameterIuivOES(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, void* row, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, void* row, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB* source) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_sharpen_texture")
    void glGetSharpenTexFuncSGIS(GLenum target, GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    GLushort glGetStageIndexNV(GLenum shadertype) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    const(GLubyte)* glGetStringi(GLenum name, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    void glGetSyncivAPPLE(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    void glGetTexBumpParameterfvATI(GLenum pname, GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    void glGetTexBumpParameterivATI(GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexEnviv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetTexEnvxv(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetTexEnvxvOES(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_filter4")
    void glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexGendv(GLenum coord, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexGeniv(GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glGetTexGenivOES(GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetTexLevelParameterxvOES(GLenum target, GLint level, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glGetTexParameterIivOES(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glGetTexParameterIuivOES(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_texture_range")
    void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetTexParameterxv(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetTexParameterxvOES(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLuint64 glGetTextureHandleARB(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    GLuint64 glGetTextureHandleIMG(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLuint64 glGetTextureHandleNV(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLuint64 glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    GLuint64 glGetTextureSamplerHandleIMG(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLuint64 glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint* location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_translated_shader_source")
    void glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    GLint glGetUniformBufferSizeEXT(GLuint program, GLint location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    GLintptr glGetUniformOffsetEXT(GLuint program, GLint location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glGetUniformi64vARB(GLuint program, GLint location, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glGetUniformui64vARB(GLuint program, GLint location, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glGetUniformuivEXT(GLuint program, GLint location, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetVariantIntegervEXT(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetVariantPointervEXT(GLuint id, GLenum value, void** data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    GLint glGetVaryingLocationNV(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, void** param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, void** param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    void glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    void glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glGetVertexAttribPointervARB(GLuint index, GLenum pname, void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetVertexAttribPointervNV(GLuint index, GLenum pname, void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetVertexAttribivNV(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glGetVideoivNV(GLuint video_slot, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnColorTable(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnConvolutionFilter(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnMapdv(GLenum target, GLenum query, GLsizei bufSize, GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnMapfv(GLenum target, GLenum query, GLsizei bufSize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnMapiv(GLenum target, GLenum query, GLsizei bufSize, GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnPixelMapfv(GLenum map, GLsizei bufSize, GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnPixelMapuiv(GLenum map, GLsizei bufSize, GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnPixelMapusv(GLenum map, GLsizei bufSize, GLushort* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnPolygonStipple(GLsizei bufSize, GLubyte* pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnPolygonStippleARB(GLsizei bufSize, GLubyte* pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnSeparableFilter(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    void glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformfvKHR(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glGetnUniformi64vARB(GLuint program, GLint location, GLsizei bufSize, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    void glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformivKHR(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glGetnUniformui64vARB(GLuint program, GLint location, GLsizei bufSize, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformuivKHR(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorbSUN(GLbyte factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactordSUN(GLdouble factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorfSUN(GLfloat factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactoriSUN(GLint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorsSUN(GLshort factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorubSUN(GLubyte factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactoruiSUN(GLuint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorusSUN(GLushort factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_PGI_misc_hints")
    void glHintPGI(GLenum target, GLint mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_igloo_interface")
    void glIglooInterfaceSGIX(GLenum pname, const void* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_x11_sync_object")
    GLsync glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glIndexFormatNV(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_index_func")
    void glIndexFuncEXT(GLenum func, GLclampf ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexMask(GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_index_material")
    void glIndexMaterialEXT(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glIndexPointer(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glIndexPointerListIBM(GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexd(GLdouble c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexdv(const GLdouble* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexf(GLfloat c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexfv(const GLfloat* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexi(GLint c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexiv(const GLint* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexs(GLshort c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexsv(const GLshort* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glIndexub(GLubyte c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glIndexubv(const(GLubyte)* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glIndexxOES(GLfixed component) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glIndexxvOES(const GLfixed* component) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glInitNames() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glInsertComponentEXT(GLuint res, GLuint src, GLuint num) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    void glInsertEventMarkerEXT(GLsizei length, const GLchar* marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    void glInstrumentsBufferSGIX(GLsizei size, GLint* buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glInterleavedArrays(GLenum format, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    GLboolean glIsAsyncMarkerSGIX(GLuint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    GLboolean glIsBufferARB(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    GLboolean glIsBufferResidentNV(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    GLboolean glIsCommandListNV(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    GLboolean glIsEnabledi(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    GLboolean glIsEnablediEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    GLboolean glIsEnablediNV(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    GLboolean glIsEnablediOES(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    GLboolean glIsFenceAPPLE(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    GLboolean glIsFenceNV(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    GLboolean glIsFramebufferEXT(GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    GLboolean glIsFramebufferOES(GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLboolean glIsImageHandleResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLboolean glIsImageHandleResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLboolean glIsList(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    GLboolean glIsNameAMD(GLenum identifier, GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    GLboolean glIsNamedBufferResidentNV(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    GLboolean glIsNamedStringARB(GLint namelen, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    GLboolean glIsObjectBufferATI(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    GLboolean glIsOcclusionQueryNV(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLboolean glIsPathNV(GLuint path) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLboolean glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLboolean glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    GLboolean glIsProgramARB(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    GLboolean glIsProgramNV(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    GLboolean glIsProgramPipelineEXT(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    GLboolean glIsQueryARB(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    GLboolean glIsQueryEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    GLboolean glIsRenderbufferEXT(GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    GLboolean glIsRenderbufferOES(GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    GLboolean glIsStateNV(GLuint state) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    GLboolean glIsSyncAPPLE(GLsync sync) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    GLboolean glIsTextureEXT(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLboolean glIsTextureHandleResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLboolean glIsTextureHandleResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    GLboolean glIsTransformFeedbackNV(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLboolean glIsVariantEnabledEXT(GLuint id, GLenum cap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    GLboolean glIsVertexArrayAPPLE(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    GLboolean glIsVertexArrayOES(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_label")
    void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glLightEnviSGIX(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightModelf(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightModelfv(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightModeli(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightModeliv(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLightModelx(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLightModelxOES(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLightModelxv(GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLightModelxvOES(GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightf(GLenum light, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightfv(GLenum light, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLighti(GLenum light, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightiv(GLenum light, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLightx(GLenum light, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLightxOES(GLenum light, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLightxv(GLenum light, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLightxvOES(GLenum light, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLineStipple(GLint factor, GLushort pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLineWidthx(GLfixed width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLineWidthxOES(GLfixed width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glLinkProgramARB(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glListBase(GLuint base) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glListDrawCommandsStatesClientNV(GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glListParameteriSGIX(GLuint list, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glListParameterivSGIX(GLuint list, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLoadIdentity() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    void glLoadIdentityDeformationMapSGIX(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLoadMatrixd(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLoadMatrixf(const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLoadMatrixx(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLoadMatrixxOES(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLoadName(GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    void glLoadPaletteFromModelViewMatrixOES() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const(GLubyte)* program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glLoadTransposeMatrixd(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    void glLoadTransposeMatrixdARB(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glLoadTransposeMatrixf(const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    void glLoadTransposeMatrixfARB(const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLoadTransposeMatrixxOES(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_compiled_vertex_array")
    void glLockArraysEXT(GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glMakeBufferNonResidentNV(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glMakeBufferResidentNV(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glMakeImageHandleNonResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glMakeImageHandleNonResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glMakeImageHandleResidentARB(GLuint64 handle, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glMakeImageHandleResidentNV(GLuint64 handle, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glMakeNamedBufferNonResidentNV(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glMakeNamedBufferResidentNV(GLuint buffer, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glMakeTextureHandleNonResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glMakeTextureHandleNonResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glMakeTextureHandleResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glMakeTextureHandleResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMap1xOES(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMap2xOES(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void* glMapBufferARB(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    void* glMapBufferOES(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_map_buffer_range")
    void* glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMapGrid1xOES(GLint n, GLfixed u1, GLfixed u2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMapGrid2xOES(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void* glMapNamedBufferEXT(GLuint buffer, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void* glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_map_object_buffer")
    void* glMapObjectBufferATI(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glMapParameterivNV(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    void* glMapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum* layout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMaterialf(GLenum face, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMaterialfv(GLenum face, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMateriali(GLenum face, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMaterialiv(GLenum face, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glMaterialx(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMaterialxOES(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glMaterialxv(GLenum face, GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMaterialxvOES(GLenum face, GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    void glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glMatrixIndexubvARB(GLint size, const(GLubyte)* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glMatrixIndexuivARB(GLint size, const GLuint* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glMatrixIndexusvARB(GLint size, const GLushort* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixLoad3x2fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixLoad3x3fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoadIdentityEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixLoadTranspose3x3fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoadTransposedEXT(GLenum mode, const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoadTransposefEXT(GLenum mode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoaddEXT(GLenum mode, const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoadfEXT(GLenum mode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMatrixMode(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixMult3x2fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixMult3x3fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixMultTranspose3x3fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixMultTransposedEXT(GLenum mode, const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixMultTransposefEXT(GLenum mode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixMultdEXT(GLenum mode, const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixMultfEXT(GLenum mode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixPopEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixPushEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_parallel_shader_compile")
    void glMaxShaderCompilerThreadsARB(GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_image_load_store")
    void glMemoryBarrierEXT(GLbitfield barriers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_shading")
    void glMinSampleShadingARB(GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_sample_shading")
    void glMinSampleShadingOES(GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glMinmax(GLenum target, GLenum internalformat, GLboolean sink) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMultMatrixd(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMultMatrixf(const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glMultMatrixx(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultMatrixxOES(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultTransposeMatrixd(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    void glMultTransposeMatrixdARB(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultTransposeMatrixf(const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    void glMultTransposeMatrixfARB(const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultTransposeMatrixxOES(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_arrays")
    void glMultiDrawArraysEXT(GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_multi_draw_indirect")
    void glMultiDrawArraysIndirectAMD(GLenum mode, const void* indirect, GLsizei primcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect_count")
    void glMultiDrawArraysIndirectBindlessCountNV(GLenum mode, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect")
    void glMultiDrawArraysIndirectBindlessNV(GLenum mode, const void* indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_indirect_parameters")
    void glMultiDrawArraysIndirectCountARB(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_indirect")
    void glMultiDrawArraysIndirectEXT(GLenum mode, const void* indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    void glMultiDrawElementsBaseVertexEXT(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, const GLint* basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    void glMultiDrawElementsBaseVertexOES(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, const GLint* basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_arrays")
    void glMultiDrawElementsEXT(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_multi_draw_indirect")
    void glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const void* indirect, GLsizei primcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect_count")
    void glMultiDrawElementsIndirectBindlessCountNV(GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect")
    void glMultiDrawElementsIndirectBindlessNV(GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_indirect_parameters")
    void glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_indirect")
    void glMultiDrawElementsIndirectEXT(GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei* count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_multimode_draw_arrays")
    void glMultiModeDrawArraysIBM(const GLenum* mode, const GLint* first, const GLsizei* count, GLsizei primcount, GLint modestride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_multimode_draw_arrays")
    void glMultiModeDrawElementsIBM(const GLenum* mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, GLint modestride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord1bOES(GLenum texture, GLbyte s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord1bvOES(GLenum texture, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1d(GLenum target, GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1dARB(GLenum target, GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1dv(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1dvARB(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1f(GLenum target, GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1fARB(GLenum target, GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1fv(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1fvARB(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord1hNV(GLenum target, GLhalfNV s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord1hvNV(GLenum target, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1i(GLenum target, GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1iARB(GLenum target, GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1iv(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1ivARB(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1s(GLenum target, GLshort s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1sARB(GLenum target, GLshort s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1sv(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1svARB(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord1xOES(GLenum texture, GLfixed s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord1xvOES(GLenum texture, const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord2bOES(GLenum texture, GLbyte s, GLbyte t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord2bvOES(GLenum texture, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2dv(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2dvARB(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2fv(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2fvARB(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord2hvNV(GLenum target, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2i(GLenum target, GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2iv(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2ivARB(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2sv(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2svARB(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord2xOES(GLenum texture, GLfixed s, GLfixed t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord2xvOES(GLenum texture, const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord3bOES(GLenum texture, GLbyte s, GLbyte t, GLbyte r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord3bvOES(GLenum texture, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3dv(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3dvARB(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3fv(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3fvARB(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord3hvNV(GLenum target, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3iv(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3ivARB(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3sv(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3svARB(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord3xOES(GLenum texture, GLfixed s, GLfixed t, GLfixed r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord3xvOES(GLenum texture, const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord4bOES(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord4bvOES(GLenum texture, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4dv(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4dvARB(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4fv(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4fvARB(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord4hvNV(GLenum target, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4iv(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4ivARB(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4sv(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4svARB(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glMultiTexCoord4x(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord4xOES(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord4xvOES(GLenum texture, const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const void* data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    void glNamedBufferPageCommitmentARB(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    void glNamedBufferPageCommitmentEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedBufferStorageEXT(GLuint buffer, GLsizeiptr size, const void* data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    void glNamedFramebufferSampleLocationsfvARB(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    void glNamedFramebufferSampleLocationsfvNV(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glNamedStringARB(GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNewList(GLuint list, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    GLuint glNewObjectBufferATI(GLsizei size, const void* pointer, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3bv(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glNormal3fVertex3fvSUN(const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glNormal3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3i(GLint nx, GLint ny, GLint nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3s(GLshort nx, GLshort ny, GLshort nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glNormal3xOES(GLfixed nx, GLfixed ny, GLfixed nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glNormal3xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glNormalFormatNV(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glNormalP3ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glNormalP3uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glNormalPointer(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glNormalPointerListIBM(GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    void glNormalPointervINTEL(GLenum type, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3bATI(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3bvATI(GLenum stream, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3dATI(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3fATI(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3iATI(GLenum stream, GLint nx, GLint ny, GLint nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3sATI(GLenum stream, GLshort nx, GLshort ny, GLshort nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glObjectLabelKHR(GLenum identifier, GLuint name, GLsizei length, const GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glObjectPtrLabelKHR(const void* ptr, GLsizei length, const GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glOrthof(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glOrthox(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glOrthoxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_pn_triangles")
    void glPNTrianglesfATI(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_pn_triangles")
    void glPNTrianglesiATI(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPassThrough(GLfloat token) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPassThroughxOES(GLfixed token) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_tessellation_shader")
    void glPatchParameterfv(GLenum pname, const GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_tessellation_shader")
    void glPatchParameteriEXT(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_tessellation_shader")
    void glPatchParameteriOES(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathCommandsNV(GLuint path, GLsizei numCommands, const(GLubyte)* commands, GLsizei numCoords, GLenum coordType, const void* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const void* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathCoverDepthFuncNV(GLenum func) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat* dashArray) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathFogGenNV(GLenum genMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLenum glPathGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLenum glPathGlyphIndexRangeNV(GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void* charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLenum glPathMemoryGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void* fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathParameterfNV(GLuint path, GLenum pname, GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathParameteriNV(GLuint path, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathParameterivNV(GLuint path, GLenum pname, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathStencilFuncNV(GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathStringNV(GLuint path, GLenum format, GLsizei length, const void* pathString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const(GLubyte)* commands, GLsizei numCoords, GLenum coordType, const void* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glPauseTransformFeedbackNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_pixel_data_range")
    void glPixelDataRangeNV(GLenum target, GLsizei length, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPixelMapx(GLenum map, GLint size, const GLfixed* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelStorei(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPixelStorex(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glPixelTexGenParameteriSGIS(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glPixelTexGenParameterivSGIS(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_pixel_texture")
    void glPixelTexGenSGIX(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelTransferf(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelTransferi(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPixelTransferxOES(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glPixelTransformParameterfEXT(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glPixelTransformParameteriEXT(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelZoom(GLfloat xfactor, GLfloat yfactor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPixelZoomxOES(GLfixed xfactor, GLfixed yfactor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLboolean glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat* y, GLfloat* tangentX, GLfloat* tangentY) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_point_parameters")
    void glPointParameterfARB(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_point_parameters")
    void glPointParameterfEXT(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_point_parameters")
    void glPointParameterfSGIS(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glPointParameterfv(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_point_parameters")
    void glPointParameterfvARB(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_point_parameters")
    void glPointParameterfvEXT(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_point_parameters")
    void glPointParameterfvSGIS(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glPointParameteri(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_point_sprite")
    void glPointParameteriNV(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glPointParameteriv(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_point_sprite")
    void glPointParameterivNV(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPointParameterx(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPointParameterxOES(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPointParameterxv(GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPointParameterxvOES(GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_point_size_array")
    void glPointSizePointerOES(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPointSizex(GLfixed size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPointSizexOES(GLfixed size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    GLint glPollAsyncSGIX(GLuint* markerp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    GLint glPollInstrumentsSGIX(GLint* marker_p) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_polygon_mode")
    void glPolygonModeNV(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_polygon_offset_clamp")
    void glPolygonOffsetClampEXT(GLfloat factor, GLfloat units, GLfloat clamp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_polygon_offset")
    void glPolygonOffsetEXT(GLfloat factor, GLfloat bias) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPolygonOffsetx(GLfixed factor, GLfixed units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPolygonOffsetxOES(GLfixed factor, GLfixed units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPolygonStipple(const(GLubyte)* mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPopAttrib() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glPopClientAttrib() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glPopDebugGroupKHR() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    void glPopGroupMarkerEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPopMatrix() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPopName() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPrimitiveBoundingBox(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_ES3_2_compatibility")
    void glPrimitiveBoundingBoxARB(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_primitive_bounding_box")
    void glPrimitiveBoundingBoxEXT(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_primitive_bounding_box")
    void glPrimitiveBoundingBoxOES(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_primitive_restart")
    void glPrimitiveRestartIndexNV(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_primitive_restart")
    void glPrimitiveRestartNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glPrioritizeTextures(GLsizei n, const GLuint* textures, const GLfloat* priorities) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    void glPrioritizeTexturesEXT(GLsizei n, const GLuint* textures, const GLclampf* priorities) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPrioritizeTexturesxOES(GLsizei n, const GLuint* textures, const GLfixed* priorities) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_get_program_binary")
    void glProgramBinaryOES(GLuint program, GLenum binaryFormat, const void* binary, GLint length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    void glProgramBufferParametersIivNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    void glProgramBufferParametersIuivNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    void glProgramBufferParametersfvNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_program_parameters")
    void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_program_parameters")
    void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glProgramNamedParameter4dNV(GLuint id, GLsizei len, const(GLubyte)* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const(GLubyte)* name, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glProgramNamedParameter4fNV(GLuint id, GLsizei len, const(GLubyte)* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const(GLubyte)* name, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    void glProgramParameteriARB(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_geometry_shader4")
    void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glProgramPathFragmentInputGenNV(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program5")
    void glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1d(GLuint program, GLint location, GLdouble v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform1i64ARB(GLuint program, GLint location, GLint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1iEXT(GLuint program, GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform1ui64ARB(GLuint program, GLint location, GLuint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform1ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform2i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform2i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform2ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform2ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform3i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform3i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform3ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform3ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform4i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform4i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform4ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform4ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    void glProgramUniformHandleui64IMG(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    void glProgramUniformHandleui64vIMG(GLuint program, GLint location, GLsizei count, const GLuint64* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_geometry_program4")
    void glProgramVertexLimitNV(GLenum target, GLint limit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_provoking_vertex")
    void glProvokingVertexEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPushAttrib(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glPushClientAttrib(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glPushClientAttribDefaultEXT(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glPushDebugGroupKHR(GLenum source, GLuint id, GLsizei length, const GLchar* message) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    void glPushGroupMarkerEXT(GLsizei length, const GLchar* marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPushMatrix() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPushName(GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glQueryCounterEXT(GLuint id, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_query_matrix")
    GLbitfield glQueryMatrixxOES(GLfixed* mantissa, GLint* exponent) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_occlusion_query_event")
    void glQueryObjectParameteruiAMD(GLenum target, GLuint id, GLenum pname, GLuint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2d(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2f(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2i(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2s(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos2xOES(GLfixed x, GLfixed y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos2xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3i(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3s(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos3xOES(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos3xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4i(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos4xOES(GLfixed x, GLfixed y, GLfixed z, GLfixed w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos4xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_raster_multisample")
    void glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    void glReadBufferIndexedEXT(GLenum src, GLint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_read_buffer")
    void glReadBufferNV(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    void glReadInstrumentsSGIX(GLint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    void glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    void glReadnPixelsKHR(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectdv(const GLdouble* v1, const GLdouble* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectfv(const GLfloat* v1, const GLfloat* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRecti(GLint x1, GLint y1, GLint x2, GLint y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectiv(const GLint* v1, const GLint* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectsv(const GLshort* v1, const GLshort* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRectxOES(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRectxvOES(const GLfixed* v1, const GLfixed* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_reference_plane")
    void glReferencePlaneSGIX(const GLdouble* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLint glRenderMode(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_framebuffer_multisample")
    void glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_framebuffer_multisample")
    void glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_multisample_coverage")
    void glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_multisample")
    void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_multisampled_render_to_texture")
    void glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_multisample")
    void glRenderbufferStorageMultisampleNV(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodePointerSUN(GLenum type, GLsizei stride, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeubSUN(GLubyte code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeubvSUN(const(GLubyte)* code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor3fVertex3fvSUN(const GLuint* rc, const GLfloat* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint* rc, const(GLubyte)* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeuiSUN(GLuint code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiVertex3fvSUN(const GLuint* rc, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeuivSUN(const GLuint* code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeusSUN(GLushort code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeusvSUN(const GLushort* code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glRequestResidentProgramsNV(GLsizei n, const GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glResetHistogram(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glResetHistogramEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glResetMinmax(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glResetMinmaxEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_resize_buffers")
    void glResizeBuffersMESA() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    void glResolveDepthValuesNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_framebuffer_multisample")
    void glResolveMultisampleFramebufferAPPLE() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glResumeTransformFeedbackNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRotatexOES(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multisample")
    void glSampleCoverageARB(GLfloat value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glSampleCoveragex(GLclampx value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glSampleCoveragexOES(GLclampx value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisample")
    void glSampleMaskEXT(GLclampf value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    void glSampleMaskIndexedNV(GLuint index, GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_multisample")
    void glSampleMaskSGIS(GLclampf value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisample")
    void glSamplePatternEXT(GLenum pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_multisample")
    void glSamplePatternSGIS(GLenum pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glSamplerParameterIivEXT(GLuint sampler, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glSamplerParameterIivOES(GLuint sampler, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glSamplerParameterIuivEXT(GLuint sampler, GLenum pname, const GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glSamplerParameterIuivOES(GLuint sampler, GLenum pname, const GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glScaled(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glScalef(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glScalex(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glScalexOES(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glScissorArrayvNV(GLuint first, GLsizei count, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glScissorArrayvOES(GLuint first, GLsizei count, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glScissorIndexedNV(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glScissorIndexedOES(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glScissorIndexedvNV(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glScissorIndexedvOES(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3bv(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3bvEXT(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3dvEXT(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3fvEXT(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glSecondaryColor3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3i(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3ivEXT(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3svEXT(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3ubv(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3ubvEXT(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3uiv(const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3uivEXT(const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3usv(const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3usvEXT(const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glSecondaryColorP3ui(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glSecondaryColorP3uiv(GLenum type, const GLuint* color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glSelectBuffer(GLsizei size, GLuint* buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* row, const void* column) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* row, const void* column) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glSetFenceAPPLE(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glSetFenceNV(GLuint fence, GLenum condition) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glSetFragmentShaderConstantATI(GLuint dst, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glSetInvariantEXT(GLuint id, GLenum type, const void* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glSetLocalConstantEXT(GLuint id, GLenum type, const void* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sample_positions")
    void glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat* val) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glShadeModel(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB** string, const GLint* length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_sharpen_texture")
    void glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    void glSpriteParameterfSGIX(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    void glSpriteParameterfvSGIX(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    void glSpriteParameteriSGIX(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    void glSpriteParameterivSGIX(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    void glStartInstrumentsSGIX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_tiled_rendering")
    void glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glStateCaptureNV(GLuint state, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_stencil_clear_tag")
    void glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_separate_stencil")
    void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref_, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_separate_stencil")
    void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_stencil_operation_extended")
    void glStencilOpValueAMD(GLenum face, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilThenCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilThenCoverFillPathNV(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilThenCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilThenCoverStrokePathNV(GLuint path, GLint reference, GLuint mask, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    void glStopInstrumentsSGIX(GLint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_GREMEDY_string_marker")
    void glStringMarkerGREMEDY(GLsizei len, const void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster")
    void glSubpixelPrecisionBiasNV(GLuint xbits, GLuint ybits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glSwizzleEXT(GLuint res, GLuint in_, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    void glSyncTextureINTEL(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_tag_sample_buffer")
    void glTagSampleBufferSGIX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3bvEXT(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3dvEXT(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3fvEXT(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3iEXT(GLint tx, GLint ty, GLint tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3ivEXT(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3svEXT(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangentPointerEXT(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_3DFX_tbuffer")
    void glTbufferMask3DFX(GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_vertex_shader_tessellator")
    void glTessellationFactorAMD(GLfloat factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_vertex_shader_tessellator")
    void glTessellationModeAMD(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    GLboolean glTestFenceAPPLE(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    GLboolean glTestFenceNV(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    GLboolean glTestObjectAPPLE(GLenum object, GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_buffer_object")
    void glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_buffer")
    void glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_buffer")
    void glTexBufferOES(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_buffer")
    void glTexBufferRangeEXT(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_buffer")
    void glTexBufferRangeOES(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    void glTexBumpParameterfvATI(GLenum pname, const GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    void glTexBumpParameterivATI(GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord1bOES(GLbyte s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord1bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1d(GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1f(GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord1hNV(GLhalfNV s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord1hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1i(GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1s(GLshort s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord1xOES(GLfixed s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord1xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord2bOES(GLbyte s, GLbyte t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord2bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2d(GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2f(GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor3fVertex3fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor4ubVertex3fvSUN(const GLfloat* tc, const(GLubyte)* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fNormal3fVertex3fvSUN(const GLfloat* tc, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fVertex3fvSUN(const GLfloat* tc, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord2hNV(GLhalfNV s, GLhalfNV t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord2hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2i(GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2s(GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord2xOES(GLfixed s, GLfixed t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord2xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord3bOES(GLbyte s, GLbyte t, GLbyte r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord3bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3i(GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3s(GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord3xOES(GLfixed s, GLfixed t, GLfixed r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord3xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord4bOES(GLbyte s, GLbyte t, GLbyte r, GLbyte q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord4bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord4fVertex4fvSUN(const GLfloat* tc, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord4hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4i(GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord4xOES(GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord4xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP1ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP1uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP2ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP2uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP3ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP3uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP4ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP4uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    void glTexCoordPointervINTEL(GLint size, GLenum type, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexEnvf(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexEnvfv(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexEnvi(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexEnviv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTexEnvx(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexEnvxOES(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTexEnvxv(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexEnvxvOES(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_filter4")
    void glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGend(GLenum coord, GLenum pname, GLdouble param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGendv(GLenum coord, GLenum pname, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGenf(GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glTexGenfOES(GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGenfv(GLenum coord, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGeni(GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glTexGeniOES(GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGeniv(GLenum coord, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glTexGenivOES(GLenum coord, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexGenxOES(GLenum coord, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture3D")
    void glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture4D")
    void glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_texture")
    void glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_sparse_texture")
    void glTexPageCommitmentEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glTexParameterIiv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glTexParameterIivEXT(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glTexParameterIivOES(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glTexParameterIuivOES(GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexParameteriv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTexParameterx(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexParameterxOES(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTexParameterxv(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexParameterxvOES(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    void glTexRenderbufferNV(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    void glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    void glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    void glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_storage_multisample_2d_array")
    void glTexStorage3DMultisampleOES(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sparse_texture")
    void glTexStorageSparseAMD(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_subtexture")
    void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_subtexture")
    void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture3D")
    void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture4D")
    void glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_barrier")
    void glTextureBarrierNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_color_mask")
    void glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    void glTextureLightEXT(GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    void glTextureMaterialEXT(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_perturb_normal")
    void glTextureNormalEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTexturePageCommitmentEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameterIiv(GLuint texture, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameterf(GLuint texture, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameteri(GLuint texture, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameteriv(GLuint texture, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_texture_range")
    void glTextureRangeAPPLE(GLenum target, GLsizei length, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sparse_texture")
    void glTextureStorageSparseAMD(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_view")
    void glTextureViewEXT(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_view")
    void glTextureViewOES(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glTransformFeedbackAttribsNV(GLsizei count, const GLint* attribs, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glTransformFeedbackStreamAttribsNV(GLsizei count, const GLint* attribs, GLsizei nbuffers, const GLint* bufstreams, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const(const(GLvoid*)*) varyings, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint* locations, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTranslated(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTranslatef(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTranslatex(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTranslatexOES(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform1d(GLint location, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform1dv(GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform1fARB(GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform1fvARB(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform1i64ARB(GLint location, GLint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform1i64NV(GLint location, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform1i64vARB(GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform1iARB(GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform1ivARB(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform1ui64ARB(GLint location, GLuint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform1ui64NV(GLint location, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform1ui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform1uiEXT(GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform1uivEXT(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform2d(GLint location, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform2dv(GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform2fvARB(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform2i64ARB(GLint location, GLint64 x, GLint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform2i64vARB(GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform2iARB(GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform2ivARB(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform2ui64ARB(GLint location, GLuint64 x, GLuint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform2ui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform2uivEXT(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform3dv(GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform3fvARB(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform3i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform3i64vARB(GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform3ivARB(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform3ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform3ui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform3uivEXT(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform4dv(GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform4fvARB(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform4i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform4i64vARB(GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform4ivARB(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform4ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform4ui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform4uivEXT(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glUniformHandleui64ARB(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    void glUniformHandleui64IMG(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glUniformHandleui64NV(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    void glUniformHandleui64vIMG(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix2x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix2x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix3x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix3x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix4x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix4x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glUniformui64NV(GLint location, GLuint64EXT value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_compiled_vertex_array")
    void glUnlockArraysEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    GLboolean glUnmapBufferARB(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    GLboolean glUnmapBufferOES(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    GLboolean glUnmapNamedBufferEXT(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_map_object_buffer")
    void glUnmapObjectBufferATI(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    void glUnmapTexture2DINTEL(GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const void* pointer, GLenum preserve) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUseProgramObjectARB(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glUseShaderProgramEXT(GLenum type, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUFiniNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUInitNV(const void* vdpDevice, const void* getProcAddress) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    GLboolean glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    GLvdpauSurfaceNV glVDPAURegisterOutputSurfaceNV(const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceNV(const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUUnmapSurfacesNV(GLsizei numSurface, const GLvdpauSurfaceNV* surfaces) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glValidateProgramARB(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glValidateProgramPipelineEXT(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const void* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantbvEXT(GLuint id, const GLbyte* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantdvEXT(GLuint id, const GLdouble* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantfvEXT(GLuint id, const GLfloat* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantivEXT(GLuint id, const GLint* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantsvEXT(GLuint id, const GLshort* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantubvEXT(GLuint id, const(GLubyte)* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantuivEXT(GLuint id, const GLuint* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantusvEXT(GLuint id, const GLushort* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex2bOES(GLbyte x, GLbyte y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex2bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2d(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2f(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex2hNV(GLhalfNV x, GLhalfNV y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex2hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2i(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2s(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex2xOES(GLfixed x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex2xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex3bOES(GLbyte x, GLbyte y, GLbyte z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex3bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3d(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3f(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3i(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3s(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex3xOES(GLfixed x, GLfixed y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex3xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex4bOES(GLbyte x, GLbyte y, GLbyte z, GLbyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex4bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex4hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4i(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex4xOES(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex4xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    void glVertexArrayParameteriAPPLE(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    void glVertexArrayRangeAPPLE(GLsizei length, void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_array_range")
    void glVertexArrayRangeNV(GLsizei length, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribDivisorEXT(GLuint vaobj, GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1dARB(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1dNV(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1dvARB(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1dvNV(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1fARB(GLuint index, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1fNV(GLuint index, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1fvARB(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1fvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib1hNV(GLuint index, GLhalfNV x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib1hvNV(GLuint index, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1sARB(GLuint index, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1sNV(GLuint index, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1svARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1svNV(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2dvARB(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2dvNV(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2fvARB(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2fvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib2hvNV(GLuint index, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2svARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2svNV(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3dvARB(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3dvNV(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3fvARB(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3fvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib3hvNV(GLuint index, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3svARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3svNV(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NbvARB(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NivARB(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NsvARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NubvARB(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NuivARB(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NusvARB(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4bvARB(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4dvARB(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4dvNV(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4fvARB(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4fvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib4hvNV(GLuint index, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4ivARB(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4svARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4svNV(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4ubvARB(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4ubvNV(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4uivARB(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4usvARB(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    void glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    void glVertexAttribDivisorANGLE(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_instanced_arrays")
    void glVertexAttribDivisorARB(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_instanced_arrays")
    void glVertexAttribDivisorEXT(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_instanced_arrays")
    void glVertexAttribDivisorNV(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI1iEXT(GLuint index, GLint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI1ivEXT(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI1uiEXT(GLuint index, GLuint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI1uivEXT(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI2ivEXT(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI2uivEXT(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI3ivEXT(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI3uivEXT(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4bvEXT(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4ivEXT(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4svEXT(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4ubvEXT(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4uivEXT(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4usvEXT(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL1dEXT(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL1dvEXT(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL1i64NV(GLuint index, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL1i64vNV(GLuint index, const GLint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL2dvEXT(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL2i64vNV(GLuint index, const GLint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL3dvEXT(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL3i64vNV(GLuint index, const GLint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL4dvEXT(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL4i64vNV(GLuint index, const GLint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_interleaved_elements")
    void glVertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs1dvNV(GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs1fvNV(GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttribs1hvNV(GLuint index, GLsizei n, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs1svNV(GLuint index, GLsizei count, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs2dvNV(GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs2fvNV(GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttribs2hvNV(GLuint index, GLsizei n, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs2svNV(GLuint index, GLsizei count, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs3dvNV(GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs3fvNV(GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttribs3hvNV(GLuint index, GLsizei n, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs3svNV(GLuint index, GLsizei count, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs4dvNV(GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs4fvNV(GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttribs4hvNV(GLuint index, GLsizei n, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs4svNV(GLuint index, GLsizei count, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs4ubvNV(GLuint index, GLsizei count, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glVertexBlendARB(GLint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexBlendEnvfATI(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexBlendEnviATI(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glVertexFormatNV(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP2ui(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP2uiv(GLenum type, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP3ui(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP3uiv(GLenum type, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP4ui(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP4uiv(GLenum type, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glVertexPointer(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    void glVertexPointervINTEL(GLint size, GLenum type, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1dATI(GLenum stream, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1fATI(GLenum stream, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1iATI(GLenum stream, GLint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1sATI(GLenum stream, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2iATI(GLenum stream, GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2sATI(GLenum stream, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    void glVertexWeightPointerEXT(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    void glVertexWeightfEXT(GLfloat weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    void glVertexWeightfvEXT(const GLfloat* weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexWeighthNV(GLhalfNV weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexWeighthvNV(const GLhalfNV* weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    GLenum glVideoCaptureNV(GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT* capture_time) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glViewportArrayvNV(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glViewportArrayvOES(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glViewportIndexedfOES(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glViewportIndexedfNV(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glViewportIndexedfv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glViewportIndexedfvOES(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glViewportIndexedfvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_clip_space_w_scaling")
    void glViewportPositionWScaleNV(GLuint index, GLfloat xcoeff, GLfloat ycoeff) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_swizzle")
    void glViewportSwizzleNV(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    void glWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint* paths, const GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    void glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightbvARB(GLint size, const GLbyte* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightdvARB(GLint size, const GLdouble* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightfvARB(GLint size, const GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightivARB(GLint size, const GLint* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightsvARB(GLint size, const GLshort* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightubvARB(GLint size, const(GLubyte)* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightuivARB(GLint size, const GLuint* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightusvARB(GLint size, const GLushort* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2d(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2dARB(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2dMESA(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2dvARB(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2dvMESA(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2f(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2fARB(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2fMESA(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2fvARB(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2fvMESA(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2i(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2iARB(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2iMESA(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2ivARB(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2ivMESA(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2s(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2sARB(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2sMESA(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2svARB(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2svMESA(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3dvARB(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3dvMESA(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3fvARB(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3fvMESA(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3i(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3iARB(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3iMESA(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3ivARB(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3ivMESA(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3s(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3sARB(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3sMESA(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3svARB(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3svMESA(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4dvMESA(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4fvMESA(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4ivMESA(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4svMESA(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_window_rectangles")
    void glWindowRectanglesEXT(GLenum mode, GLsizei count, const GLint* box) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glWriteMaskEXT(GLuint res, GLuint in_, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) @system @nogc nothrow;
}
